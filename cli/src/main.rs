use std::{
    path::{
        Path, 
        PathBuf,
    }, 
    fs,
};

use clap::{
    Parser, 
    Subcommand, 
    CommandFactory,
    error::ErrorKind,
};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// parse source code
    Parse {
        /// Sets source code folder path which will be parsed
        #[arg(short, long, value_name = "SOURCES")]
        src: Vec<PathBuf>,
    
        /// Sets output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT")]
        output: PathBuf,

        /// Sets paths which need be excluded folder or file
        #[arg(short = 'x', long, value_name = "EXCLUDES")]
        exclude: Option<Vec<String>>
    },

    /// data extraction
    Extract {
        /// Sets metadata file folder path which is generated by 'Parse' command
        #[arg(short, long, value_name = "METADATAS")]
        metadata: Vec<PathBuf>,
    
        /// Sets output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT")]
        output: PathBuf,

        /// Sets paths which need be excluded folder or file
        #[arg(short = 'x', long, value_name = "EXCLUDES")]
        exclude: Option<Vec<String>>
    },

    /// data mapping, will generates a file contains combined elements
    Map {
        /// Sets metadata file folder path which is generated by 'Extraction' command
        #[arg(short, long, value_name = "ELEMENTS")]
        element: Vec<PathBuf>,
    
        /// Sets output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT")]
        output: PathBuf,

        /// Sets paths which need be excluded folder or file
        #[arg(short = 'x', long, value_name = "EXCLUDES")]
        exclude: Option<Vec<String>>
    },

    /// analysing, will generates a file contains analysed data
    Analysis {
        /// Sets data file path which is generated by 'Map' command
        #[arg(short, long, value_name = "DATA")]
        data: PathBuf,
    
        /// Sets output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT")]
        output: PathBuf,
    },

    /// generates report
    Report {
        /// Sets data file path which is generated by 'Analysis' command
        #[arg(short, long, value_name = "DATA")]
        data: PathBuf,
    
        /// Sets output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT")]
        output: PathBuf,
    },

    /// pipeline
    Pipeline {
        /// Sets the file path of config
        #[arg(short, long, value_name = "CONFIG")]
        config: PathBuf,
    
        /// Sets output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT")]
        output: PathBuf,
    }
}

fn main() {
    let cli = Cli::parse();

    let extend_excludes = |excludes: &Vec<String>| -> Vec<PathBuf> {
        let mut excluded_paths: Vec<PathBuf> = Vec::new();
        for exclude in excludes {
            if let Ok(path) = fs::canonicalize(exclude) {
                excluded_paths.push(path);
            }
        }
        excluded_paths
    };

    match &cli.command {
        Some(Commands::Parse { src: sources, output, exclude: excludes }) => {
            let mut validated_sources: Vec<PathBuf> = Vec::new();
            for source in sources {
                match fs::canonicalize(source) {
                    Ok(canonicalize_path) => validated_sources.push(canonicalize_path),
                    Err(err) => {
                        let mut cmd = Cli::command();
                        cmd.error(ErrorKind::InvalidValue, 
                            format!("{}: {}", err, source.to_str().unwrap())).exit();
                    }
                }
            }

            let output_dir = fs::canonicalize(Path::new(output));
            if let Err(e) = output_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, output.to_str().unwrap())).exit();
            }

            let excluded_paths = match excludes {
                Some(ex) => extend_excludes(ex),
                None => Vec::new()
            };

            match suzaku_core::parse(&validated_sources, &output_dir.unwrap(), &excluded_paths) {
                Ok(metadata_files_folder) => println!("Parsed results already stored at: {}", metadata_files_folder.to_str().unwrap()),
                Err(err) => panic!("[ERROR] {:?}", err)
            }
        },
        Some(Commands::Extract { metadata: metadatas, output, exclude: excludes }) => {
            let mut validated_metadatas: Vec<PathBuf> = Vec::new();
            for metadata in metadatas {
                match fs::canonicalize(metadata) {
                    Ok(canonicalize_path) => validated_metadatas.push(canonicalize_path),
                    Err(err) => {
                        let mut cmd = Cli::command();
                        cmd.error(ErrorKind::InvalidValue, 
                            format!("{}: {}", err, metadata.to_str().unwrap())).exit();
                    }
                }
            }

            let output_dir = fs::canonicalize(Path::new(output));
            if let Err(e) = output_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, output.to_str().unwrap())).exit();
            }

            let excluded_paths = match excludes {
                Some(ex) => extend_excludes(ex),
                None => Vec::new()
            };

            match suzaku_core::extract(&validated_metadatas, &output_dir.unwrap(), &excluded_paths) {
                Ok(vertex_files_folder) => println!("Extracted data already stored at: {}", vertex_files_folder.to_str().unwrap()),
                Err(err) => panic!("[ERROR] {:?}", err)
            }
        },
        Some(Commands::Map { element: elements, output, exclude: excludes }) => {
            let mut validated_elements: Vec<PathBuf> = Vec::new();
            for metadata in elements {
                match fs::canonicalize(metadata) {
                    Ok(canonicalize_path) => validated_elements.push(canonicalize_path),
                    Err(err) => {
                        let mut cmd = Cli::command();
                        cmd.error(ErrorKind::InvalidValue, 
                            format!("{}: {}", err, metadata.to_str().unwrap())).exit();
                    }
                }
            }

            let output_dir = fs::canonicalize(Path::new(output));
            if let Err(e) = output_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, output.to_str().unwrap())).exit();
            }

            let excluded_paths = match excludes {
                Some(ex) => extend_excludes(ex),
                None => Vec::new()
            };

            match suzaku_core::map(&validated_elements, &output_dir.unwrap(), &excluded_paths) {
                Ok(vertex_files_folder) => println!("Mapped data already stored at: {}", vertex_files_folder.to_str().unwrap()),
                Err(err) => panic!("[ERROR] {:?}", err)
            }
        },
        Some(Commands::Analysis { data, output }) => {
            let validated_data_file = match fs::canonicalize(data) {
                Ok(canonicalize_path) => canonicalize_path,
                Err(err) => {
                    let mut cmd = Cli::command();
                    cmd.error(ErrorKind::InvalidValue, 
                        format!("{}: {}", err, data.to_str().unwrap())).exit();
                }
            };

            let output_dir = fs::canonicalize(Path::new(output));
            if let Err(e) = output_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, output.to_str().unwrap())).exit();
            }

            match suzaku_core::analysis(&validated_data_file, &output_dir.as_ref().unwrap()) {
                Ok(vertex_file) => println!("Anslysed results already stored at: {}", vertex_file.to_str().unwrap()),
                Err(err) => panic!("[ERROR] {:?}", err)
            }
        },
        Some(Commands::Report { data, output }) => {
            let validated_data_file = match fs::canonicalize(data) {
                Ok(canonicalize_path) => canonicalize_path,
                Err(err) => {
                    let mut cmd = Cli::command();
                    cmd.error(ErrorKind::InvalidValue, 
                        format!("{}: {}", err, data.to_str().unwrap())).exit();
                }
            };

            let output_dir = fs::canonicalize(Path::new(output));
            if let Err(e) = output_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, output.to_str().unwrap())).exit();
            }

            match suzaku_core::report(&validated_data_file, &output_dir.as_ref().unwrap()) {
                Ok(vertex_file) => println!("Report file already stored at: {}", vertex_file.to_str().unwrap()),
                Err(err) => panic!("[ERROR] {:?}", err)
            }
        },
        Some(Commands::Pipeline { config, output }) => {
        },
        None => {
            let mut cmd = Cli::command();
            cmd.error(
                ErrorKind::MissingSubcommand,
                "Missing required command",
            ).exit();
        }
    }
}
