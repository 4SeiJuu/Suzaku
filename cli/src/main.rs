extern crate core;
extern crate clap;

use std::{
    path::{
        Path, 
        PathBuf,
    }, 
    fs,
};

use clap::{
    Parser, 
    Subcommand, 
    CommandFactory,
    error::ErrorKind,
};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// Sets a custom config file
    #[arg(short, long, value_name = "FILE")]
    config: Option<PathBuf>,

    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// parse source code
    Parse {
        /// Sets source code folder path which will be parsed
        #[arg(short, long, value_name = "SRC", default_value_t = String::from("."))]
        src: String,
    
        /// Set output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT", default_value_t = String::from("."))]
        output: String,

        /// Set paths which need be excluded folder or file
        #[arg(short, long, value_name = "EXCLUDES")]
        exclude: Option<Vec<String>>
    },

    /// analysis source code
    Analysis {
        /// Sets source code folder path which will be analyzed
        #[arg(short, long, value_name = "SRC", group = "src-data")]
        src: Option<String>,

        /// Sets metadata file folder path which is generated by 'Parse' command
        #[arg(short, long, value_name = "METADATA", group = "src-data")]
        metadata: Option<String>,
    
        /// Set output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT", default_value_t = String::from("."))]
        output: String,

        /// Set paths which need be excluded folder or file
        #[arg(short, long, value_name = "EXCLUDES")]
        exclude: Option<Vec<String>>
    },
}

fn main() {
    let cli = Cli::parse();

    let extend_excludes = |excludes: &Vec<String>| -> Vec<PathBuf> {
        let mut excluded_paths: Vec<PathBuf> = Vec::new();
        for exclude in excludes {
            if let Ok(path) = fs::canonicalize(exclude) {
                excluded_paths.push(path);
            }
        }
        excluded_paths
    };

    match &cli.command {
        Some(Commands::Parse { src, output, exclude: excludes }) => {
            let src_dir = fs::canonicalize(Path::new(src));
            if let Err(e) = src_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, src)).exit();
            }

            let output_dir = fs::canonicalize(Path::new(output));
            if let Err(e) = output_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, output)).exit();
            }

            let excluded_paths = match excludes {
                Some(ex) => extend_excludes(ex),
                None => Vec::new()
            };

            match suzaku_core::parse(&src_dir.unwrap(), &output_dir.unwrap(), excluded_paths) {
                Ok(metadata_files_folder) => println!("Parsed results already stored at: {}", metadata_files_folder.to_str().unwrap()),
                Err(err) => panic!("[ERROR] {:?}", err)
            }
        },
        Some(Commands::Analysis { src, metadata, output, exclude: excludes}) => {
            match fs::canonicalize(Path::new(output)) {
                Ok(output_dir) => {
                    if let Some(src) = src {
                        let src_dir = fs::canonicalize(Path::new(src));
                        if let Err(e) = src_dir {
                            let mut cmd = Cli::command();
                            cmd.error(ErrorKind::InvalidValue, 
                                format!("{}: {}", e, src)).exit();
                        }

                        let excluded_paths = match excludes {
                            Some(ex) => extend_excludes(ex),
                            None => Vec::new()
                        };
        
                        match suzaku_core::parse(&src_dir.unwrap(), &output_dir, excluded_paths) {
                            Ok(metadata_dir) => {
                                match suzaku_core::data_clean(&metadata_dir, &output_dir) {
                                    Ok(vertex_files_folder) => println!("Cleaned data results already stored at: {}", vertex_files_folder.to_str().unwrap()),
                                    Err(err) => panic!("[ERROR] {:?}", err)
                                }
                            }
                            Err(err) => panic!("ERROR: {:?}", err)
                        }
                    } else if let Some(metadata) = metadata {
                        let metadata_dir = fs::canonicalize(Path::new(metadata));
                        if let Err(e) = metadata_dir {
                            let mut cmd = Cli::command();
                            cmd.error(ErrorKind::InvalidValue, 
                                format!("{}: {}", e, metadata)).exit();
                        }
        
                        match suzaku_core::data_clean(&metadata_dir.unwrap(), &output_dir) {
                            Ok(vertex_files_folder) => println!("Cleaned data results already stored at: {}", vertex_files_folder.to_str().unwrap()),
                            Err(err) => panic!("[ERROR] {:?}", err)
                        }
                    } else {
                        let mut cmd = Cli::command();
                        cmd.error(ErrorKind::MissingRequiredArgument, 
                            "Missing required arguments").exit();
                    }
                },
                Err(e) => {
                    let mut cmd = Cli::command();
                    cmd.error(ErrorKind::InvalidValue, 
                        format!("{}: {}", e, output)).exit();
                }
            }
        },
        None => {
            let mut cmd = Cli::command();
            cmd.error(
                ErrorKind::MissingSubcommand,
                "Missing required command",
            ).exit();
        }
    }
}
