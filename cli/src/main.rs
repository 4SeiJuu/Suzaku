extern crate core;
extern crate clap;

use std::{
    path::{
        Path, 
        PathBuf,
    }, 
    fs
};

use clap::{
    Parser, 
    Subcommand, 
    CommandFactory,
    error::ErrorKind,
};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// Sets a custom config file
    #[arg(short, long, value_name = "FILE")]
    config: Option<PathBuf>,

    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// parse source code
    Parse {
        /// Sets source code folder path which will be parsed
        #[arg(short, long, value_name = "SRC", default_value_t = String::from("."))]
        src: String,
    
        /// Set output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT", default_value_t = String::from("."))]
        output: String,
    },

    /// analysis source code
    Analysis {
        /// Sets source code folder path which will be analyzed
        #[arg(short, long, value_name = "SRC", group = "src-data")]
        src: Option<String>,

        /// Sets metadata file folder path which is generated by 'Parse' command
        #[arg(short, long, value_name = "METADATA", group = "src-data")]
        metadata: Option<String>,
    
        /// Set output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT", default_value_t = String::from("."))]
        output: String,
    },
}

fn main() {
    let cli = Cli::parse();

    match &cli.command {
        Some(Commands::Parse { src, output }) => {
            let src_dir = fs::canonicalize(Path::new(src));
            if let Err(e) = src_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, src)).exit();
            }

            let output_dir = fs::canonicalize(Path::new(output));
            if let Err(e) = output_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, output)).exit();
            }

            suzaku_core::parse(&src_dir.unwrap(), &output_dir.unwrap());
        },
        Some(Commands::Analysis { src, metadata, output }) => {
            let output_dir = fs::canonicalize(Path::new(output));
            if let Err(e) = output_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, output)).exit();
            }

            if let Some(src) = src {
                let src_dir = fs::canonicalize(Path::new(src));
                if let Err(e) = src_dir {
                    let mut cmd = Cli::command();
                    cmd.error(ErrorKind::InvalidValue, 
                        format!("{}: {}", e, src)).exit();
                }

                // TODO: run analysing with source code
            } else if let Some(metadata) = metadata {
                let metadata_dir = fs::canonicalize(Path::new(metadata));
                if let Err(e) = metadata_dir {
                    let mut cmd = Cli::command();
                    cmd.error(ErrorKind::InvalidValue, 
                        format!("{}: {}", e, metadata)).exit();
                }

                // TODO: run analysing with metadata
            } else {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::MissingRequiredArgument, 
                    "Missing required arguments").exit();
            }
        },
        None => {
            let mut cmd = Cli::command();
            cmd.error(
                ErrorKind::MissingSubcommand,
                "Missing required command",
            ).exit();
        }
    }
}
