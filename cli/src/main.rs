extern crate core;
extern crate clap;

use std::{
    path::{
        Path, 
        PathBuf,
    }, 
    fs,
};

use clap::{
    Parser, 
    Subcommand, 
    CommandFactory,
    error::ErrorKind,
};

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// Sets a custom config file
    #[arg(short, long, value_name = "FILE")]
    config: Option<PathBuf>,

    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    /// parse source code
    Parse {
        /// Sets source code folder path which will be parsed
        #[arg(short, long, value_name = "SRC", default_value_t = String::from("."))]
        src: String,
    
        /// Set output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT", default_value_t = String::from("."))]
        output: String,
    },

    /// analysis source code
    Analysis {
        /// Sets source code folder path which will be analyzed
        #[arg(short, long, value_name = "SRC", group = "src-data")]
        src: Option<String>,

        /// Sets metadata file folder path which is generated by 'Parse' command
        #[arg(short, long, value_name = "METADATA", group = "src-data")]
        metadata: Option<String>,
    
        /// Set output folder path which will store the output files
        #[arg(short, long, value_name = "OUTPUT", default_value_t = String::from("."))]
        output: String,
    },
}

fn main() {
    let cli = Cli::parse();

    match &cli.command {
        Some(Commands::Parse { src, output }) => {
            let src_dir = fs::canonicalize(Path::new(src));
            if let Err(e) = src_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, src)).exit();
            }

            let output_dir = fs::canonicalize(Path::new(output));
            if let Err(e) = output_dir {
                let mut cmd = Cli::command();
                cmd.error(ErrorKind::InvalidValue, 
                    format!("{}: {}", e, output)).exit();
            }

            match suzaku_core::parse(&src_dir.unwrap(), &output_dir.unwrap()) {
                Ok(metadata_files_folder) => println!("Parsed results already stored at: {}", metadata_files_folder.to_str().unwrap()),
                Err(err) => panic!("[ERROR] {:?}", err)
            }
        },
        Some(Commands::Analysis { src, metadata, output }) => {
            match fs::canonicalize(Path::new(output)) {
                Ok(output_dir) => {
                    if let Some(src) = src {
                        let src_dir = fs::canonicalize(Path::new(src));
                        if let Err(e) = src_dir {
                            let mut cmd = Cli::command();
                            cmd.error(ErrorKind::InvalidValue, 
                                format!("{}: {}", e, src)).exit();
                        }
        
                        match suzaku_core::parse(&src_dir.unwrap(), &output_dir) {
                            Ok(metadata_dir) => {
                                match suzaku_core::analysis(&metadata_dir, &output_dir) {
                                    Ok(vertex_files_folder) => println!("Analysized results already stored at: {}", vertex_files_folder.to_str().unwrap()),
                                    Err(err) => panic!("[ERROR] {:?}", err)
                                }
                            }
                            Err(err) => panic!("ERROR: {:?}", err)
                        }
                    } else if let Some(metadata) = metadata {
                        let metadata_dir = fs::canonicalize(Path::new(metadata));
                        if let Err(e) = metadata_dir {
                            let mut cmd = Cli::command();
                            cmd.error(ErrorKind::InvalidValue, 
                                format!("{}: {}", e, metadata)).exit();
                        }
        
                        match suzaku_core::analysis(&metadata_dir.unwrap(), &output_dir) {
                            Ok(vertex_files_folder) => println!("Analysized results already stored at: {}", vertex_files_folder.to_str().unwrap()),
                            Err(err) => panic!("[ERROR] {:?}", err)
                        }
                    } else {
                        let mut cmd = Cli::command();
                        cmd.error(ErrorKind::MissingRequiredArgument, 
                            "Missing required arguments").exit();
                    }
                },
                Err(e) => {
                    let mut cmd = Cli::command();
                    cmd.error(ErrorKind::InvalidValue, 
                        format!("{}: {}", e, output)).exit();
                }
            }
        },
        None => {
            let mut cmd = Cli::command();
            cmd.error(
                ErrorKind::MissingSubcommand,
                "Missing required command",
            ).exit();
        }
    }
}
