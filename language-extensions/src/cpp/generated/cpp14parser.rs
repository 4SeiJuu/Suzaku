// Generated from ./language-extensions/src/cpp/generated/CPP14Parser.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
use antlr_rust::PredictionContextCache;
use antlr_rust::parser::{Parser, BaseParser, ParserRecog, ParserNodeType};
use antlr_rust::token_stream::TokenStream;
use antlr_rust::TokenSource;
use antlr_rust::parser_atn_simulator::ParserATNSimulator;
use antlr_rust::errors::*;
use antlr_rust::rule_context::{BaseRuleContext, CustomRuleContext, RuleContext};
use antlr_rust::recognizer::{Recognizer,Actions};
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::atn::{ATN, INVALID_ALT};
use antlr_rust::error_strategy::{ErrorStrategy, DefaultErrorStrategy};
use antlr_rust::parser_rule_context::{BaseParserRuleContext, ParserRuleContext,cast,cast_mut};
use antlr_rust::tree::*;
use antlr_rust::token::{TOKEN_EOF,OwningToken,Token};
use antlr_rust::int_stream::EOF;
use antlr_rust::vocabulary::{Vocabulary,VocabularyImpl};
use antlr_rust::token_factory::{CommonTokenFactory,TokenFactory, TokenAware};
use super::cpp14parserlistener::*;
use antlr_rust::lazy_static;
use antlr_rust::{TidAble,TidExt};

use std::marker::PhantomData;
use std::sync::Arc;
use std::rc::Rc;
use std::convert::TryFrom;
use std::cell::RefCell;
use std::ops::{DerefMut, Deref};
use std::borrow::{Borrow,BorrowMut};
use std::any::{Any,TypeId};

		pub const IntegerLiteral:isize=1; 
		pub const CharacterLiteral:isize=2; 
		pub const FloatingLiteral:isize=3; 
		pub const StringLiteral:isize=4; 
		pub const BooleanLiteral:isize=5; 
		pub const PointerLiteral:isize=6; 
		pub const UserDefinedLiteral:isize=7; 
		pub const MultiLineMacro:isize=8; 
		pub const Directive:isize=9; 
		pub const Alignas:isize=10; 
		pub const Alignof:isize=11; 
		pub const Asm:isize=12; 
		pub const Auto:isize=13; 
		pub const Bool:isize=14; 
		pub const Break:isize=15; 
		pub const Case:isize=16; 
		pub const Catch:isize=17; 
		pub const Char:isize=18; 
		pub const Char16:isize=19; 
		pub const Char32:isize=20; 
		pub const Class:isize=21; 
		pub const Const:isize=22; 
		pub const Constexpr:isize=23; 
		pub const Const_cast:isize=24; 
		pub const Continue:isize=25; 
		pub const Decltype:isize=26; 
		pub const Default:isize=27; 
		pub const Delete:isize=28; 
		pub const Do:isize=29; 
		pub const Double:isize=30; 
		pub const Dynamic_cast:isize=31; 
		pub const Else:isize=32; 
		pub const Enum:isize=33; 
		pub const Explicit:isize=34; 
		pub const Export:isize=35; 
		pub const Extern:isize=36; 
		pub const False_:isize=37; 
		pub const Final:isize=38; 
		pub const Float:isize=39; 
		pub const For:isize=40; 
		pub const Friend:isize=41; 
		pub const Goto:isize=42; 
		pub const If:isize=43; 
		pub const Inline:isize=44; 
		pub const Int:isize=45; 
		pub const Long:isize=46; 
		pub const Mutable:isize=47; 
		pub const Namespace:isize=48; 
		pub const New:isize=49; 
		pub const Noexcept:isize=50; 
		pub const Nullptr:isize=51; 
		pub const Operator:isize=52; 
		pub const Override:isize=53; 
		pub const Private:isize=54; 
		pub const Protected:isize=55; 
		pub const Public:isize=56; 
		pub const Register:isize=57; 
		pub const Reinterpret_cast:isize=58; 
		pub const Return:isize=59; 
		pub const Short:isize=60; 
		pub const Signed:isize=61; 
		pub const Sizeof:isize=62; 
		pub const Static:isize=63; 
		pub const Static_assert:isize=64; 
		pub const Static_cast:isize=65; 
		pub const Struct:isize=66; 
		pub const Switch:isize=67; 
		pub const Template:isize=68; 
		pub const This:isize=69; 
		pub const Thread_local:isize=70; 
		pub const Throw:isize=71; 
		pub const True_:isize=72; 
		pub const Try:isize=73; 
		pub const Typedef:isize=74; 
		pub const Typeid_:isize=75; 
		pub const Typename_:isize=76; 
		pub const Union:isize=77; 
		pub const Unsigned:isize=78; 
		pub const Using:isize=79; 
		pub const Virtual:isize=80; 
		pub const Void:isize=81; 
		pub const Volatile:isize=82; 
		pub const Wchar:isize=83; 
		pub const While:isize=84; 
		pub const LeftParen:isize=85; 
		pub const RightParen:isize=86; 
		pub const LeftBracket:isize=87; 
		pub const RightBracket:isize=88; 
		pub const LeftBrace:isize=89; 
		pub const RightBrace:isize=90; 
		pub const Plus:isize=91; 
		pub const Minus:isize=92; 
		pub const Star:isize=93; 
		pub const Div:isize=94; 
		pub const Mod:isize=95; 
		pub const Caret:isize=96; 
		pub const And:isize=97; 
		pub const Or:isize=98; 
		pub const Tilde:isize=99; 
		pub const Not:isize=100; 
		pub const Assign:isize=101; 
		pub const Less:isize=102; 
		pub const Greater:isize=103; 
		pub const PlusAssign:isize=104; 
		pub const MinusAssign:isize=105; 
		pub const StarAssign:isize=106; 
		pub const DivAssign:isize=107; 
		pub const ModAssign:isize=108; 
		pub const XorAssign:isize=109; 
		pub const AndAssign:isize=110; 
		pub const OrAssign:isize=111; 
		pub const LeftShiftAssign:isize=112; 
		pub const RightShiftAssign:isize=113; 
		pub const Equal:isize=114; 
		pub const NotEqual:isize=115; 
		pub const LessEqual:isize=116; 
		pub const GreaterEqual:isize=117; 
		pub const AndAnd:isize=118; 
		pub const OrOr:isize=119; 
		pub const PlusPlus:isize=120; 
		pub const MinusMinus:isize=121; 
		pub const Comma:isize=122; 
		pub const ArrowStar:isize=123; 
		pub const Arrow:isize=124; 
		pub const Question:isize=125; 
		pub const Colon:isize=126; 
		pub const Doublecolon:isize=127; 
		pub const Semi:isize=128; 
		pub const Dot:isize=129; 
		pub const DotStar:isize=130; 
		pub const Ellipsis:isize=131; 
		pub const Identifier:isize=132; 
		pub const DecimalLiteral:isize=133; 
		pub const OctalLiteral:isize=134; 
		pub const HexadecimalLiteral:isize=135; 
		pub const BinaryLiteral:isize=136; 
		pub const Integersuffix:isize=137; 
		pub const UserDefinedIntegerLiteral:isize=138; 
		pub const UserDefinedFloatingLiteral:isize=139; 
		pub const UserDefinedStringLiteral:isize=140; 
		pub const UserDefinedCharacterLiteral:isize=141; 
		pub const Whitespace:isize=142; 
		pub const Newline:isize=143; 
		pub const BlockComment:isize=144; 
		pub const LineComment:isize=145;
	pub const RULE_translationUnit:usize = 0; 
	pub const RULE_primaryExpression:usize = 1; 
	pub const RULE_idExpression:usize = 2; 
	pub const RULE_unqualifiedId:usize = 3; 
	pub const RULE_qualifiedId:usize = 4; 
	pub const RULE_nestedNameSpecifier:usize = 5; 
	pub const RULE_lambdaExpression:usize = 6; 
	pub const RULE_lambdaIntroducer:usize = 7; 
	pub const RULE_lambdaCapture:usize = 8; 
	pub const RULE_captureDefault:usize = 9; 
	pub const RULE_captureList:usize = 10; 
	pub const RULE_capture:usize = 11; 
	pub const RULE_simpleCapture:usize = 12; 
	pub const RULE_initcapture:usize = 13; 
	pub const RULE_lambdaDeclarator:usize = 14; 
	pub const RULE_postfixExpression:usize = 15; 
	pub const RULE_typeIdOfTheTypeId:usize = 16; 
	pub const RULE_expressionList:usize = 17; 
	pub const RULE_pseudoDestructorName:usize = 18; 
	pub const RULE_unaryExpression:usize = 19; 
	pub const RULE_unaryOperator:usize = 20; 
	pub const RULE_newExpression_:usize = 21; 
	pub const RULE_newPlacement:usize = 22; 
	pub const RULE_newTypeId:usize = 23; 
	pub const RULE_newDeclarator_:usize = 24; 
	pub const RULE_noPointerNewDeclarator:usize = 25; 
	pub const RULE_newInitializer_:usize = 26; 
	pub const RULE_deleteExpression:usize = 27; 
	pub const RULE_noExceptExpression:usize = 28; 
	pub const RULE_castExpression:usize = 29; 
	pub const RULE_pointerMemberExpression:usize = 30; 
	pub const RULE_multiplicativeExpression:usize = 31; 
	pub const RULE_additiveExpression:usize = 32; 
	pub const RULE_shiftExpression:usize = 33; 
	pub const RULE_shiftOperator:usize = 34; 
	pub const RULE_relationalExpression:usize = 35; 
	pub const RULE_equalityExpression:usize = 36; 
	pub const RULE_andExpression:usize = 37; 
	pub const RULE_exclusiveOrExpression:usize = 38; 
	pub const RULE_inclusiveOrExpression:usize = 39; 
	pub const RULE_logicalAndExpression:usize = 40; 
	pub const RULE_logicalOrExpression:usize = 41; 
	pub const RULE_conditionalExpression:usize = 42; 
	pub const RULE_assignmentExpression:usize = 43; 
	pub const RULE_assignmentOperator:usize = 44; 
	pub const RULE_expression:usize = 45; 
	pub const RULE_constantExpression:usize = 46; 
	pub const RULE_statement:usize = 47; 
	pub const RULE_labeledStatement:usize = 48; 
	pub const RULE_expressionStatement:usize = 49; 
	pub const RULE_compoundStatement:usize = 50; 
	pub const RULE_statementSeq:usize = 51; 
	pub const RULE_selectionStatement:usize = 52; 
	pub const RULE_condition:usize = 53; 
	pub const RULE_iterationStatement:usize = 54; 
	pub const RULE_forInitStatement:usize = 55; 
	pub const RULE_forRangeDeclaration:usize = 56; 
	pub const RULE_forRangeInitializer:usize = 57; 
	pub const RULE_jumpStatement:usize = 58; 
	pub const RULE_declarationStatement:usize = 59; 
	pub const RULE_declarationseq:usize = 60; 
	pub const RULE_declaration:usize = 61; 
	pub const RULE_blockDeclaration:usize = 62; 
	pub const RULE_aliasDeclaration:usize = 63; 
	pub const RULE_simpleDeclaration:usize = 64; 
	pub const RULE_staticAssertDeclaration:usize = 65; 
	pub const RULE_emptyDeclaration_:usize = 66; 
	pub const RULE_attributeDeclaration:usize = 67; 
	pub const RULE_declSpecifier:usize = 68; 
	pub const RULE_declSpecifierSeq:usize = 69; 
	pub const RULE_storageClassSpecifier:usize = 70; 
	pub const RULE_functionSpecifier:usize = 71; 
	pub const RULE_typedefName:usize = 72; 
	pub const RULE_typeSpecifier:usize = 73; 
	pub const RULE_trailingTypeSpecifier:usize = 74; 
	pub const RULE_typeSpecifierSeq:usize = 75; 
	pub const RULE_trailingTypeSpecifierSeq:usize = 76; 
	pub const RULE_simpleTypeLengthModifier:usize = 77; 
	pub const RULE_simpleTypeSignednessModifier:usize = 78; 
	pub const RULE_simpleTypeSpecifier:usize = 79; 
	pub const RULE_theTypeName:usize = 80; 
	pub const RULE_decltypeSpecifier:usize = 81; 
	pub const RULE_elaboratedTypeSpecifier:usize = 82; 
	pub const RULE_enumName:usize = 83; 
	pub const RULE_enumSpecifier:usize = 84; 
	pub const RULE_enumHead:usize = 85; 
	pub const RULE_opaqueEnumDeclaration:usize = 86; 
	pub const RULE_enumkey:usize = 87; 
	pub const RULE_enumbase:usize = 88; 
	pub const RULE_enumeratorList:usize = 89; 
	pub const RULE_enumeratorDefinition:usize = 90; 
	pub const RULE_enumerator:usize = 91; 
	pub const RULE_namespaceName:usize = 92; 
	pub const RULE_originalNamespaceName:usize = 93; 
	pub const RULE_namespaceDefinition:usize = 94; 
	pub const RULE_namespaceAlias:usize = 95; 
	pub const RULE_namespaceAliasDefinition:usize = 96; 
	pub const RULE_qualifiednamespacespecifier:usize = 97; 
	pub const RULE_usingDeclaration:usize = 98; 
	pub const RULE_usingDirective:usize = 99; 
	pub const RULE_asmDefinition:usize = 100; 
	pub const RULE_linkageSpecification:usize = 101; 
	pub const RULE_attributeSpecifierSeq:usize = 102; 
	pub const RULE_attributeSpecifier:usize = 103; 
	pub const RULE_alignmentspecifier:usize = 104; 
	pub const RULE_attributeList:usize = 105; 
	pub const RULE_attribute:usize = 106; 
	pub const RULE_attributeNamespace:usize = 107; 
	pub const RULE_attributeArgumentClause:usize = 108; 
	pub const RULE_balancedTokenSeq:usize = 109; 
	pub const RULE_balancedtoken:usize = 110; 
	pub const RULE_initDeclaratorList:usize = 111; 
	pub const RULE_initDeclarator:usize = 112; 
	pub const RULE_declarator:usize = 113; 
	pub const RULE_pointerDeclarator:usize = 114; 
	pub const RULE_noPointerDeclarator:usize = 115; 
	pub const RULE_parametersAndQualifiers:usize = 116; 
	pub const RULE_trailingReturnType:usize = 117; 
	pub const RULE_pointerOperator:usize = 118; 
	pub const RULE_cvqualifierseq:usize = 119; 
	pub const RULE_cvQualifier:usize = 120; 
	pub const RULE_refqualifier:usize = 121; 
	pub const RULE_declaratorid:usize = 122; 
	pub const RULE_theTypeId:usize = 123; 
	pub const RULE_abstractDeclarator:usize = 124; 
	pub const RULE_pointerAbstractDeclarator:usize = 125; 
	pub const RULE_noPointerAbstractDeclarator:usize = 126; 
	pub const RULE_abstractPackDeclarator:usize = 127; 
	pub const RULE_noPointerAbstractPackDeclarator:usize = 128; 
	pub const RULE_parameterDeclarationClause:usize = 129; 
	pub const RULE_parameterDeclarationList:usize = 130; 
	pub const RULE_parameterDeclaration:usize = 131; 
	pub const RULE_functionDefinition:usize = 132; 
	pub const RULE_functionBody:usize = 133; 
	pub const RULE_initializer:usize = 134; 
	pub const RULE_braceOrEqualInitializer:usize = 135; 
	pub const RULE_initializerClause:usize = 136; 
	pub const RULE_initializerList:usize = 137; 
	pub const RULE_bracedInitList:usize = 138; 
	pub const RULE_className:usize = 139; 
	pub const RULE_classSpecifier:usize = 140; 
	pub const RULE_classHead:usize = 141; 
	pub const RULE_classHeadName:usize = 142; 
	pub const RULE_classVirtSpecifier:usize = 143; 
	pub const RULE_classKey:usize = 144; 
	pub const RULE_memberSpecification:usize = 145; 
	pub const RULE_memberdeclaration:usize = 146; 
	pub const RULE_memberDeclaratorList:usize = 147; 
	pub const RULE_memberDeclarator:usize = 148; 
	pub const RULE_virtualSpecifierSeq:usize = 149; 
	pub const RULE_virtualSpecifier:usize = 150; 
	pub const RULE_pureSpecifier:usize = 151; 
	pub const RULE_baseClause:usize = 152; 
	pub const RULE_baseSpecifierList:usize = 153; 
	pub const RULE_baseSpecifier:usize = 154; 
	pub const RULE_classOrDeclType:usize = 155; 
	pub const RULE_baseTypeSpecifier:usize = 156; 
	pub const RULE_accessSpecifier:usize = 157; 
	pub const RULE_conversionFunctionId:usize = 158; 
	pub const RULE_conversionTypeId:usize = 159; 
	pub const RULE_conversionDeclarator:usize = 160; 
	pub const RULE_constructorInitializer:usize = 161; 
	pub const RULE_memInitializerList:usize = 162; 
	pub const RULE_memInitializer:usize = 163; 
	pub const RULE_meminitializerid:usize = 164; 
	pub const RULE_operatorFunctionId:usize = 165; 
	pub const RULE_literalOperatorId:usize = 166; 
	pub const RULE_templateDeclaration:usize = 167; 
	pub const RULE_templateparameterList:usize = 168; 
	pub const RULE_templateParameter:usize = 169; 
	pub const RULE_typeParameter:usize = 170; 
	pub const RULE_simpleTemplateId:usize = 171; 
	pub const RULE_templateId:usize = 172; 
	pub const RULE_templateName:usize = 173; 
	pub const RULE_templateArgumentList:usize = 174; 
	pub const RULE_templateArgument:usize = 175; 
	pub const RULE_typeNameSpecifier:usize = 176; 
	pub const RULE_explicitInstantiation:usize = 177; 
	pub const RULE_explicitSpecialization:usize = 178; 
	pub const RULE_tryBlock:usize = 179; 
	pub const RULE_functionTryBlock:usize = 180; 
	pub const RULE_handlerSeq:usize = 181; 
	pub const RULE_handler:usize = 182; 
	pub const RULE_exceptionDeclaration:usize = 183; 
	pub const RULE_throwExpression:usize = 184; 
	pub const RULE_exceptionSpecification:usize = 185; 
	pub const RULE_dynamicExceptionSpecification:usize = 186; 
	pub const RULE_typeIdList:usize = 187; 
	pub const RULE_noeExceptSpecification:usize = 188; 
	pub const RULE_theOperator:usize = 189; 
	pub const RULE_literal:usize = 190;
	pub const ruleNames: [&'static str; 191] =  [
		"translationUnit", "primaryExpression", "idExpression", "unqualifiedId", 
		"qualifiedId", "nestedNameSpecifier", "lambdaExpression", "lambdaIntroducer", 
		"lambdaCapture", "captureDefault", "captureList", "capture", "simpleCapture", 
		"initcapture", "lambdaDeclarator", "postfixExpression", "typeIdOfTheTypeId", 
		"expressionList", "pseudoDestructorName", "unaryExpression", "unaryOperator", 
		"newExpression_", "newPlacement", "newTypeId", "newDeclarator_", "noPointerNewDeclarator", 
		"newInitializer_", "deleteExpression", "noExceptExpression", "castExpression", 
		"pointerMemberExpression", "multiplicativeExpression", "additiveExpression", 
		"shiftExpression", "shiftOperator", "relationalExpression", "equalityExpression", 
		"andExpression", "exclusiveOrExpression", "inclusiveOrExpression", "logicalAndExpression", 
		"logicalOrExpression", "conditionalExpression", "assignmentExpression", 
		"assignmentOperator", "expression", "constantExpression", "statement", 
		"labeledStatement", "expressionStatement", "compoundStatement", "statementSeq", 
		"selectionStatement", "condition", "iterationStatement", "forInitStatement", 
		"forRangeDeclaration", "forRangeInitializer", "jumpStatement", "declarationStatement", 
		"declarationseq", "declaration", "blockDeclaration", "aliasDeclaration", 
		"simpleDeclaration", "staticAssertDeclaration", "emptyDeclaration_", "attributeDeclaration", 
		"declSpecifier", "declSpecifierSeq", "storageClassSpecifier", "functionSpecifier", 
		"typedefName", "typeSpecifier", "trailingTypeSpecifier", "typeSpecifierSeq", 
		"trailingTypeSpecifierSeq", "simpleTypeLengthModifier", "simpleTypeSignednessModifier", 
		"simpleTypeSpecifier", "theTypeName", "decltypeSpecifier", "elaboratedTypeSpecifier", 
		"enumName", "enumSpecifier", "enumHead", "opaqueEnumDeclaration", "enumkey", 
		"enumbase", "enumeratorList", "enumeratorDefinition", "enumerator", "namespaceName", 
		"originalNamespaceName", "namespaceDefinition", "namespaceAlias", "namespaceAliasDefinition", 
		"qualifiednamespacespecifier", "usingDeclaration", "usingDirective", "asmDefinition", 
		"linkageSpecification", "attributeSpecifierSeq", "attributeSpecifier", 
		"alignmentspecifier", "attributeList", "attribute", "attributeNamespace", 
		"attributeArgumentClause", "balancedTokenSeq", "balancedtoken", "initDeclaratorList", 
		"initDeclarator", "declarator", "pointerDeclarator", "noPointerDeclarator", 
		"parametersAndQualifiers", "trailingReturnType", "pointerOperator", "cvqualifierseq", 
		"cvQualifier", "refqualifier", "declaratorid", "theTypeId", "abstractDeclarator", 
		"pointerAbstractDeclarator", "noPointerAbstractDeclarator", "abstractPackDeclarator", 
		"noPointerAbstractPackDeclarator", "parameterDeclarationClause", "parameterDeclarationList", 
		"parameterDeclaration", "functionDefinition", "functionBody", "initializer", 
		"braceOrEqualInitializer", "initializerClause", "initializerList", "bracedInitList", 
		"className", "classSpecifier", "classHead", "classHeadName", "classVirtSpecifier", 
		"classKey", "memberSpecification", "memberdeclaration", "memberDeclaratorList", 
		"memberDeclarator", "virtualSpecifierSeq", "virtualSpecifier", "pureSpecifier", 
		"baseClause", "baseSpecifierList", "baseSpecifier", "classOrDeclType", 
		"baseTypeSpecifier", "accessSpecifier", "conversionFunctionId", "conversionTypeId", 
		"conversionDeclarator", "constructorInitializer", "memInitializerList", 
		"memInitializer", "meminitializerid", "operatorFunctionId", "literalOperatorId", 
		"templateDeclaration", "templateparameterList", "templateParameter", "typeParameter", 
		"simpleTemplateId", "templateId", "templateName", "templateArgumentList", 
		"templateArgument", "typeNameSpecifier", "explicitInstantiation", "explicitSpecialization", 
		"tryBlock", "functionTryBlock", "handlerSeq", "handler", "exceptionDeclaration", 
		"throwExpression", "exceptionSpecification", "dynamicExceptionSpecification", 
		"typeIdList", "noeExceptSpecification", "theOperator", "literal"
	];


	pub const _LITERAL_NAMES: [Option<&'static str>;132] = [
		None, None, None, None, None, None, None, None, None, None, Some("'alignas'"), 
		Some("'alignof'"), Some("'asm'"), Some("'auto'"), Some("'bool'"), Some("'break'"), 
		Some("'case'"), Some("'catch'"), Some("'char'"), Some("'char16_t'"), Some("'char32_t'"), 
		Some("'class'"), Some("'const'"), Some("'constexpr'"), Some("'const_cast'"), 
		Some("'continue'"), Some("'decltype'"), Some("'default'"), Some("'delete'"), 
		Some("'do'"), Some("'double'"), Some("'dynamic_cast'"), Some("'else'"), 
		Some("'enum'"), Some("'explicit'"), Some("'export'"), Some("'extern'"), 
		Some("'false'"), Some("'final'"), Some("'float'"), Some("'for'"), Some("'friend'"), 
		Some("'goto'"), Some("'if'"), Some("'inline'"), Some("'int'"), Some("'long'"), 
		Some("'mutable'"), Some("'namespace'"), Some("'new'"), Some("'noexcept'"), 
		Some("'nullptr'"), Some("'operator'"), Some("'override'"), Some("'private'"), 
		Some("'protected'"), Some("'public'"), Some("'register'"), Some("'reinterpret_cast'"), 
		Some("'return'"), Some("'short'"), Some("'signed'"), Some("'sizeof'"), 
		Some("'static'"), Some("'static_assert'"), Some("'static_cast'"), Some("'struct'"), 
		Some("'switch'"), Some("'template'"), Some("'this'"), Some("'thread_local'"), 
		Some("'throw'"), Some("'true'"), Some("'try'"), Some("'typedef'"), Some("'typeid'"), 
		Some("'typename'"), Some("'union'"), Some("'unsigned'"), Some("'using'"), 
		Some("'virtual'"), Some("'void'"), Some("'volatile'"), Some("'wchar_t'"), 
		Some("'while'"), Some("'('"), Some("')'"), Some("'['"), Some("']'"), Some("'{'"), 
		Some("'}'"), Some("'+'"), Some("'-'"), Some("'*'"), Some("'/'"), Some("'%'"), 
		Some("'^'"), Some("'&'"), Some("'|'"), Some("'~'"), None, Some("'='"), 
		Some("'<'"), Some("'>'"), Some("'+='"), Some("'-='"), Some("'*='"), Some("'/='"), 
		Some("'%='"), Some("'^='"), Some("'&='"), Some("'|='"), Some("'<<='"), 
		Some("'>>='"), Some("'=='"), Some("'!='"), Some("'<='"), Some("'>='"), 
		None, None, Some("'++'"), Some("'--'"), Some("','"), Some("'->*'"), Some("'->'"), 
		Some("'?'"), Some("':'"), Some("'::'"), Some("';'"), Some("'.'"), Some("'.*'"), 
		Some("'...'")
	];
	pub const _SYMBOLIC_NAMES: [Option<&'static str>;146]  = [
		None, Some("IntegerLiteral"), Some("CharacterLiteral"), Some("FloatingLiteral"), 
		Some("StringLiteral"), Some("BooleanLiteral"), Some("PointerLiteral"), 
		Some("UserDefinedLiteral"), Some("MultiLineMacro"), Some("Directive"), 
		Some("Alignas"), Some("Alignof"), Some("Asm"), Some("Auto"), Some("Bool"), 
		Some("Break"), Some("Case"), Some("Catch"), Some("Char"), Some("Char16"), 
		Some("Char32"), Some("Class"), Some("Const"), Some("Constexpr"), Some("Const_cast"), 
		Some("Continue"), Some("Decltype"), Some("Default"), Some("Delete"), Some("Do"), 
		Some("Double"), Some("Dynamic_cast"), Some("Else"), Some("Enum"), Some("Explicit"), 
		Some("Export"), Some("Extern"), Some("False_"), Some("Final"), Some("Float"), 
		Some("For"), Some("Friend"), Some("Goto"), Some("If"), Some("Inline"), 
		Some("Int"), Some("Long"), Some("Mutable"), Some("Namespace"), Some("New"), 
		Some("Noexcept"), Some("Nullptr"), Some("Operator"), Some("Override"), 
		Some("Private"), Some("Protected"), Some("Public"), Some("Register"), 
		Some("Reinterpret_cast"), Some("Return"), Some("Short"), Some("Signed"), 
		Some("Sizeof"), Some("Static"), Some("Static_assert"), Some("Static_cast"), 
		Some("Struct"), Some("Switch"), Some("Template"), Some("This"), Some("Thread_local"), 
		Some("Throw"), Some("True_"), Some("Try"), Some("Typedef"), Some("Typeid_"), 
		Some("Typename_"), Some("Union"), Some("Unsigned"), Some("Using"), Some("Virtual"), 
		Some("Void"), Some("Volatile"), Some("Wchar"), Some("While"), Some("LeftParen"), 
		Some("RightParen"), Some("LeftBracket"), Some("RightBracket"), Some("LeftBrace"), 
		Some("RightBrace"), Some("Plus"), Some("Minus"), Some("Star"), Some("Div"), 
		Some("Mod"), Some("Caret"), Some("And"), Some("Or"), Some("Tilde"), Some("Not"), 
		Some("Assign"), Some("Less"), Some("Greater"), Some("PlusAssign"), Some("MinusAssign"), 
		Some("StarAssign"), Some("DivAssign"), Some("ModAssign"), Some("XorAssign"), 
		Some("AndAssign"), Some("OrAssign"), Some("LeftShiftAssign"), Some("RightShiftAssign"), 
		Some("Equal"), Some("NotEqual"), Some("LessEqual"), Some("GreaterEqual"), 
		Some("AndAnd"), Some("OrOr"), Some("PlusPlus"), Some("MinusMinus"), Some("Comma"), 
		Some("ArrowStar"), Some("Arrow"), Some("Question"), Some("Colon"), Some("Doublecolon"), 
		Some("Semi"), Some("Dot"), Some("DotStar"), Some("Ellipsis"), Some("Identifier"), 
		Some("DecimalLiteral"), Some("OctalLiteral"), Some("HexadecimalLiteral"), 
		Some("BinaryLiteral"), Some("Integersuffix"), Some("UserDefinedIntegerLiteral"), 
		Some("UserDefinedFloatingLiteral"), Some("UserDefinedStringLiteral"), 
		Some("UserDefinedCharacterLiteral"), Some("Whitespace"), Some("Newline"), 
		Some("BlockComment"), Some("LineComment")
	];
	lazy_static!{
	    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
		static ref VOCABULARY: Box<dyn Vocabulary> = Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
	}

// trait PureSpecifier<'input> {
// 	fn is_pure_sepcifier_allowed(&self) -> bool;
// }



type BaseParserType<'input, I> =
	BaseParser<'input,CPP14ParserExt<'input>, I, CPP14ParserContextType , dyn CPP14ParserListener<'input> + 'input >;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type CPP14ParserTreeWalker<'input,'a> =
	ParseTreeWalker<'input, 'a, CPP14ParserContextType , dyn CPP14ParserListener<'input> + 'a>;

/// Parser for CPP14Parser grammar
pub struct CPP14Parser<'input,I,H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	base:BaseParserType<'input,I>,
	interpreter:Arc<ParserATNSimulator>,
	_shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

// // logic as following
// // see: https://github.com/antlr/grammars-v4/blob/master/cpp/Cpp/CPP14ParserBase.cpp
// // -----------------------------------------------------------------------------------
// // bool CPP14ParserBase::IsPureSpecifierAllowed()
// // {
// // 		try
// // 		{
// // 			auto x = this->getRuleContext(); // memberDeclarator
// // 			auto c = x->children[0]->children[0];
// // 			auto c2 = c->children[0];
// // 			auto p = c2->children[1];
// // 			if (p == nullptr) return false;
// // 			return typeid(*p) == typeid(CPP14Parser::ParametersAndQualifiersContext);
// // 		}
// // 		catch (...)
// // 		{
// // 		}
// // 		return false;
// // }
// // -----------------------------------------------------------------------------------
// impl<'input> PureSpecifier<'input> for BaseParserRuleContext<'input, MemberDeclaratorContextExt<'input>> {
// 	fn is_pure_sepcifier_allowed(&self) -> bool {
// 		return match self.get_child(0) {
// 			Some(child) => match child.get_child(0) {
// 				Some(child) => match child.get_child(0) {
// 					Some(child) => match child.get_child(1) {
// 						Some(child) => child.type_id() == TypeId::of::<ParametersAndQualifiersContext>(),
// 						None => false
// 					},
// 					None => false
// 				},
// 				None => false
// 			},
// 			None => false
// 		}
// 	}
// }

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn get_serialized_atn() -> &'static str { _serializedATN }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
		antlr_rust::recognizer::check_version("0","3");
		let interpreter = Arc::new(ParserATNSimulator::new(
			_ATN.clone(),
			_decision_to_DFA.clone(),
			_shared_context_cache.clone(),
		));
		Self {
			base: BaseParser::new_base_parser(
				input,
				Arc::clone(&interpreter),
				CPP14ParserExt{
					_pd: Default::default(),
				}
			),
			interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }

}

type DynStrategy<'input,I> = Box<dyn ErrorStrategy<'input,BaseParserType<'input,I>> + 'input>;

impl<'input, I> CPP14Parser<'input, I, DynStrategy<'input,I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self{
    	Self::with_strategy(input,Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> CPP14Parser<'input, I, DefaultErrorStrategy<'input,CPP14ParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn new(input: I) -> Self{
    	Self::with_strategy(input,DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for CPP14Parser
pub trait CPP14ParserContext<'input>:
	for<'x> Listenable<dyn CPP14ParserListener<'input> + 'x > + 
	ParserRuleContext<'input, TF=LocalTokenFactory<'input>, Ctx=CPP14ParserContextType>
{}

antlr_rust::coerce_from!{ 'input : CPP14ParserContext<'input> }

impl<'input> CPP14ParserContext<'input> for TerminalNode<'input,CPP14ParserContextType> {}
impl<'input> CPP14ParserContext<'input> for ErrorNode<'input,CPP14ParserContextType> {}

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn CPP14ParserContext<'input> + 'input }

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn CPP14ParserListener<'input> + 'input }

pub struct CPP14ParserContextType;
antlr_rust::tid!{CPP14ParserContextType}

impl<'input> ParserNodeType<'input> for CPP14ParserContextType{
	type TF = LocalTokenFactory<'input>;
	type Type = dyn CPP14ParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    type Target = BaseParserType<'input,I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct CPP14ParserExt<'input>{
	_pd: PhantomData<&'input str>,
}

impl<'input> CPP14ParserExt<'input>{
}
antlr_rust::tid! { CPP14ParserExt<'a> }

impl<'input> TokenAware<'input> for CPP14ParserExt<'input>{
	type TF = LocalTokenFactory<'input>;
}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> ParserRecog<'input, BaseParserType<'input,I>> for CPP14ParserExt<'input>{}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> Actions<'input, BaseParserType<'input,I>> for CPP14ParserExt<'input>{
	fn get_grammar_file_name(&self) -> & str{ "CPP14Parser.g4"}

   	fn get_rule_names(&self) -> &[& str] {&ruleNames}

   	fn get_vocabulary(&self) -> &dyn Vocabulary { &**VOCABULARY }
	fn sempred(_localctx: Option<&(dyn CPP14ParserContext<'input> + 'input)>, rule_index: isize, pred_index: isize,
			   recog:&mut BaseParserType<'input,I>
	)->bool{
		match rule_index {
					5 => CPP14Parser::<'input,I,_>::nestedNameSpecifier_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					15 => CPP14Parser::<'input,I,_>::postfixExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					25 => CPP14Parser::<'input,I,_>::noPointerNewDeclarator_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					115 => CPP14Parser::<'input,I,_>::noPointerDeclarator_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					126 => CPP14Parser::<'input,I,_>::noPointerAbstractDeclarator_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					128 => CPP14Parser::<'input,I,_>::noPointerAbstractPackDeclarator_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					148 => CPP14Parser::<'input,I,_>::memberDeclarator_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
			_ => true
		}
	}
}

impl<'input, I> CPP14Parser<'input, I, DefaultErrorStrategy<'input,CPP14ParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
	fn nestedNameSpecifier_sempred(_localctx: Option<&NestedNameSpecifierContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				0=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn postfixExpression_sempred(_localctx: Option<&PostfixExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				1=>{
					recog.precpred(None, 7)
				}
				2=>{
					recog.precpred(None, 6)
				}
				3=>{
					recog.precpred(None, 4)
				}
				4=>{
					recog.precpred(None, 3)
				}
			_ => true
		}
	}
	fn noPointerNewDeclarator_sempred(_localctx: Option<&NoPointerNewDeclaratorContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				5=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn noPointerDeclarator_sempred(_localctx: Option<&NoPointerDeclaratorContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				6=>{
					recog.precpred(None, 2)
				}
			_ => true
		}
	}
	fn noPointerAbstractDeclarator_sempred(_localctx: Option<&NoPointerAbstractDeclaratorContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				7=>{
					recog.precpred(None, 4)
				}
			_ => true
		}
	}
	fn noPointerAbstractPackDeclarator_sempred(_localctx: Option<&NoPointerAbstractPackDeclaratorContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				8=>{
					recog.precpred(None, 2)
				}
			_ => true
		}
	}
	fn memberDeclarator_sempred(_localctx: Option<&MemberDeclaratorContext<'input>>, pred_index:isize, recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				9=>{
					// TODO: confirm here: is_pure_sepcifier_allowed
					// match _localctx {
					// 	Some(ctx) => ctx.is_pure_sepcifier_allowed(),
					// 	None => false
					// }
					true
				}
				10=>{
					// TODO: confirm here: is_pure_sepcifier_allowed
					// match _localctx {
					// 	Some(ctx) => ctx.is_pure_sepcifier_allowed(),
					// 	None => false
					// }
					true
				}
			_ => true
		}
	}
}
//------------------- translationUnit ----------------
pub type TranslationUnitContextAll<'input> = TranslationUnitContext<'input>;


pub type TranslationUnitContext<'input> = BaseParserRuleContext<'input,TranslationUnitContextExt<'input>>;

#[derive(Clone)]
pub struct TranslationUnitContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TranslationUnitContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TranslationUnitContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_translationUnit(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_translationUnit(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TranslationUnitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_translationUnit }
	//fn type_rule_index() -> usize where Self: Sized { RULE_translationUnit }
}
antlr_rust::tid!{TranslationUnitContextExt<'a>}

impl<'input> TranslationUnitContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TranslationUnitContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TranslationUnitContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TranslationUnitContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TranslationUnitContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}
fn declarationseq(&self) -> Option<Rc<DeclarationseqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TranslationUnitContextAttrs<'input> for TranslationUnitContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn translationUnit(&mut self,)
	-> Result<Rc<TranslationUnitContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TranslationUnitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_translationUnit);
        let mut _localctx: Rc<TranslationUnitContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(383);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 10)) & !0x3f) == 0 && ((1usize << (_la - 10)) & ((1usize << (Alignas - 10)) | (1usize << (Asm - 10)) | (1usize << (Auto - 10)) | (1usize << (Bool - 10)) | (1usize << (Char - 10)) | (1usize << (Char16 - 10)) | (1usize << (Char32 - 10)) | (1usize << (Class - 10)) | (1usize << (Const - 10)) | (1usize << (Constexpr - 10)) | (1usize << (Decltype - 10)) | (1usize << (Double - 10)) | (1usize << (Enum - 10)) | (1usize << (Explicit - 10)) | (1usize << (Extern - 10)) | (1usize << (Float - 10)) | (1usize << (Friend - 10)))) != 0) || ((((_la - 44)) & !0x3f) == 0 && ((1usize << (_la - 44)) & ((1usize << (Inline - 44)) | (1usize << (Int - 44)) | (1usize << (Long - 44)) | (1usize << (Mutable - 44)) | (1usize << (Namespace - 44)) | (1usize << (Operator - 44)) | (1usize << (Register - 44)) | (1usize << (Short - 44)) | (1usize << (Signed - 44)) | (1usize << (Static - 44)) | (1usize << (Static_assert - 44)) | (1usize << (Struct - 44)) | (1usize << (Template - 44)) | (1usize << (Thread_local - 44)) | (1usize << (Typedef - 44)))) != 0) || ((((_la - 76)) & !0x3f) == 0 && ((1usize << (_la - 76)) & ((1usize << (Typename_ - 76)) | (1usize << (Union - 76)) | (1usize << (Unsigned - 76)) | (1usize << (Using - 76)) | (1usize << (Virtual - 76)) | (1usize << (Void - 76)) | (1usize << (Volatile - 76)) | (1usize << (Wchar - 76)) | (1usize << (LeftParen - 76)) | (1usize << (LeftBracket - 76)) | (1usize << (Star - 76)) | (1usize << (And - 76)) | (1usize << (Tilde - 76)))) != 0) || ((((_la - 118)) & !0x3f) == 0 && ((1usize << (_la - 118)) & ((1usize << (AndAnd - 118)) | (1usize << (Doublecolon - 118)) | (1usize << (Semi - 118)) | (1usize << (Ellipsis - 118)) | (1usize << (Identifier - 118)))) != 0) {
				{
				/*InvokeRule declarationseq*/
				recog.base.set_state(382);
				recog.declarationseq()?;

				}
			}

			recog.base.set_state(385);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryExpression ----------------
pub type PrimaryExpressionContextAll<'input> = PrimaryExpressionContext<'input>;


pub type PrimaryExpressionContext<'input> = BaseParserRuleContext<'input,PrimaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for PrimaryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for PrimaryExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_primaryExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimaryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}
antlr_rust::tid!{PrimaryExpressionContextExt<'a>}

impl<'input> PrimaryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<PrimaryExpressionContextExt<'input>>{

fn literal_all(&self) ->  Vec<Rc<LiteralContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn literal(&self, i: usize) -> Option<Rc<LiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token This
/// Returns `None` if there is no child corresponding to token This
fn This(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(This, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn idExpression(&self) -> Option<Rc<IdExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn lambdaExpression(&self) -> Option<Rc<LambdaExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryExpressionContextAttrs<'input> for PrimaryExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryExpression(&mut self,)
	-> Result<Rc<PrimaryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_primaryExpression);
        let mut _localctx: Rc<PrimaryExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(399);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 IntegerLiteral | CharacterLiteral | FloatingLiteral | StringLiteral |
			 BooleanLiteral | PointerLiteral | UserDefinedLiteral 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(388); 
					recog.err_handler.sync(&mut recog.base)?;
					_alt = 1;
					loop {
						match _alt {
						    x if x == 1=>
							{
							{
							/*InvokeRule literal*/
							recog.base.set_state(387);
							recog.literal()?;

							}
							}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(390); 
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(1,&mut recog.base)?;
						if _alt==2 || _alt==INVALID_ALT { break }
					}
					}
				}

			 This 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(392);
					recog.base.match_token(This,&mut recog.err_handler)?;

					}
				}

			 LeftParen 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(393);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(394);
					recog.expression()?;

					recog.base.set_state(395);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}

			 Decltype | Operator | Tilde | Doublecolon | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule idExpression*/
					recog.base.set_state(397);
					recog.idExpression()?;

					}
				}

			 LeftBracket 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule lambdaExpression*/
					recog.base.set_state(398);
					recog.lambdaExpression()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- idExpression ----------------
pub type IdExpressionContextAll<'input> = IdExpressionContext<'input>;


pub type IdExpressionContext<'input> = BaseParserRuleContext<'input,IdExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct IdExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for IdExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for IdExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_idExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_idExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IdExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_idExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_idExpression }
}
antlr_rust::tid!{IdExpressionContextExt<'a>}

impl<'input> IdExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IdExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IdExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IdExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<IdExpressionContextExt<'input>>{

fn unqualifiedId(&self) -> Option<Rc<UnqualifiedIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn qualifiedId(&self) -> Option<Rc<QualifiedIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IdExpressionContextAttrs<'input> for IdExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn idExpression(&mut self,)
	-> Result<Rc<IdExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IdExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_idExpression);
        let mut _localctx: Rc<IdExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(403);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(3,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unqualifiedId*/
					recog.base.set_state(401);
					recog.unqualifiedId()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule qualifiedId*/
					recog.base.set_state(402);
					recog.qualifiedId()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unqualifiedId ----------------
pub type UnqualifiedIdContextAll<'input> = UnqualifiedIdContext<'input>;


pub type UnqualifiedIdContext<'input> = BaseParserRuleContext<'input,UnqualifiedIdContextExt<'input>>;

#[derive(Clone)]
pub struct UnqualifiedIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for UnqualifiedIdContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for UnqualifiedIdContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unqualifiedId(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_unqualifiedId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnqualifiedIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unqualifiedId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unqualifiedId }
}
antlr_rust::tid!{UnqualifiedIdContextExt<'a>}

impl<'input> UnqualifiedIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnqualifiedIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnqualifiedIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnqualifiedIdContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<UnqualifiedIdContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn operatorFunctionId(&self) -> Option<Rc<OperatorFunctionIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn conversionFunctionId(&self) -> Option<Rc<ConversionFunctionIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn literalOperatorId(&self) -> Option<Rc<LiteralOperatorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Tilde
/// Returns `None` if there is no child corresponding to token Tilde
fn Tilde(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Tilde, 0)
}
fn className(&self) -> Option<Rc<ClassNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn decltypeSpecifier(&self) -> Option<Rc<DecltypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn templateId(&self) -> Option<Rc<TemplateIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnqualifiedIdContextAttrs<'input> for UnqualifiedIdContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unqualifiedId(&mut self,)
	-> Result<Rc<UnqualifiedIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnqualifiedIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_unqualifiedId);
        let mut _localctx: Rc<UnqualifiedIdContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(415);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(5,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(405);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule operatorFunctionId*/
					recog.base.set_state(406);
					recog.operatorFunctionId()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule conversionFunctionId*/
					recog.base.set_state(407);
					recog.conversionFunctionId()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule literalOperatorId*/
					recog.base.set_state(408);
					recog.literalOperatorId()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(409);
					recog.base.match_token(Tilde,&mut recog.err_handler)?;

					recog.base.set_state(412);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 Identifier 
						=> {
							{
							/*InvokeRule className*/
							recog.base.set_state(410);
							recog.className()?;

							}
						}

					 Decltype 
						=> {
							{
							/*InvokeRule decltypeSpecifier*/
							recog.base.set_state(411);
							recog.decltypeSpecifier()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule templateId*/
					recog.base.set_state(414);
					recog.templateId()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- qualifiedId ----------------
pub type QualifiedIdContextAll<'input> = QualifiedIdContext<'input>;


pub type QualifiedIdContext<'input> = BaseParserRuleContext<'input,QualifiedIdContextExt<'input>>;

#[derive(Clone)]
pub struct QualifiedIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for QualifiedIdContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for QualifiedIdContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_qualifiedId(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_qualifiedId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for QualifiedIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_qualifiedId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_qualifiedId }
}
antlr_rust::tid!{QualifiedIdContextExt<'a>}

impl<'input> QualifiedIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QualifiedIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QualifiedIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait QualifiedIdContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<QualifiedIdContextExt<'input>>{

fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unqualifiedId(&self) -> Option<Rc<UnqualifiedIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Template
/// Returns `None` if there is no child corresponding to token Template
fn Template(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Template, 0)
}

}

impl<'input> QualifiedIdContextAttrs<'input> for QualifiedIdContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn qualifiedId(&mut self,)
	-> Result<Rc<QualifiedIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QualifiedIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_qualifiedId);
        let mut _localctx: Rc<QualifiedIdContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule nestedNameSpecifier*/
			recog.base.set_state(417);
			recog.nestedNameSpecifier_rec(0)?;

			recog.base.set_state(419);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Template {
				{
				recog.base.set_state(418);
				recog.base.match_token(Template,&mut recog.err_handler)?;

				}
			}

			/*InvokeRule unqualifiedId*/
			recog.base.set_state(421);
			recog.unqualifiedId()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nestedNameSpecifier ----------------
pub type NestedNameSpecifierContextAll<'input> = NestedNameSpecifierContext<'input>;


pub type NestedNameSpecifierContext<'input> = BaseParserRuleContext<'input,NestedNameSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct NestedNameSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NestedNameSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NestedNameSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_nestedNameSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_nestedNameSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NestedNameSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nestedNameSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nestedNameSpecifier }
}
antlr_rust::tid!{NestedNameSpecifierContextExt<'a>}

impl<'input> NestedNameSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NestedNameSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NestedNameSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NestedNameSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NestedNameSpecifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Doublecolon
/// Returns `None` if there is no child corresponding to token Doublecolon
fn Doublecolon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Doublecolon, 0)
}
fn theTypeName(&self) -> Option<Rc<TheTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn namespaceName(&self) -> Option<Rc<NamespaceNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn decltypeSpecifier(&self) -> Option<Rc<DecltypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn simpleTemplateId(&self) -> Option<Rc<SimpleTemplateIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Template
/// Returns `None` if there is no child corresponding to token Template
fn Template(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Template, 0)
}

}

impl<'input> NestedNameSpecifierContextAttrs<'input> for NestedNameSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  nestedNameSpecifier(&mut self,)
	-> Result<Rc<NestedNameSpecifierContextAll<'input>>,ANTLRError> {
		self.nestedNameSpecifier_rec(0)
	}

	fn nestedNameSpecifier_rec(&mut self, _p: isize)
	-> Result<Rc<NestedNameSpecifierContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = NestedNameSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 10, RULE_nestedNameSpecifier, _p);
	    let mut _localctx: Rc<NestedNameSpecifierContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 10;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			recog.base.set_state(427);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(7,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule theTypeName*/
					recog.base.set_state(424);
					recog.theTypeName()?;

					}
				}

				x if x == 2=>{
					{
					/*InvokeRule namespaceName*/
					recog.base.set_state(425);
					recog.namespaceName()?;

					}
				}

				x if x == 3=>{
					{
					/*InvokeRule decltypeSpecifier*/
					recog.base.set_state(426);
					recog.decltypeSpecifier()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(429);
			recog.base.match_token(Doublecolon,&mut recog.err_handler)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(442);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(10,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = NestedNameSpecifierContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_nestedNameSpecifier);
					_localctx = tmp;
					recog.base.set_state(431);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(437);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(9,&mut recog.base)? {
						1 =>{
							{
							recog.base.set_state(432);
							recog.base.match_token(Identifier,&mut recog.err_handler)?;

							}
						}
					,
						2 =>{
							{
							recog.base.set_state(434);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==Template {
								{
								recog.base.set_state(433);
								recog.base.match_token(Template,&mut recog.err_handler)?;

								}
							}

							/*InvokeRule simpleTemplateId*/
							recog.base.set_state(436);
							recog.simpleTemplateId()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(439);
					recog.base.match_token(Doublecolon,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(444);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(10,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- lambdaExpression ----------------
pub type LambdaExpressionContextAll<'input> = LambdaExpressionContext<'input>;


pub type LambdaExpressionContext<'input> = BaseParserRuleContext<'input,LambdaExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for LambdaExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for LambdaExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_lambdaExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LambdaExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaExpression }
}
antlr_rust::tid!{LambdaExpressionContextExt<'a>}

impl<'input> LambdaExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<LambdaExpressionContextExt<'input>>{

fn lambdaIntroducer(&self) -> Option<Rc<LambdaIntroducerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn compoundStatement(&self) -> Option<Rc<CompoundStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn lambdaDeclarator(&self) -> Option<Rc<LambdaDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LambdaExpressionContextAttrs<'input> for LambdaExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaExpression(&mut self,)
	-> Result<Rc<LambdaExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_lambdaExpression);
        let mut _localctx: Rc<LambdaExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule lambdaIntroducer*/
			recog.base.set_state(445);
			recog.lambdaIntroducer()?;

			recog.base.set_state(447);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LeftParen {
				{
				/*InvokeRule lambdaDeclarator*/
				recog.base.set_state(446);
				recog.lambdaDeclarator()?;

				}
			}

			/*InvokeRule compoundStatement*/
			recog.base.set_state(449);
			recog.compoundStatement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaIntroducer ----------------
pub type LambdaIntroducerContextAll<'input> = LambdaIntroducerContext<'input>;


pub type LambdaIntroducerContext<'input> = BaseParserRuleContext<'input,LambdaIntroducerContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaIntroducerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for LambdaIntroducerContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for LambdaIntroducerContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaIntroducer(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_lambdaIntroducer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LambdaIntroducerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaIntroducer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaIntroducer }
}
antlr_rust::tid!{LambdaIntroducerContextExt<'a>}

impl<'input> LambdaIntroducerContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaIntroducerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaIntroducerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaIntroducerContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<LambdaIntroducerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LeftBracket
/// Returns `None` if there is no child corresponding to token LeftBracket
fn LeftBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBracket, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBracket
/// Returns `None` if there is no child corresponding to token RightBracket
fn RightBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBracket, 0)
}
fn lambdaCapture(&self) -> Option<Rc<LambdaCaptureContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LambdaIntroducerContextAttrs<'input> for LambdaIntroducerContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaIntroducer(&mut self,)
	-> Result<Rc<LambdaIntroducerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaIntroducerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_lambdaIntroducer);
        let mut _localctx: Rc<LambdaIntroducerContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(451);
			recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

			recog.base.set_state(453);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==This || _la==And || _la==Assign || _la==Identifier {
				{
				/*InvokeRule lambdaCapture*/
				recog.base.set_state(452);
				recog.lambdaCapture()?;

				}
			}

			recog.base.set_state(455);
			recog.base.match_token(RightBracket,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaCapture ----------------
pub type LambdaCaptureContextAll<'input> = LambdaCaptureContext<'input>;


pub type LambdaCaptureContext<'input> = BaseParserRuleContext<'input,LambdaCaptureContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaCaptureContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for LambdaCaptureContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for LambdaCaptureContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaCapture(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_lambdaCapture(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LambdaCaptureContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaCapture }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaCapture }
}
antlr_rust::tid!{LambdaCaptureContextExt<'a>}

impl<'input> LambdaCaptureContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaCaptureContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaCaptureContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaCaptureContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<LambdaCaptureContextExt<'input>>{

fn captureList(&self) -> Option<Rc<CaptureListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn captureDefault(&self) -> Option<Rc<CaptureDefaultContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Comma
/// Returns `None` if there is no child corresponding to token Comma
fn Comma(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, 0)
}

}

impl<'input> LambdaCaptureContextAttrs<'input> for LambdaCaptureContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaCapture(&mut self,)
	-> Result<Rc<LambdaCaptureContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaCaptureContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_lambdaCapture);
        let mut _localctx: Rc<LambdaCaptureContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(463);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(14,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule captureList*/
					recog.base.set_state(457);
					recog.captureList()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule captureDefault*/
					recog.base.set_state(458);
					recog.captureDefault()?;

					recog.base.set_state(461);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Comma {
						{
						recog.base.set_state(459);
						recog.base.match_token(Comma,&mut recog.err_handler)?;

						/*InvokeRule captureList*/
						recog.base.set_state(460);
						recog.captureList()?;

						}
					}

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- captureDefault ----------------
pub type CaptureDefaultContextAll<'input> = CaptureDefaultContext<'input>;


pub type CaptureDefaultContext<'input> = BaseParserRuleContext<'input,CaptureDefaultContextExt<'input>>;

#[derive(Clone)]
pub struct CaptureDefaultContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for CaptureDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for CaptureDefaultContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_captureDefault(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_captureDefault(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CaptureDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_captureDefault }
	//fn type_rule_index() -> usize where Self: Sized { RULE_captureDefault }
}
antlr_rust::tid!{CaptureDefaultContextExt<'a>}

impl<'input> CaptureDefaultContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaptureDefaultContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaptureDefaultContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CaptureDefaultContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<CaptureDefaultContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token And
/// Returns `None` if there is no child corresponding to token And
fn And(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(And, 0)
}
/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}

}

impl<'input> CaptureDefaultContextAttrs<'input> for CaptureDefaultContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn captureDefault(&mut self,)
	-> Result<Rc<CaptureDefaultContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaptureDefaultContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_captureDefault);
        let mut _localctx: Rc<CaptureDefaultContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(465);
			_la = recog.base.input.la(1);
			if { !(_la==And || _la==Assign) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- captureList ----------------
pub type CaptureListContextAll<'input> = CaptureListContext<'input>;


pub type CaptureListContext<'input> = BaseParserRuleContext<'input,CaptureListContextExt<'input>>;

#[derive(Clone)]
pub struct CaptureListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for CaptureListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for CaptureListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_captureList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_captureList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CaptureListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_captureList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_captureList }
}
antlr_rust::tid!{CaptureListContextExt<'a>}

impl<'input> CaptureListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaptureListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaptureListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CaptureListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<CaptureListContextExt<'input>>{

fn capture_all(&self) ->  Vec<Rc<CaptureContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn capture(&self, i: usize) -> Option<Rc<CaptureContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}
/// Retrieves first TerminalNode corresponding to token Ellipsis
/// Returns `None` if there is no child corresponding to token Ellipsis
fn Ellipsis(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, 0)
}

}

impl<'input> CaptureListContextAttrs<'input> for CaptureListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn captureList(&mut self,)
	-> Result<Rc<CaptureListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaptureListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_captureList);
        let mut _localctx: Rc<CaptureListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule capture*/
			recog.base.set_state(467);
			recog.capture()?;

			recog.base.set_state(472);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Comma {
				{
				{
				recog.base.set_state(468);
				recog.base.match_token(Comma,&mut recog.err_handler)?;

				/*InvokeRule capture*/
				recog.base.set_state(469);
				recog.capture()?;

				}
				}
				recog.base.set_state(474);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(476);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Ellipsis {
				{
				recog.base.set_state(475);
				recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- capture ----------------
pub type CaptureContextAll<'input> = CaptureContext<'input>;


pub type CaptureContext<'input> = BaseParserRuleContext<'input,CaptureContextExt<'input>>;

#[derive(Clone)]
pub struct CaptureContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for CaptureContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for CaptureContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_capture(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_capture(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CaptureContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_capture }
	//fn type_rule_index() -> usize where Self: Sized { RULE_capture }
}
antlr_rust::tid!{CaptureContextExt<'a>}

impl<'input> CaptureContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CaptureContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CaptureContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CaptureContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<CaptureContextExt<'input>>{

fn simpleCapture(&self) -> Option<Rc<SimpleCaptureContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn initcapture(&self) -> Option<Rc<InitcaptureContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CaptureContextAttrs<'input> for CaptureContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn capture(&mut self,)
	-> Result<Rc<CaptureContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CaptureContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_capture);
        let mut _localctx: Rc<CaptureContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(480);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(17,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule simpleCapture*/
					recog.base.set_state(478);
					recog.simpleCapture()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule initcapture*/
					recog.base.set_state(479);
					recog.initcapture()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleCapture ----------------
pub type SimpleCaptureContextAll<'input> = SimpleCaptureContext<'input>;


pub type SimpleCaptureContext<'input> = BaseParserRuleContext<'input,SimpleCaptureContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleCaptureContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for SimpleCaptureContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for SimpleCaptureContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_simpleCapture(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_simpleCapture(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SimpleCaptureContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleCapture }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleCapture }
}
antlr_rust::tid!{SimpleCaptureContextExt<'a>}

impl<'input> SimpleCaptureContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleCaptureContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleCaptureContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleCaptureContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<SimpleCaptureContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token And
/// Returns `None` if there is no child corresponding to token And
fn And(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(And, 0)
}
/// Retrieves first TerminalNode corresponding to token This
/// Returns `None` if there is no child corresponding to token This
fn This(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(This, 0)
}

}

impl<'input> SimpleCaptureContextAttrs<'input> for SimpleCaptureContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleCapture(&mut self,)
	-> Result<Rc<SimpleCaptureContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleCaptureContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_simpleCapture);
        let mut _localctx: Rc<SimpleCaptureContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(487);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 And | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(483);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==And {
						{
						recog.base.set_state(482);
						recog.base.match_token(And,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(485);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}

			 This 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(486);
					recog.base.match_token(This,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- initcapture ----------------
pub type InitcaptureContextAll<'input> = InitcaptureContext<'input>;


pub type InitcaptureContext<'input> = BaseParserRuleContext<'input,InitcaptureContextExt<'input>>;

#[derive(Clone)]
pub struct InitcaptureContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for InitcaptureContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for InitcaptureContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_initcapture(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_initcapture(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InitcaptureContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_initcapture }
	//fn type_rule_index() -> usize where Self: Sized { RULE_initcapture }
}
antlr_rust::tid!{InitcaptureContextExt<'a>}

impl<'input> InitcaptureContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InitcaptureContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InitcaptureContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InitcaptureContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<InitcaptureContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn initializer(&self) -> Option<Rc<InitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token And
/// Returns `None` if there is no child corresponding to token And
fn And(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(And, 0)
}

}

impl<'input> InitcaptureContextAttrs<'input> for InitcaptureContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn initcapture(&mut self,)
	-> Result<Rc<InitcaptureContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InitcaptureContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_initcapture);
        let mut _localctx: Rc<InitcaptureContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(490);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==And {
				{
				recog.base.set_state(489);
				recog.base.match_token(And,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(492);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			/*InvokeRule initializer*/
			recog.base.set_state(493);
			recog.initializer()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaDeclarator ----------------
pub type LambdaDeclaratorContextAll<'input> = LambdaDeclaratorContext<'input>;


pub type LambdaDeclaratorContext<'input> = BaseParserRuleContext<'input,LambdaDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for LambdaDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for LambdaDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_lambdaDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LambdaDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaDeclarator }
}
antlr_rust::tid!{LambdaDeclaratorContextExt<'a>}

impl<'input> LambdaDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<LambdaDeclaratorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn parameterDeclarationClause(&self) -> Option<Rc<ParameterDeclarationClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Mutable
/// Returns `None` if there is no child corresponding to token Mutable
fn Mutable(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Mutable, 0)
}
fn exceptionSpecification(&self) -> Option<Rc<ExceptionSpecificationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn trailingReturnType(&self) -> Option<Rc<TrailingReturnTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LambdaDeclaratorContextAttrs<'input> for LambdaDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaDeclarator(&mut self,)
	-> Result<Rc<LambdaDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_lambdaDeclarator);
        let mut _localctx: Rc<LambdaDeclaratorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(495);
			recog.base.match_token(LeftParen,&mut recog.err_handler)?;

			recog.base.set_state(497);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << Alignas) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Class) | (1usize << Const) | (1usize << Constexpr) | (1usize << Decltype) | (1usize << Double))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (Enum - 33)) | (1usize << (Explicit - 33)) | (1usize << (Extern - 33)) | (1usize << (Float - 33)) | (1usize << (Friend - 33)) | (1usize << (Inline - 33)) | (1usize << (Int - 33)) | (1usize << (Long - 33)) | (1usize << (Mutable - 33)) | (1usize << (Register - 33)) | (1usize << (Short - 33)) | (1usize << (Signed - 33)) | (1usize << (Static - 33)))) != 0) || ((((_la - 66)) & !0x3f) == 0 && ((1usize << (_la - 66)) & ((1usize << (Struct - 66)) | (1usize << (Thread_local - 66)) | (1usize << (Typedef - 66)) | (1usize << (Typename_ - 66)) | (1usize << (Union - 66)) | (1usize << (Unsigned - 66)) | (1usize << (Virtual - 66)) | (1usize << (Void - 66)) | (1usize << (Volatile - 66)) | (1usize << (Wchar - 66)) | (1usize << (LeftBracket - 66)))) != 0) || _la==Doublecolon || _la==Identifier {
				{
				/*InvokeRule parameterDeclarationClause*/
				recog.base.set_state(496);
				recog.parameterDeclarationClause()?;

				}
			}

			recog.base.set_state(499);
			recog.base.match_token(RightParen,&mut recog.err_handler)?;

			recog.base.set_state(501);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Mutable {
				{
				recog.base.set_state(500);
				recog.base.match_token(Mutable,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(504);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Noexcept || _la==Throw {
				{
				/*InvokeRule exceptionSpecification*/
				recog.base.set_state(503);
				recog.exceptionSpecification()?;

				}
			}

			recog.base.set_state(507);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Alignas || _la==LeftBracket {
				{
				/*InvokeRule attributeSpecifierSeq*/
				recog.base.set_state(506);
				recog.attributeSpecifierSeq()?;

				}
			}

			recog.base.set_state(510);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Arrow {
				{
				/*InvokeRule trailingReturnType*/
				recog.base.set_state(509);
				recog.trailingReturnType()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postfixExpression ----------------
pub type PostfixExpressionContextAll<'input> = PostfixExpressionContext<'input>;


pub type PostfixExpressionContext<'input> = BaseParserRuleContext<'input,PostfixExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PostfixExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for PostfixExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for PostfixExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postfixExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_postfixExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PostfixExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postfixExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postfixExpression }
}
antlr_rust::tid!{PostfixExpressionContextExt<'a>}

impl<'input> PostfixExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostfixExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostfixExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostfixExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<PostfixExpressionContextExt<'input>>{

fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn simpleTypeSpecifier(&self) -> Option<Rc<SimpleTypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeNameSpecifier(&self) -> Option<Rc<TypeNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn bracedInitList(&self) -> Option<Rc<BracedInitListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionList(&self) -> Option<Rc<ExpressionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Less
/// Returns `None` if there is no child corresponding to token Less
fn Less(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Less, 0)
}
fn theTypeId(&self) -> Option<Rc<TheTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Greater
/// Returns `None` if there is no child corresponding to token Greater
fn Greater(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Greater, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Dynamic_cast
/// Returns `None` if there is no child corresponding to token Dynamic_cast
fn Dynamic_cast(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Dynamic_cast, 0)
}
/// Retrieves first TerminalNode corresponding to token Static_cast
/// Returns `None` if there is no child corresponding to token Static_cast
fn Static_cast(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Static_cast, 0)
}
/// Retrieves first TerminalNode corresponding to token Reinterpret_cast
/// Returns `None` if there is no child corresponding to token Reinterpret_cast
fn Reinterpret_cast(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Reinterpret_cast, 0)
}
/// Retrieves first TerminalNode corresponding to token Const_cast
/// Returns `None` if there is no child corresponding to token Const_cast
fn Const_cast(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Const_cast, 0)
}
fn typeIdOfTheTypeId(&self) -> Option<Rc<TypeIdOfTheTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn postfixExpression(&self) -> Option<Rc<PostfixExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftBracket
/// Returns `None` if there is no child corresponding to token LeftBracket
fn LeftBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBracket, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBracket
/// Returns `None` if there is no child corresponding to token RightBracket
fn RightBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBracket, 0)
}
/// Retrieves first TerminalNode corresponding to token Dot
/// Returns `None` if there is no child corresponding to token Dot
fn Dot(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Dot, 0)
}
/// Retrieves first TerminalNode corresponding to token Arrow
/// Returns `None` if there is no child corresponding to token Arrow
fn Arrow(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Arrow, 0)
}
fn idExpression(&self) -> Option<Rc<IdExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pseudoDestructorName(&self) -> Option<Rc<PseudoDestructorNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Template
/// Returns `None` if there is no child corresponding to token Template
fn Template(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Template, 0)
}
/// Retrieves first TerminalNode corresponding to token PlusPlus
/// Returns `None` if there is no child corresponding to token PlusPlus
fn PlusPlus(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(PlusPlus, 0)
}
/// Retrieves first TerminalNode corresponding to token MinusMinus
/// Returns `None` if there is no child corresponding to token MinusMinus
fn MinusMinus(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(MinusMinus, 0)
}

}

impl<'input> PostfixExpressionContextAttrs<'input> for PostfixExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  postfixExpression(&mut self,)
	-> Result<Rc<PostfixExpressionContextAll<'input>>,ANTLRError> {
		self.postfixExpression_rec(0)
	}

	fn postfixExpression_rec(&mut self, _p: isize)
	-> Result<Rc<PostfixExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = PostfixExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 30, RULE_postfixExpression, _p);
	    let mut _localctx: Rc<PostfixExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 30;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(542);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(30,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule primaryExpression*/
					recog.base.set_state(513);
					recog.primaryExpression()?;

					}
				}
			,
				2 =>{
					{
					recog.base.set_state(516);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 Auto | Bool | Char | Char16 | Char32 | Decltype | Double | Float |
					 Int | Long | Short | Signed | Unsigned | Void | Wchar | Doublecolon |
					 Identifier 
						=> {
							{
							/*InvokeRule simpleTypeSpecifier*/
							recog.base.set_state(514);
							recog.simpleTypeSpecifier()?;

							}
						}

					 Typename_ 
						=> {
							{
							/*InvokeRule typeNameSpecifier*/
							recog.base.set_state(515);
							recog.typeNameSpecifier()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(524);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 LeftParen 
						=> {
							{
							recog.base.set_state(518);
							recog.base.match_token(LeftParen,&mut recog.err_handler)?;

							recog.base.set_state(520);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 71)) & !0x3f) == 0 && ((1usize << (_la - 71)) & ((1usize << (Throw - 71)) | (1usize << (Typeid_ - 71)) | (1usize << (Typename_ - 71)) | (1usize << (Unsigned - 71)) | (1usize << (Void - 71)) | (1usize << (Wchar - 71)) | (1usize << (LeftParen - 71)) | (1usize << (LeftBracket - 71)) | (1usize << (LeftBrace - 71)) | (1usize << (Plus - 71)) | (1usize << (Minus - 71)) | (1usize << (Star - 71)) | (1usize << (And - 71)) | (1usize << (Or - 71)) | (1usize << (Tilde - 71)) | (1usize << (Not - 71)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
								{
								/*InvokeRule expressionList*/
								recog.base.set_state(519);
								recog.expressionList()?;

								}
							}

							recog.base.set_state(522);
							recog.base.match_token(RightParen,&mut recog.err_handler)?;

							}
						}

					 LeftBrace 
						=> {
							{
							/*InvokeRule bracedInitList*/
							recog.base.set_state(523);
							recog.bracedInitList()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}
			,
				3 =>{
					{
					recog.base.set_state(526);
					_la = recog.base.input.la(1);
					if { !(_la==Const_cast || _la==Dynamic_cast || _la==Reinterpret_cast || _la==Static_cast) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(527);
					recog.base.match_token(Less,&mut recog.err_handler)?;

					/*InvokeRule theTypeId*/
					recog.base.set_state(528);
					recog.theTypeId()?;

					recog.base.set_state(529);
					recog.base.match_token(Greater,&mut recog.err_handler)?;

					recog.base.set_state(530);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(531);
					recog.expression()?;

					recog.base.set_state(532);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					{
					/*InvokeRule typeIdOfTheTypeId*/
					recog.base.set_state(534);
					recog.typeIdOfTheTypeId()?;

					recog.base.set_state(535);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					recog.base.set_state(538);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(29,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule expression*/
							recog.base.set_state(536);
							recog.expression()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule theTypeId*/
							recog.base.set_state(537);
							recog.theTypeId()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(540);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(571);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(36,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(569);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(35,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = PostfixExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_postfixExpression);
							_localctx = tmp;
							recog.base.set_state(544);
							if !({recog.precpred(None, 7)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 7)".to_owned()), None))?;
							}
							recog.base.set_state(545);
							recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

							recog.base.set_state(548);
							recog.err_handler.sync(&mut recog.base)?;
							match recog.base.input.la(1) {
							 IntegerLiteral | CharacterLiteral | FloatingLiteral | StringLiteral |
							 BooleanLiteral | PointerLiteral | UserDefinedLiteral | Alignof |
							 Auto | Bool | Char | Char16 | Char32 | Const_cast | Decltype | Delete |
							 Double | Dynamic_cast | Float | Int | Long | New | Noexcept | Operator |
							 Reinterpret_cast | Short | Signed | Sizeof | Static_cast | This |
							 Throw | Typeid_ | Typename_ | Unsigned | Void | Wchar | LeftParen |
							 LeftBracket | Plus | Minus | Star | And | Or | Tilde | Not | PlusPlus |
							 MinusMinus | Doublecolon | Identifier 
								=> {
									{
									/*InvokeRule expression*/
									recog.base.set_state(546);
									recog.expression()?;

									}
								}

							 LeftBrace 
								=> {
									{
									/*InvokeRule bracedInitList*/
									recog.base.set_state(547);
									recog.bracedInitList()?;

									}
								}

								_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
							}
							recog.base.set_state(550);
							recog.base.match_token(RightBracket,&mut recog.err_handler)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = PostfixExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_postfixExpression);
							_localctx = tmp;
							recog.base.set_state(552);
							if !({recog.precpred(None, 6)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 6)".to_owned()), None))?;
							}
							recog.base.set_state(553);
							recog.base.match_token(LeftParen,&mut recog.err_handler)?;

							recog.base.set_state(555);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 71)) & !0x3f) == 0 && ((1usize << (_la - 71)) & ((1usize << (Throw - 71)) | (1usize << (Typeid_ - 71)) | (1usize << (Typename_ - 71)) | (1usize << (Unsigned - 71)) | (1usize << (Void - 71)) | (1usize << (Wchar - 71)) | (1usize << (LeftParen - 71)) | (1usize << (LeftBracket - 71)) | (1usize << (LeftBrace - 71)) | (1usize << (Plus - 71)) | (1usize << (Minus - 71)) | (1usize << (Star - 71)) | (1usize << (And - 71)) | (1usize << (Or - 71)) | (1usize << (Tilde - 71)) | (1usize << (Not - 71)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
								{
								/*InvokeRule expressionList*/
								recog.base.set_state(554);
								recog.expressionList()?;

								}
							}

							recog.base.set_state(557);
							recog.base.match_token(RightParen,&mut recog.err_handler)?;

							}
						}
					,
						3 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = PostfixExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_postfixExpression);
							_localctx = tmp;
							recog.base.set_state(558);
							if !({recog.precpred(None, 4)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 4)".to_owned()), None))?;
							}
							recog.base.set_state(559);
							_la = recog.base.input.la(1);
							if { !(_la==Arrow || _la==Dot) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							recog.base.set_state(565);
							recog.err_handler.sync(&mut recog.base)?;
							match  recog.interpreter.adaptive_predict(34,&mut recog.base)? {
								1 =>{
									{
									recog.base.set_state(561);
									recog.err_handler.sync(&mut recog.base)?;
									_la = recog.base.input.la(1);
									if _la==Template {
										{
										recog.base.set_state(560);
										recog.base.match_token(Template,&mut recog.err_handler)?;

										}
									}

									/*InvokeRule idExpression*/
									recog.base.set_state(563);
									recog.idExpression()?;

									}
								}
							,
								2 =>{
									{
									/*InvokeRule pseudoDestructorName*/
									recog.base.set_state(564);
									recog.pseudoDestructorName()?;

									}
								}

								_ => {}
							}
							}
						}
					,
						4 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = PostfixExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_postfixExpression);
							_localctx = tmp;
							recog.base.set_state(567);
							if !({recog.precpred(None, 3)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 3)".to_owned()), None))?;
							}
							recog.base.set_state(568);
							_la = recog.base.input.la(1);
							if { !(_la==PlusPlus || _la==MinusMinus) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(573);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(36,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- typeIdOfTheTypeId ----------------
pub type TypeIdOfTheTypeIdContextAll<'input> = TypeIdOfTheTypeIdContext<'input>;


pub type TypeIdOfTheTypeIdContext<'input> = BaseParserRuleContext<'input,TypeIdOfTheTypeIdContextExt<'input>>;

#[derive(Clone)]
pub struct TypeIdOfTheTypeIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TypeIdOfTheTypeIdContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TypeIdOfTheTypeIdContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeIdOfTheTypeId(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_typeIdOfTheTypeId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeIdOfTheTypeIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeIdOfTheTypeId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeIdOfTheTypeId }
}
antlr_rust::tid!{TypeIdOfTheTypeIdContextExt<'a>}

impl<'input> TypeIdOfTheTypeIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeIdOfTheTypeIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeIdOfTheTypeIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeIdOfTheTypeIdContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TypeIdOfTheTypeIdContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Typeid_
/// Returns `None` if there is no child corresponding to token Typeid_
fn Typeid_(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Typeid_, 0)
}

}

impl<'input> TypeIdOfTheTypeIdContextAttrs<'input> for TypeIdOfTheTypeIdContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeIdOfTheTypeId(&mut self,)
	-> Result<Rc<TypeIdOfTheTypeIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeIdOfTheTypeIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_typeIdOfTheTypeId);
        let mut _localctx: Rc<TypeIdOfTheTypeIdContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(574);
			recog.base.match_token(Typeid_,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expressionList ----------------
pub type ExpressionListContextAll<'input> = ExpressionListContext<'input>;


pub type ExpressionListContext<'input> = BaseParserRuleContext<'input,ExpressionListContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ExpressionListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ExpressionListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_expressionList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_expressionList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExpressionListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expressionList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expressionList }
}
antlr_rust::tid!{ExpressionListContextExt<'a>}

impl<'input> ExpressionListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ExpressionListContextExt<'input>>{

fn initializerList(&self) -> Option<Rc<InitializerListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExpressionListContextAttrs<'input> for ExpressionListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expressionList(&mut self,)
	-> Result<Rc<ExpressionListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_expressionList);
        let mut _localctx: Rc<ExpressionListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule initializerList*/
			recog.base.set_state(576);
			recog.initializerList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pseudoDestructorName ----------------
pub type PseudoDestructorNameContextAll<'input> = PseudoDestructorNameContext<'input>;


pub type PseudoDestructorNameContext<'input> = BaseParserRuleContext<'input,PseudoDestructorNameContextExt<'input>>;

#[derive(Clone)]
pub struct PseudoDestructorNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for PseudoDestructorNameContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for PseudoDestructorNameContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pseudoDestructorName(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_pseudoDestructorName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PseudoDestructorNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pseudoDestructorName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pseudoDestructorName }
}
antlr_rust::tid!{PseudoDestructorNameContextExt<'a>}

impl<'input> PseudoDestructorNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PseudoDestructorNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PseudoDestructorNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PseudoDestructorNameContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<PseudoDestructorNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Tilde
/// Returns `None` if there is no child corresponding to token Tilde
fn Tilde(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Tilde, 0)
}
fn theTypeName_all(&self) ->  Vec<Rc<TheTypeNameContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn theTypeName(&self, i: usize) -> Option<Rc<TheTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Doublecolon
/// Returns `None` if there is no child corresponding to token Doublecolon
fn Doublecolon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Doublecolon, 0)
}
/// Retrieves first TerminalNode corresponding to token Template
/// Returns `None` if there is no child corresponding to token Template
fn Template(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Template, 0)
}
fn simpleTemplateId(&self) -> Option<Rc<SimpleTemplateIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn decltypeSpecifier(&self) -> Option<Rc<DecltypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PseudoDestructorNameContextAttrs<'input> for PseudoDestructorNameContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pseudoDestructorName(&mut self,)
	-> Result<Rc<PseudoDestructorNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PseudoDestructorNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_pseudoDestructorName);
        let mut _localctx: Rc<PseudoDestructorNameContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(597);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(39,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(579);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(37,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule nestedNameSpecifier*/
							recog.base.set_state(578);
							recog.nestedNameSpecifier_rec(0)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(584);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Identifier {
						{
						/*InvokeRule theTypeName*/
						recog.base.set_state(581);
						recog.theTypeName()?;

						recog.base.set_state(582);
						recog.base.match_token(Doublecolon,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(586);
					recog.base.match_token(Tilde,&mut recog.err_handler)?;

					/*InvokeRule theTypeName*/
					recog.base.set_state(587);
					recog.theTypeName()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule nestedNameSpecifier*/
					recog.base.set_state(588);
					recog.nestedNameSpecifier_rec(0)?;

					recog.base.set_state(589);
					recog.base.match_token(Template,&mut recog.err_handler)?;

					/*InvokeRule simpleTemplateId*/
					recog.base.set_state(590);
					recog.simpleTemplateId()?;

					recog.base.set_state(591);
					recog.base.match_token(Doublecolon,&mut recog.err_handler)?;

					recog.base.set_state(592);
					recog.base.match_token(Tilde,&mut recog.err_handler)?;

					/*InvokeRule theTypeName*/
					recog.base.set_state(593);
					recog.theTypeName()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(595);
					recog.base.match_token(Tilde,&mut recog.err_handler)?;

					/*InvokeRule decltypeSpecifier*/
					recog.base.set_state(596);
					recog.decltypeSpecifier()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unaryExpression ----------------
pub type UnaryExpressionContextAll<'input> = UnaryExpressionContext<'input>;


pub type UnaryExpressionContext<'input> = BaseParserRuleContext<'input,UnaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct UnaryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for UnaryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for UnaryExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unaryExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_unaryExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnaryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unaryExpression }
}
antlr_rust::tid!{UnaryExpressionContextExt<'a>}

impl<'input> UnaryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnaryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnaryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnaryExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<UnaryExpressionContextExt<'input>>{

fn postfixExpression(&self) -> Option<Rc<PostfixExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PlusPlus
/// Returns `None` if there is no child corresponding to token PlusPlus
fn PlusPlus(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(PlusPlus, 0)
}
/// Retrieves first TerminalNode corresponding to token MinusMinus
/// Returns `None` if there is no child corresponding to token MinusMinus
fn MinusMinus(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(MinusMinus, 0)
}
fn unaryOperator(&self) -> Option<Rc<UnaryOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Sizeof
/// Returns `None` if there is no child corresponding to token Sizeof
fn Sizeof(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Sizeof, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn theTypeId(&self) -> Option<Rc<TheTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
/// Retrieves first TerminalNode corresponding to token Ellipsis
/// Returns `None` if there is no child corresponding to token Ellipsis
fn Ellipsis(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token Alignof
/// Returns `None` if there is no child corresponding to token Alignof
fn Alignof(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Alignof, 0)
}
fn noExceptExpression(&self) -> Option<Rc<NoExceptExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn newExpression_(&self) -> Option<Rc<NewExpression_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn deleteExpression(&self) -> Option<Rc<DeleteExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnaryExpressionContextAttrs<'input> for UnaryExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unaryExpression(&mut self,)
	-> Result<Rc<UnaryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_unaryExpression);
        let mut _localctx: Rc<UnaryExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(626);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(42,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule postfixExpression*/
					recog.base.set_state(599);
					recog.postfixExpression_rec(0)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(604);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 PlusPlus 
						=> {
							{
							recog.base.set_state(600);
							recog.base.match_token(PlusPlus,&mut recog.err_handler)?;

							}
						}

					 MinusMinus 
						=> {
							{
							recog.base.set_state(601);
							recog.base.match_token(MinusMinus,&mut recog.err_handler)?;

							}
						}

					 Plus | Minus | Star | And | Or | Tilde | Not 
						=> {
							{
							/*InvokeRule unaryOperator*/
							recog.base.set_state(602);
							recog.unaryOperator()?;

							}
						}

					 Sizeof 
						=> {
							{
							recog.base.set_state(603);
							recog.base.match_token(Sizeof,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					/*InvokeRule unaryExpression*/
					recog.base.set_state(606);
					recog.unaryExpression()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(607);
					recog.base.match_token(Sizeof,&mut recog.err_handler)?;

					recog.base.set_state(616);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 LeftParen 
						=> {
							{
							recog.base.set_state(608);
							recog.base.match_token(LeftParen,&mut recog.err_handler)?;

							/*InvokeRule theTypeId*/
							recog.base.set_state(609);
							recog.theTypeId()?;

							recog.base.set_state(610);
							recog.base.match_token(RightParen,&mut recog.err_handler)?;

							}
						}

					 Ellipsis 
						=> {
							{
							recog.base.set_state(612);
							recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

							recog.base.set_state(613);
							recog.base.match_token(LeftParen,&mut recog.err_handler)?;

							recog.base.set_state(614);
							recog.base.match_token(Identifier,&mut recog.err_handler)?;

							recog.base.set_state(615);
							recog.base.match_token(RightParen,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(618);
					recog.base.match_token(Alignof,&mut recog.err_handler)?;

					recog.base.set_state(619);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule theTypeId*/
					recog.base.set_state(620);
					recog.theTypeId()?;

					recog.base.set_state(621);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule noExceptExpression*/
					recog.base.set_state(623);
					recog.noExceptExpression()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule newExpression_*/
					recog.base.set_state(624);
					recog.newExpression_()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule deleteExpression*/
					recog.base.set_state(625);
					recog.deleteExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unaryOperator ----------------
pub type UnaryOperatorContextAll<'input> = UnaryOperatorContext<'input>;


pub type UnaryOperatorContext<'input> = BaseParserRuleContext<'input,UnaryOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct UnaryOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for UnaryOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for UnaryOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unaryOperator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_unaryOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnaryOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unaryOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unaryOperator }
}
antlr_rust::tid!{UnaryOperatorContextExt<'a>}

impl<'input> UnaryOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnaryOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnaryOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnaryOperatorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<UnaryOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Or
/// Returns `None` if there is no child corresponding to token Or
fn Or(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Or, 0)
}
/// Retrieves first TerminalNode corresponding to token Star
/// Returns `None` if there is no child corresponding to token Star
fn Star(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Star, 0)
}
/// Retrieves first TerminalNode corresponding to token And
/// Returns `None` if there is no child corresponding to token And
fn And(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(And, 0)
}
/// Retrieves first TerminalNode corresponding to token Plus
/// Returns `None` if there is no child corresponding to token Plus
fn Plus(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Plus, 0)
}
/// Retrieves first TerminalNode corresponding to token Tilde
/// Returns `None` if there is no child corresponding to token Tilde
fn Tilde(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Tilde, 0)
}
/// Retrieves first TerminalNode corresponding to token Minus
/// Returns `None` if there is no child corresponding to token Minus
fn Minus(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Minus, 0)
}
/// Retrieves first TerminalNode corresponding to token Not
/// Returns `None` if there is no child corresponding to token Not
fn Not(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Not, 0)
}

}

impl<'input> UnaryOperatorContextAttrs<'input> for UnaryOperatorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unaryOperator(&mut self,)
	-> Result<Rc<UnaryOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnaryOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_unaryOperator);
        let mut _localctx: Rc<UnaryOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(628);
			_la = recog.base.input.la(1);
			if { !(((((_la - 91)) & !0x3f) == 0 && ((1usize << (_la - 91)) & ((1usize << (Plus - 91)) | (1usize << (Minus - 91)) | (1usize << (Star - 91)) | (1usize << (And - 91)) | (1usize << (Or - 91)) | (1usize << (Tilde - 91)) | (1usize << (Not - 91)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- newExpression_ ----------------
pub type NewExpression_ContextAll<'input> = NewExpression_Context<'input>;


pub type NewExpression_Context<'input> = BaseParserRuleContext<'input,NewExpression_ContextExt<'input>>;

#[derive(Clone)]
pub struct NewExpression_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NewExpression_Context<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NewExpression_Context<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_newExpression_(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_newExpression_(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NewExpression_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_newExpression_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_newExpression_ }
}
antlr_rust::tid!{NewExpression_ContextExt<'a>}

impl<'input> NewExpression_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NewExpression_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NewExpression_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NewExpression_ContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NewExpression_ContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token New
/// Returns `None` if there is no child corresponding to token New
fn New(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(New, 0)
}
fn newTypeId(&self) -> Option<Rc<NewTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn theTypeId(&self) -> Option<Rc<TheTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
/// Retrieves first TerminalNode corresponding to token Doublecolon
/// Returns `None` if there is no child corresponding to token Doublecolon
fn Doublecolon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Doublecolon, 0)
}
fn newPlacement(&self) -> Option<Rc<NewPlacementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn newInitializer_(&self) -> Option<Rc<NewInitializer_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NewExpression_ContextAttrs<'input> for NewExpression_Context<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn newExpression_(&mut self,)
	-> Result<Rc<NewExpression_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NewExpression_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_newExpression_);
        let mut _localctx: Rc<NewExpression_ContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(631);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Doublecolon {
				{
				recog.base.set_state(630);
				recog.base.match_token(Doublecolon,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(633);
			recog.base.match_token(New,&mut recog.err_handler)?;

			recog.base.set_state(635);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(44,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule newPlacement*/
					recog.base.set_state(634);
					recog.newPlacement()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(642);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Auto | Bool | Char | Char16 | Char32 | Class | Const | Decltype | Double |
			 Enum | Float | Int | Long | Short | Signed | Struct | Typename_ | Union |
			 Unsigned | Void | Volatile | Wchar | Doublecolon | Identifier 
				=> {
					{
					/*InvokeRule newTypeId*/
					recog.base.set_state(637);
					recog.newTypeId()?;

					}
				}

			 LeftParen 
				=> {
					{
					recog.base.set_state(638);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule theTypeId*/
					recog.base.set_state(639);
					recog.theTypeId()?;

					recog.base.set_state(640);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(645);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LeftParen || _la==LeftBrace {
				{
				/*InvokeRule newInitializer_*/
				recog.base.set_state(644);
				recog.newInitializer_()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- newPlacement ----------------
pub type NewPlacementContextAll<'input> = NewPlacementContext<'input>;


pub type NewPlacementContext<'input> = BaseParserRuleContext<'input,NewPlacementContextExt<'input>>;

#[derive(Clone)]
pub struct NewPlacementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NewPlacementContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NewPlacementContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_newPlacement(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_newPlacement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NewPlacementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_newPlacement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_newPlacement }
}
antlr_rust::tid!{NewPlacementContextExt<'a>}

impl<'input> NewPlacementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NewPlacementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NewPlacementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NewPlacementContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NewPlacementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn expressionList(&self) -> Option<Rc<ExpressionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}

}

impl<'input> NewPlacementContextAttrs<'input> for NewPlacementContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn newPlacement(&mut self,)
	-> Result<Rc<NewPlacementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NewPlacementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_newPlacement);
        let mut _localctx: Rc<NewPlacementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(647);
			recog.base.match_token(LeftParen,&mut recog.err_handler)?;

			/*InvokeRule expressionList*/
			recog.base.set_state(648);
			recog.expressionList()?;

			recog.base.set_state(649);
			recog.base.match_token(RightParen,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- newTypeId ----------------
pub type NewTypeIdContextAll<'input> = NewTypeIdContext<'input>;


pub type NewTypeIdContext<'input> = BaseParserRuleContext<'input,NewTypeIdContextExt<'input>>;

#[derive(Clone)]
pub struct NewTypeIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NewTypeIdContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NewTypeIdContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_newTypeId(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_newTypeId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NewTypeIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_newTypeId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_newTypeId }
}
antlr_rust::tid!{NewTypeIdContextExt<'a>}

impl<'input> NewTypeIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NewTypeIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NewTypeIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NewTypeIdContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NewTypeIdContextExt<'input>>{

fn typeSpecifierSeq(&self) -> Option<Rc<TypeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn newDeclarator_(&self) -> Option<Rc<NewDeclarator_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NewTypeIdContextAttrs<'input> for NewTypeIdContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn newTypeId(&mut self,)
	-> Result<Rc<NewTypeIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NewTypeIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_newTypeId);
        let mut _localctx: Rc<NewTypeIdContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typeSpecifierSeq*/
			recog.base.set_state(651);
			recog.typeSpecifierSeq()?;

			recog.base.set_state(653);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(47,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule newDeclarator_*/
					recog.base.set_state(652);
					recog.newDeclarator_()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- newDeclarator_ ----------------
pub type NewDeclarator_ContextAll<'input> = NewDeclarator_Context<'input>;


pub type NewDeclarator_Context<'input> = BaseParserRuleContext<'input,NewDeclarator_ContextExt<'input>>;

#[derive(Clone)]
pub struct NewDeclarator_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NewDeclarator_Context<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NewDeclarator_Context<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_newDeclarator_(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_newDeclarator_(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NewDeclarator_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_newDeclarator_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_newDeclarator_ }
}
antlr_rust::tid!{NewDeclarator_ContextExt<'a>}

impl<'input> NewDeclarator_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NewDeclarator_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NewDeclarator_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NewDeclarator_ContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NewDeclarator_ContextExt<'input>>{

fn pointerOperator(&self) -> Option<Rc<PointerOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn newDeclarator_(&self) -> Option<Rc<NewDeclarator_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn noPointerNewDeclarator(&self) -> Option<Rc<NoPointerNewDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NewDeclarator_ContextAttrs<'input> for NewDeclarator_Context<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn newDeclarator_(&mut self,)
	-> Result<Rc<NewDeclarator_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NewDeclarator_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_newDeclarator_);
        let mut _localctx: Rc<NewDeclarator_ContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(660);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Decltype | Star | And | AndAnd | Doublecolon | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule pointerOperator*/
					recog.base.set_state(655);
					recog.pointerOperator()?;

					recog.base.set_state(657);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(48,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule newDeclarator_*/
							recog.base.set_state(656);
							recog.newDeclarator_()?;

							}
						}

						_ => {}
					}
					}
				}

			 LeftBracket 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule noPointerNewDeclarator*/
					recog.base.set_state(659);
					recog.noPointerNewDeclarator_rec(0)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- noPointerNewDeclarator ----------------
pub type NoPointerNewDeclaratorContextAll<'input> = NoPointerNewDeclaratorContext<'input>;


pub type NoPointerNewDeclaratorContext<'input> = BaseParserRuleContext<'input,NoPointerNewDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct NoPointerNewDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NoPointerNewDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NoPointerNewDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_noPointerNewDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_noPointerNewDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NoPointerNewDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_noPointerNewDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_noPointerNewDeclarator }
}
antlr_rust::tid!{NoPointerNewDeclaratorContextExt<'a>}

impl<'input> NoPointerNewDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NoPointerNewDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NoPointerNewDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NoPointerNewDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NoPointerNewDeclaratorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LeftBracket
/// Returns `None` if there is no child corresponding to token LeftBracket
fn LeftBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBracket, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightBracket
/// Returns `None` if there is no child corresponding to token RightBracket
fn RightBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBracket, 0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn noPointerNewDeclarator(&self) -> Option<Rc<NoPointerNewDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NoPointerNewDeclaratorContextAttrs<'input> for NoPointerNewDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  noPointerNewDeclarator(&mut self,)
	-> Result<Rc<NoPointerNewDeclaratorContextAll<'input>>,ANTLRError> {
		self.noPointerNewDeclarator_rec(0)
	}

	fn noPointerNewDeclarator_rec(&mut self, _p: isize)
	-> Result<Rc<NoPointerNewDeclaratorContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = NoPointerNewDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 50, RULE_noPointerNewDeclarator, _p);
	    let mut _localctx: Rc<NoPointerNewDeclaratorContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 50;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			recog.base.set_state(663);
			recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(664);
			recog.expression()?;

			recog.base.set_state(665);
			recog.base.match_token(RightBracket,&mut recog.err_handler)?;

			recog.base.set_state(667);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(50,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule attributeSpecifierSeq*/
					recog.base.set_state(666);
					recog.attributeSpecifierSeq()?;

					}
				}

				_ => {}
			}
			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(678);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(52,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = NoPointerNewDeclaratorContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_noPointerNewDeclarator);
					_localctx = tmp;
					recog.base.set_state(669);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(670);
					recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

					/*InvokeRule constantExpression*/
					recog.base.set_state(671);
					recog.constantExpression()?;

					recog.base.set_state(672);
					recog.base.match_token(RightBracket,&mut recog.err_handler)?;

					recog.base.set_state(674);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(51,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule attributeSpecifierSeq*/
							recog.base.set_state(673);
							recog.attributeSpecifierSeq()?;

							}
						}

						_ => {}
					}
					}
					} 
				}
				recog.base.set_state(680);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(52,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- newInitializer_ ----------------
pub type NewInitializer_ContextAll<'input> = NewInitializer_Context<'input>;


pub type NewInitializer_Context<'input> = BaseParserRuleContext<'input,NewInitializer_ContextExt<'input>>;

#[derive(Clone)]
pub struct NewInitializer_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NewInitializer_Context<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NewInitializer_Context<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_newInitializer_(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_newInitializer_(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NewInitializer_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_newInitializer_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_newInitializer_ }
}
antlr_rust::tid!{NewInitializer_ContextExt<'a>}

impl<'input> NewInitializer_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NewInitializer_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NewInitializer_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NewInitializer_ContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NewInitializer_ContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn expressionList(&self) -> Option<Rc<ExpressionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn bracedInitList(&self) -> Option<Rc<BracedInitListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NewInitializer_ContextAttrs<'input> for NewInitializer_Context<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn newInitializer_(&mut self,)
	-> Result<Rc<NewInitializer_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NewInitializer_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_newInitializer_);
        let mut _localctx: Rc<NewInitializer_ContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(687);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LeftParen 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(681);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					recog.base.set_state(683);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 71)) & !0x3f) == 0 && ((1usize << (_la - 71)) & ((1usize << (Throw - 71)) | (1usize << (Typeid_ - 71)) | (1usize << (Typename_ - 71)) | (1usize << (Unsigned - 71)) | (1usize << (Void - 71)) | (1usize << (Wchar - 71)) | (1usize << (LeftParen - 71)) | (1usize << (LeftBracket - 71)) | (1usize << (LeftBrace - 71)) | (1usize << (Plus - 71)) | (1usize << (Minus - 71)) | (1usize << (Star - 71)) | (1usize << (And - 71)) | (1usize << (Or - 71)) | (1usize << (Tilde - 71)) | (1usize << (Not - 71)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
						{
						/*InvokeRule expressionList*/
						recog.base.set_state(682);
						recog.expressionList()?;

						}
					}

					recog.base.set_state(685);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}

			 LeftBrace 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule bracedInitList*/
					recog.base.set_state(686);
					recog.bracedInitList()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- deleteExpression ----------------
pub type DeleteExpressionContextAll<'input> = DeleteExpressionContext<'input>;


pub type DeleteExpressionContext<'input> = BaseParserRuleContext<'input,DeleteExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct DeleteExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for DeleteExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for DeleteExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_deleteExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_deleteExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DeleteExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_deleteExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_deleteExpression }
}
antlr_rust::tid!{DeleteExpressionContextExt<'a>}

impl<'input> DeleteExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeleteExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeleteExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeleteExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<DeleteExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Delete
/// Returns `None` if there is no child corresponding to token Delete
fn Delete(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Delete, 0)
}
fn castExpression(&self) -> Option<Rc<CastExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Doublecolon
/// Returns `None` if there is no child corresponding to token Doublecolon
fn Doublecolon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Doublecolon, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftBracket
/// Returns `None` if there is no child corresponding to token LeftBracket
fn LeftBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBracket, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBracket
/// Returns `None` if there is no child corresponding to token RightBracket
fn RightBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBracket, 0)
}

}

impl<'input> DeleteExpressionContextAttrs<'input> for DeleteExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn deleteExpression(&mut self,)
	-> Result<Rc<DeleteExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeleteExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_deleteExpression);
        let mut _localctx: Rc<DeleteExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(690);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Doublecolon {
				{
				recog.base.set_state(689);
				recog.base.match_token(Doublecolon,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(692);
			recog.base.match_token(Delete,&mut recog.err_handler)?;

			recog.base.set_state(695);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(56,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(693);
					recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

					recog.base.set_state(694);
					recog.base.match_token(RightBracket,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule castExpression*/
			recog.base.set_state(697);
			recog.castExpression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- noExceptExpression ----------------
pub type NoExceptExpressionContextAll<'input> = NoExceptExpressionContext<'input>;


pub type NoExceptExpressionContext<'input> = BaseParserRuleContext<'input,NoExceptExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct NoExceptExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NoExceptExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NoExceptExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_noExceptExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_noExceptExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NoExceptExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_noExceptExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_noExceptExpression }
}
antlr_rust::tid!{NoExceptExpressionContextExt<'a>}

impl<'input> NoExceptExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NoExceptExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NoExceptExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NoExceptExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NoExceptExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Noexcept
/// Returns `None` if there is no child corresponding to token Noexcept
fn Noexcept(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Noexcept, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}

}

impl<'input> NoExceptExpressionContextAttrs<'input> for NoExceptExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn noExceptExpression(&mut self,)
	-> Result<Rc<NoExceptExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NoExceptExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_noExceptExpression);
        let mut _localctx: Rc<NoExceptExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(699);
			recog.base.match_token(Noexcept,&mut recog.err_handler)?;

			recog.base.set_state(700);
			recog.base.match_token(LeftParen,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(701);
			recog.expression()?;

			recog.base.set_state(702);
			recog.base.match_token(RightParen,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- castExpression ----------------
pub type CastExpressionContextAll<'input> = CastExpressionContext<'input>;


pub type CastExpressionContext<'input> = BaseParserRuleContext<'input,CastExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct CastExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for CastExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for CastExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_castExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_castExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CastExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_castExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_castExpression }
}
antlr_rust::tid!{CastExpressionContextExt<'a>}

impl<'input> CastExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CastExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CastExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CastExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<CastExpressionContextExt<'input>>{

fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn theTypeId(&self) -> Option<Rc<TheTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn castExpression(&self) -> Option<Rc<CastExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CastExpressionContextAttrs<'input> for CastExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn castExpression(&mut self,)
	-> Result<Rc<CastExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CastExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_castExpression);
        let mut _localctx: Rc<CastExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(710);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(57,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unaryExpression*/
					recog.base.set_state(704);
					recog.unaryExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(705);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule theTypeId*/
					recog.base.set_state(706);
					recog.theTypeId()?;

					recog.base.set_state(707);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					/*InvokeRule castExpression*/
					recog.base.set_state(708);
					recog.castExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pointerMemberExpression ----------------
pub type PointerMemberExpressionContextAll<'input> = PointerMemberExpressionContext<'input>;


pub type PointerMemberExpressionContext<'input> = BaseParserRuleContext<'input,PointerMemberExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PointerMemberExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for PointerMemberExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for PointerMemberExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pointerMemberExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_pointerMemberExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PointerMemberExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pointerMemberExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pointerMemberExpression }
}
antlr_rust::tid!{PointerMemberExpressionContextExt<'a>}

impl<'input> PointerMemberExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PointerMemberExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PointerMemberExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PointerMemberExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<PointerMemberExpressionContextExt<'input>>{

fn castExpression_all(&self) ->  Vec<Rc<CastExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn castExpression(&self, i: usize) -> Option<Rc<CastExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DotStar in current rule
fn DotStar_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DotStar, starting from 0.
/// Returns `None` if number of children corresponding to token DotStar is less or equal than `i`.
fn DotStar(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(DotStar, i)
}
/// Retrieves all `TerminalNode`s corresponding to token ArrowStar in current rule
fn ArrowStar_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token ArrowStar, starting from 0.
/// Returns `None` if number of children corresponding to token ArrowStar is less or equal than `i`.
fn ArrowStar(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(ArrowStar, i)
}

}

impl<'input> PointerMemberExpressionContextAttrs<'input> for PointerMemberExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pointerMemberExpression(&mut self,)
	-> Result<Rc<PointerMemberExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PointerMemberExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_pointerMemberExpression);
        let mut _localctx: Rc<PointerMemberExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule castExpression*/
			recog.base.set_state(712);
			recog.castExpression()?;

			recog.base.set_state(717);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==ArrowStar || _la==DotStar {
				{
				{
				recog.base.set_state(713);
				_la = recog.base.input.la(1);
				if { !(_la==ArrowStar || _la==DotStar) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				/*InvokeRule castExpression*/
				recog.base.set_state(714);
				recog.castExpression()?;

				}
				}
				recog.base.set_state(719);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiplicativeExpression ----------------
pub type MultiplicativeExpressionContextAll<'input> = MultiplicativeExpressionContext<'input>;


pub type MultiplicativeExpressionContext<'input> = BaseParserRuleContext<'input,MultiplicativeExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct MultiplicativeExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for MultiplicativeExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for MultiplicativeExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multiplicativeExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_multiplicativeExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MultiplicativeExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiplicativeExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiplicativeExpression }
}
antlr_rust::tid!{MultiplicativeExpressionContextExt<'a>}

impl<'input> MultiplicativeExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiplicativeExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiplicativeExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiplicativeExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<MultiplicativeExpressionContextExt<'input>>{

fn pointerMemberExpression_all(&self) ->  Vec<Rc<PointerMemberExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn pointerMemberExpression(&self, i: usize) -> Option<Rc<PointerMemberExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Star in current rule
fn Star_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Star, starting from 0.
/// Returns `None` if number of children corresponding to token Star is less or equal than `i`.
fn Star(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Star, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Div in current rule
fn Div_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Div, starting from 0.
/// Returns `None` if number of children corresponding to token Div is less or equal than `i`.
fn Div(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Div, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Mod in current rule
fn Mod_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Mod, starting from 0.
/// Returns `None` if number of children corresponding to token Mod is less or equal than `i`.
fn Mod(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Mod, i)
}

}

impl<'input> MultiplicativeExpressionContextAttrs<'input> for MultiplicativeExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiplicativeExpression(&mut self,)
	-> Result<Rc<MultiplicativeExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiplicativeExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_multiplicativeExpression);
        let mut _localctx: Rc<MultiplicativeExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule pointerMemberExpression*/
			recog.base.set_state(720);
			recog.pointerMemberExpression()?;

			recog.base.set_state(725);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 93)) & !0x3f) == 0 && ((1usize << (_la - 93)) & ((1usize << (Star - 93)) | (1usize << (Div - 93)) | (1usize << (Mod - 93)))) != 0) {
				{
				{
				recog.base.set_state(721);
				_la = recog.base.input.la(1);
				if { !(((((_la - 93)) & !0x3f) == 0 && ((1usize << (_la - 93)) & ((1usize << (Star - 93)) | (1usize << (Div - 93)) | (1usize << (Mod - 93)))) != 0)) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				/*InvokeRule pointerMemberExpression*/
				recog.base.set_state(722);
				recog.pointerMemberExpression()?;

				}
				}
				recog.base.set_state(727);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- additiveExpression ----------------
pub type AdditiveExpressionContextAll<'input> = AdditiveExpressionContext<'input>;


pub type AdditiveExpressionContext<'input> = BaseParserRuleContext<'input,AdditiveExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AdditiveExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AdditiveExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AdditiveExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_additiveExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_additiveExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AdditiveExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_additiveExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_additiveExpression }
}
antlr_rust::tid!{AdditiveExpressionContextExt<'a>}

impl<'input> AdditiveExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AdditiveExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AdditiveExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AdditiveExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AdditiveExpressionContextExt<'input>>{

fn multiplicativeExpression_all(&self) ->  Vec<Rc<MultiplicativeExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn multiplicativeExpression(&self, i: usize) -> Option<Rc<MultiplicativeExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Plus in current rule
fn Plus_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Plus, starting from 0.
/// Returns `None` if number of children corresponding to token Plus is less or equal than `i`.
fn Plus(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Plus, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Minus in current rule
fn Minus_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Minus, starting from 0.
/// Returns `None` if number of children corresponding to token Minus is less or equal than `i`.
fn Minus(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Minus, i)
}

}

impl<'input> AdditiveExpressionContextAttrs<'input> for AdditiveExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn additiveExpression(&mut self,)
	-> Result<Rc<AdditiveExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AdditiveExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_additiveExpression);
        let mut _localctx: Rc<AdditiveExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule multiplicativeExpression*/
			recog.base.set_state(728);
			recog.multiplicativeExpression()?;

			recog.base.set_state(733);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Plus || _la==Minus {
				{
				{
				recog.base.set_state(729);
				_la = recog.base.input.la(1);
				if { !(_la==Plus || _la==Minus) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				/*InvokeRule multiplicativeExpression*/
				recog.base.set_state(730);
				recog.multiplicativeExpression()?;

				}
				}
				recog.base.set_state(735);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shiftExpression ----------------
pub type ShiftExpressionContextAll<'input> = ShiftExpressionContext<'input>;


pub type ShiftExpressionContext<'input> = BaseParserRuleContext<'input,ShiftExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ShiftExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ShiftExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ShiftExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shiftExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_shiftExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShiftExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shiftExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shiftExpression }
}
antlr_rust::tid!{ShiftExpressionContextExt<'a>}

impl<'input> ShiftExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShiftExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShiftExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShiftExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ShiftExpressionContextExt<'input>>{

fn additiveExpression_all(&self) ->  Vec<Rc<AdditiveExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn additiveExpression(&self, i: usize) -> Option<Rc<AdditiveExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn shiftOperator_all(&self) ->  Vec<Rc<ShiftOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn shiftOperator(&self, i: usize) -> Option<Rc<ShiftOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ShiftExpressionContextAttrs<'input> for ShiftExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shiftExpression(&mut self,)
	-> Result<Rc<ShiftExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShiftExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_shiftExpression);
        let mut _localctx: Rc<ShiftExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule additiveExpression*/
			recog.base.set_state(736);
			recog.additiveExpression()?;

			recog.base.set_state(742);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(61,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule shiftOperator*/
					recog.base.set_state(737);
					recog.shiftOperator()?;

					/*InvokeRule additiveExpression*/
					recog.base.set_state(738);
					recog.additiveExpression()?;

					}
					} 
				}
				recog.base.set_state(744);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(61,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shiftOperator ----------------
pub type ShiftOperatorContextAll<'input> = ShiftOperatorContext<'input>;


pub type ShiftOperatorContext<'input> = BaseParserRuleContext<'input,ShiftOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct ShiftOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ShiftOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ShiftOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shiftOperator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_shiftOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShiftOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shiftOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shiftOperator }
}
antlr_rust::tid!{ShiftOperatorContextExt<'a>}

impl<'input> ShiftOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShiftOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShiftOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShiftOperatorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ShiftOperatorContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token Greater in current rule
fn Greater_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Greater, starting from 0.
/// Returns `None` if number of children corresponding to token Greater is less or equal than `i`.
fn Greater(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Greater, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Less in current rule
fn Less_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Less, starting from 0.
/// Returns `None` if number of children corresponding to token Less is less or equal than `i`.
fn Less(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Less, i)
}

}

impl<'input> ShiftOperatorContextAttrs<'input> for ShiftOperatorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shiftOperator(&mut self,)
	-> Result<Rc<ShiftOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShiftOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_shiftOperator);
        let mut _localctx: Rc<ShiftOperatorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(749);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Greater 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(745);
					recog.base.match_token(Greater,&mut recog.err_handler)?;

					recog.base.set_state(746);
					recog.base.match_token(Greater,&mut recog.err_handler)?;

					}
				}

			 Less 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(747);
					recog.base.match_token(Less,&mut recog.err_handler)?;

					recog.base.set_state(748);
					recog.base.match_token(Less,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- relationalExpression ----------------
pub type RelationalExpressionContextAll<'input> = RelationalExpressionContext<'input>;


pub type RelationalExpressionContext<'input> = BaseParserRuleContext<'input,RelationalExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct RelationalExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for RelationalExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for RelationalExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_relationalExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_relationalExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RelationalExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relationalExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relationalExpression }
}
antlr_rust::tid!{RelationalExpressionContextExt<'a>}

impl<'input> RelationalExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RelationalExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RelationalExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RelationalExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<RelationalExpressionContextExt<'input>>{

fn shiftExpression_all(&self) ->  Vec<Rc<ShiftExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn shiftExpression(&self, i: usize) -> Option<Rc<ShiftExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Less in current rule
fn Less_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Less, starting from 0.
/// Returns `None` if number of children corresponding to token Less is less or equal than `i`.
fn Less(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Less, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Greater in current rule
fn Greater_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Greater, starting from 0.
/// Returns `None` if number of children corresponding to token Greater is less or equal than `i`.
fn Greater(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Greater, i)
}
/// Retrieves all `TerminalNode`s corresponding to token LessEqual in current rule
fn LessEqual_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LessEqual, starting from 0.
/// Returns `None` if number of children corresponding to token LessEqual is less or equal than `i`.
fn LessEqual(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LessEqual, i)
}
/// Retrieves all `TerminalNode`s corresponding to token GreaterEqual in current rule
fn GreaterEqual_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token GreaterEqual, starting from 0.
/// Returns `None` if number of children corresponding to token GreaterEqual is less or equal than `i`.
fn GreaterEqual(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(GreaterEqual, i)
}

}

impl<'input> RelationalExpressionContextAttrs<'input> for RelationalExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn relationalExpression(&mut self,)
	-> Result<Rc<RelationalExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RelationalExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_relationalExpression);
        let mut _localctx: Rc<RelationalExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule shiftExpression*/
			recog.base.set_state(751);
			recog.shiftExpression()?;

			recog.base.set_state(756);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(63,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(752);
					_la = recog.base.input.la(1);
					if { !(((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (Less - 102)) | (1usize << (Greater - 102)) | (1usize << (LessEqual - 102)) | (1usize << (GreaterEqual - 102)))) != 0)) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule shiftExpression*/
					recog.base.set_state(753);
					recog.shiftExpression()?;

					}
					} 
				}
				recog.base.set_state(758);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(63,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- equalityExpression ----------------
pub type EqualityExpressionContextAll<'input> = EqualityExpressionContext<'input>;


pub type EqualityExpressionContext<'input> = BaseParserRuleContext<'input,EqualityExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct EqualityExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for EqualityExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for EqualityExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_equalityExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_equalityExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EqualityExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_equalityExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_equalityExpression }
}
antlr_rust::tid!{EqualityExpressionContextExt<'a>}

impl<'input> EqualityExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EqualityExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EqualityExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EqualityExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<EqualityExpressionContextExt<'input>>{

fn relationalExpression_all(&self) ->  Vec<Rc<RelationalExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn relationalExpression(&self, i: usize) -> Option<Rc<RelationalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Equal in current rule
fn Equal_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Equal, starting from 0.
/// Returns `None` if number of children corresponding to token Equal is less or equal than `i`.
fn Equal(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Equal, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NotEqual in current rule
fn NotEqual_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NotEqual, starting from 0.
/// Returns `None` if number of children corresponding to token NotEqual is less or equal than `i`.
fn NotEqual(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(NotEqual, i)
}

}

impl<'input> EqualityExpressionContextAttrs<'input> for EqualityExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn equalityExpression(&mut self,)
	-> Result<Rc<EqualityExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EqualityExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_equalityExpression);
        let mut _localctx: Rc<EqualityExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule relationalExpression*/
			recog.base.set_state(759);
			recog.relationalExpression()?;

			recog.base.set_state(764);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Equal || _la==NotEqual {
				{
				{
				recog.base.set_state(760);
				_la = recog.base.input.la(1);
				if { !(_la==Equal || _la==NotEqual) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				/*InvokeRule relationalExpression*/
				recog.base.set_state(761);
				recog.relationalExpression()?;

				}
				}
				recog.base.set_state(766);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- andExpression ----------------
pub type AndExpressionContextAll<'input> = AndExpressionContext<'input>;


pub type AndExpressionContext<'input> = BaseParserRuleContext<'input,AndExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AndExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AndExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AndExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_andExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_andExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AndExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_andExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_andExpression }
}
antlr_rust::tid!{AndExpressionContextExt<'a>}

impl<'input> AndExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AndExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AndExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AndExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AndExpressionContextExt<'input>>{

fn equalityExpression_all(&self) ->  Vec<Rc<EqualityExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn equalityExpression(&self, i: usize) -> Option<Rc<EqualityExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token And in current rule
fn And_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token And, starting from 0.
/// Returns `None` if number of children corresponding to token And is less or equal than `i`.
fn And(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(And, i)
}

}

impl<'input> AndExpressionContextAttrs<'input> for AndExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn andExpression(&mut self,)
	-> Result<Rc<AndExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AndExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_andExpression);
        let mut _localctx: Rc<AndExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule equalityExpression*/
			recog.base.set_state(767);
			recog.equalityExpression()?;

			recog.base.set_state(772);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==And {
				{
				{
				recog.base.set_state(768);
				recog.base.match_token(And,&mut recog.err_handler)?;

				/*InvokeRule equalityExpression*/
				recog.base.set_state(769);
				recog.equalityExpression()?;

				}
				}
				recog.base.set_state(774);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- exclusiveOrExpression ----------------
pub type ExclusiveOrExpressionContextAll<'input> = ExclusiveOrExpressionContext<'input>;


pub type ExclusiveOrExpressionContext<'input> = BaseParserRuleContext<'input,ExclusiveOrExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExclusiveOrExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ExclusiveOrExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ExclusiveOrExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_exclusiveOrExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_exclusiveOrExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExclusiveOrExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exclusiveOrExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exclusiveOrExpression }
}
antlr_rust::tid!{ExclusiveOrExpressionContextExt<'a>}

impl<'input> ExclusiveOrExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExclusiveOrExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExclusiveOrExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExclusiveOrExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ExclusiveOrExpressionContextExt<'input>>{

fn andExpression_all(&self) ->  Vec<Rc<AndExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn andExpression(&self, i: usize) -> Option<Rc<AndExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Caret in current rule
fn Caret_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Caret, starting from 0.
/// Returns `None` if number of children corresponding to token Caret is less or equal than `i`.
fn Caret(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Caret, i)
}

}

impl<'input> ExclusiveOrExpressionContextAttrs<'input> for ExclusiveOrExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn exclusiveOrExpression(&mut self,)
	-> Result<Rc<ExclusiveOrExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExclusiveOrExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_exclusiveOrExpression);
        let mut _localctx: Rc<ExclusiveOrExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule andExpression*/
			recog.base.set_state(775);
			recog.andExpression()?;

			recog.base.set_state(780);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Caret {
				{
				{
				recog.base.set_state(776);
				recog.base.match_token(Caret,&mut recog.err_handler)?;

				/*InvokeRule andExpression*/
				recog.base.set_state(777);
				recog.andExpression()?;

				}
				}
				recog.base.set_state(782);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- inclusiveOrExpression ----------------
pub type InclusiveOrExpressionContextAll<'input> = InclusiveOrExpressionContext<'input>;


pub type InclusiveOrExpressionContext<'input> = BaseParserRuleContext<'input,InclusiveOrExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct InclusiveOrExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for InclusiveOrExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for InclusiveOrExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_inclusiveOrExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_inclusiveOrExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InclusiveOrExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inclusiveOrExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inclusiveOrExpression }
}
antlr_rust::tid!{InclusiveOrExpressionContextExt<'a>}

impl<'input> InclusiveOrExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InclusiveOrExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InclusiveOrExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InclusiveOrExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<InclusiveOrExpressionContextExt<'input>>{

fn exclusiveOrExpression_all(&self) ->  Vec<Rc<ExclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn exclusiveOrExpression(&self, i: usize) -> Option<Rc<ExclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Or in current rule
fn Or_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Or, starting from 0.
/// Returns `None` if number of children corresponding to token Or is less or equal than `i`.
fn Or(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Or, i)
}

}

impl<'input> InclusiveOrExpressionContextAttrs<'input> for InclusiveOrExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn inclusiveOrExpression(&mut self,)
	-> Result<Rc<InclusiveOrExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InclusiveOrExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_inclusiveOrExpression);
        let mut _localctx: Rc<InclusiveOrExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule exclusiveOrExpression*/
			recog.base.set_state(783);
			recog.exclusiveOrExpression()?;

			recog.base.set_state(788);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Or {
				{
				{
				recog.base.set_state(784);
				recog.base.match_token(Or,&mut recog.err_handler)?;

				/*InvokeRule exclusiveOrExpression*/
				recog.base.set_state(785);
				recog.exclusiveOrExpression()?;

				}
				}
				recog.base.set_state(790);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- logicalAndExpression ----------------
pub type LogicalAndExpressionContextAll<'input> = LogicalAndExpressionContext<'input>;


pub type LogicalAndExpressionContext<'input> = BaseParserRuleContext<'input,LogicalAndExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct LogicalAndExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for LogicalAndExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for LogicalAndExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_logicalAndExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_logicalAndExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LogicalAndExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_logicalAndExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_logicalAndExpression }
}
antlr_rust::tid!{LogicalAndExpressionContextExt<'a>}

impl<'input> LogicalAndExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LogicalAndExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LogicalAndExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LogicalAndExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<LogicalAndExpressionContextExt<'input>>{

fn inclusiveOrExpression_all(&self) ->  Vec<Rc<InclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn inclusiveOrExpression(&self, i: usize) -> Option<Rc<InclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token AndAnd in current rule
fn AndAnd_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token AndAnd, starting from 0.
/// Returns `None` if number of children corresponding to token AndAnd is less or equal than `i`.
fn AndAnd(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(AndAnd, i)
}

}

impl<'input> LogicalAndExpressionContextAttrs<'input> for LogicalAndExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn logicalAndExpression(&mut self,)
	-> Result<Rc<LogicalAndExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LogicalAndExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_logicalAndExpression);
        let mut _localctx: Rc<LogicalAndExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule inclusiveOrExpression*/
			recog.base.set_state(791);
			recog.inclusiveOrExpression()?;

			recog.base.set_state(796);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AndAnd {
				{
				{
				recog.base.set_state(792);
				recog.base.match_token(AndAnd,&mut recog.err_handler)?;

				/*InvokeRule inclusiveOrExpression*/
				recog.base.set_state(793);
				recog.inclusiveOrExpression()?;

				}
				}
				recog.base.set_state(798);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- logicalOrExpression ----------------
pub type LogicalOrExpressionContextAll<'input> = LogicalOrExpressionContext<'input>;


pub type LogicalOrExpressionContext<'input> = BaseParserRuleContext<'input,LogicalOrExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct LogicalOrExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for LogicalOrExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for LogicalOrExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_logicalOrExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_logicalOrExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LogicalOrExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_logicalOrExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_logicalOrExpression }
}
antlr_rust::tid!{LogicalOrExpressionContextExt<'a>}

impl<'input> LogicalOrExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LogicalOrExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LogicalOrExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LogicalOrExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<LogicalOrExpressionContextExt<'input>>{

fn logicalAndExpression_all(&self) ->  Vec<Rc<LogicalAndExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn logicalAndExpression(&self, i: usize) -> Option<Rc<LogicalAndExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token OrOr in current rule
fn OrOr_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token OrOr, starting from 0.
/// Returns `None` if number of children corresponding to token OrOr is less or equal than `i`.
fn OrOr(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(OrOr, i)
}

}

impl<'input> LogicalOrExpressionContextAttrs<'input> for LogicalOrExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn logicalOrExpression(&mut self,)
	-> Result<Rc<LogicalOrExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LogicalOrExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_logicalOrExpression);
        let mut _localctx: Rc<LogicalOrExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule logicalAndExpression*/
			recog.base.set_state(799);
			recog.logicalAndExpression()?;

			recog.base.set_state(804);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==OrOr {
				{
				{
				recog.base.set_state(800);
				recog.base.match_token(OrOr,&mut recog.err_handler)?;

				/*InvokeRule logicalAndExpression*/
				recog.base.set_state(801);
				recog.logicalAndExpression()?;

				}
				}
				recog.base.set_state(806);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- conditionalExpression ----------------
pub type ConditionalExpressionContextAll<'input> = ConditionalExpressionContext<'input>;


pub type ConditionalExpressionContext<'input> = BaseParserRuleContext<'input,ConditionalExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ConditionalExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ConditionalExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ConditionalExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_conditionalExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_conditionalExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConditionalExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conditionalExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conditionalExpression }
}
antlr_rust::tid!{ConditionalExpressionContextExt<'a>}

impl<'input> ConditionalExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConditionalExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConditionalExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConditionalExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ConditionalExpressionContextExt<'input>>{

fn logicalOrExpression(&self) -> Option<Rc<LogicalOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Question
/// Returns `None` if there is no child corresponding to token Question
fn Question(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Question, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Colon
/// Returns `None` if there is no child corresponding to token Colon
fn Colon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Colon, 0)
}
fn assignmentExpression(&self) -> Option<Rc<AssignmentExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConditionalExpressionContextAttrs<'input> for ConditionalExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn conditionalExpression(&mut self,)
	-> Result<Rc<ConditionalExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConditionalExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_conditionalExpression);
        let mut _localctx: Rc<ConditionalExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule logicalOrExpression*/
			recog.base.set_state(807);
			recog.logicalOrExpression()?;

			recog.base.set_state(813);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Question {
				{
				recog.base.set_state(808);
				recog.base.match_token(Question,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(809);
				recog.expression()?;

				recog.base.set_state(810);
				recog.base.match_token(Colon,&mut recog.err_handler)?;

				/*InvokeRule assignmentExpression*/
				recog.base.set_state(811);
				recog.assignmentExpression()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentExpression ----------------
pub type AssignmentExpressionContextAll<'input> = AssignmentExpressionContext<'input>;


pub type AssignmentExpressionContext<'input> = BaseParserRuleContext<'input,AssignmentExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AssignmentExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AssignmentExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignmentExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_assignmentExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AssignmentExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentExpression }
}
antlr_rust::tid!{AssignmentExpressionContextExt<'a>}

impl<'input> AssignmentExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AssignmentExpressionContextExt<'input>>{

fn conditionalExpression(&self) -> Option<Rc<ConditionalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn logicalOrExpression(&self) -> Option<Rc<LogicalOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentOperator(&self) -> Option<Rc<AssignmentOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn initializerClause(&self) -> Option<Rc<InitializerClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn throwExpression(&self) -> Option<Rc<ThrowExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AssignmentExpressionContextAttrs<'input> for AssignmentExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentExpression(&mut self,)
	-> Result<Rc<AssignmentExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_assignmentExpression);
        let mut _localctx: Rc<AssignmentExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(821);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(71,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule conditionalExpression*/
					recog.base.set_state(815);
					recog.conditionalExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule logicalOrExpression*/
					recog.base.set_state(816);
					recog.logicalOrExpression()?;

					/*InvokeRule assignmentOperator*/
					recog.base.set_state(817);
					recog.assignmentOperator()?;

					/*InvokeRule initializerClause*/
					recog.base.set_state(818);
					recog.initializerClause()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule throwExpression*/
					recog.base.set_state(820);
					recog.throwExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentOperator ----------------
pub type AssignmentOperatorContextAll<'input> = AssignmentOperatorContext<'input>;


pub type AssignmentOperatorContext<'input> = BaseParserRuleContext<'input,AssignmentOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AssignmentOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AssignmentOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignmentOperator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_assignmentOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AssignmentOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentOperator }
}
antlr_rust::tid!{AssignmentOperatorContextExt<'a>}

impl<'input> AssignmentOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentOperatorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AssignmentOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}
/// Retrieves first TerminalNode corresponding to token StarAssign
/// Returns `None` if there is no child corresponding to token StarAssign
fn StarAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(StarAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token DivAssign
/// Returns `None` if there is no child corresponding to token DivAssign
fn DivAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(DivAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token ModAssign
/// Returns `None` if there is no child corresponding to token ModAssign
fn ModAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(ModAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token PlusAssign
/// Returns `None` if there is no child corresponding to token PlusAssign
fn PlusAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(PlusAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token MinusAssign
/// Returns `None` if there is no child corresponding to token MinusAssign
fn MinusAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(MinusAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token RightShiftAssign
/// Returns `None` if there is no child corresponding to token RightShiftAssign
fn RightShiftAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightShiftAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftShiftAssign
/// Returns `None` if there is no child corresponding to token LeftShiftAssign
fn LeftShiftAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftShiftAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token AndAssign
/// Returns `None` if there is no child corresponding to token AndAssign
fn AndAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(AndAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token XorAssign
/// Returns `None` if there is no child corresponding to token XorAssign
fn XorAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(XorAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token OrAssign
/// Returns `None` if there is no child corresponding to token OrAssign
fn OrAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(OrAssign, 0)
}

}

impl<'input> AssignmentOperatorContextAttrs<'input> for AssignmentOperatorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentOperator(&mut self,)
	-> Result<Rc<AssignmentOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_assignmentOperator);
        let mut _localctx: Rc<AssignmentOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(823);
			_la = recog.base.input.la(1);
			if { !(((((_la - 101)) & !0x3f) == 0 && ((1usize << (_la - 101)) & ((1usize << (Assign - 101)) | (1usize << (PlusAssign - 101)) | (1usize << (MinusAssign - 101)) | (1usize << (StarAssign - 101)) | (1usize << (DivAssign - 101)) | (1usize << (ModAssign - 101)) | (1usize << (XorAssign - 101)) | (1usize << (AndAssign - 101)) | (1usize << (OrAssign - 101)) | (1usize << (LeftShiftAssign - 101)) | (1usize << (RightShiftAssign - 101)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expression ----------------
pub type ExpressionContextAll<'input> = ExpressionContext<'input>;


pub type ExpressionContext<'input> = BaseParserRuleContext<'input,ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_expression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_expression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::tid!{ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ExpressionContextExt<'input>>{

fn assignmentExpression_all(&self) ->  Vec<Rc<AssignmentExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn assignmentExpression(&self, i: usize) -> Option<Rc<AssignmentExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}

}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expression(&mut self,)
	-> Result<Rc<ExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_expression);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule assignmentExpression*/
			recog.base.set_state(825);
			recog.assignmentExpression()?;

			recog.base.set_state(830);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Comma {
				{
				{
				recog.base.set_state(826);
				recog.base.match_token(Comma,&mut recog.err_handler)?;

				/*InvokeRule assignmentExpression*/
				recog.base.set_state(827);
				recog.assignmentExpression()?;

				}
				}
				recog.base.set_state(832);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constantExpression ----------------
pub type ConstantExpressionContextAll<'input> = ConstantExpressionContext<'input>;


pub type ConstantExpressionContext<'input> = BaseParserRuleContext<'input,ConstantExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ConstantExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ConstantExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ConstantExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constantExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_constantExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstantExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constantExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constantExpression }
}
antlr_rust::tid!{ConstantExpressionContextExt<'a>}

impl<'input> ConstantExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstantExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstantExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstantExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ConstantExpressionContextExt<'input>>{

fn conditionalExpression(&self) -> Option<Rc<ConditionalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstantExpressionContextAttrs<'input> for ConstantExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constantExpression(&mut self,)
	-> Result<Rc<ConstantExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstantExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_constantExpression);
        let mut _localctx: Rc<ConstantExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule conditionalExpression*/
			recog.base.set_state(833);
			recog.conditionalExpression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statement ----------------
pub type StatementContextAll<'input> = StatementContext<'input>;


pub type StatementContext<'input> = BaseParserRuleContext<'input,StatementContextExt<'input>>;

#[derive(Clone)]
pub struct StatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for StatementContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for StatementContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statement(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_statement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}
antlr_rust::tid!{StatementContextExt<'a>}

impl<'input> StatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<StatementContextExt<'input>>{

fn labeledStatement(&self) -> Option<Rc<LabeledStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn declarationStatement(&self) -> Option<Rc<DeclarationStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionStatement(&self) -> Option<Rc<ExpressionStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn compoundStatement(&self) -> Option<Rc<CompoundStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn selectionStatement(&self) -> Option<Rc<SelectionStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn iterationStatement(&self) -> Option<Rc<IterationStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn jumpStatement(&self) -> Option<Rc<JumpStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tryBlock(&self) -> Option<Rc<TryBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StatementContextAttrs<'input> for StatementContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statement(&mut self,)
	-> Result<Rc<StatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_statement);
        let mut _localctx: Rc<StatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(848);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(75,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule labeledStatement*/
					recog.base.set_state(835);
					recog.labeledStatement()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule declarationStatement*/
					recog.base.set_state(836);
					recog.declarationStatement()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(838);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(73,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule attributeSpecifierSeq*/
							recog.base.set_state(837);
							recog.attributeSpecifierSeq()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(846);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 IntegerLiteral | CharacterLiteral | FloatingLiteral | StringLiteral |
					 BooleanLiteral | PointerLiteral | UserDefinedLiteral | Alignof | Auto |
					 Bool | Char | Char16 | Char32 | Const_cast | Decltype | Delete | Double |
					 Dynamic_cast | Float | Int | Long | New | Noexcept | Operator | Reinterpret_cast |
					 Short | Signed | Sizeof | Static_cast | This | Throw | Typeid_ | Typename_ |
					 Unsigned | Void | Wchar | LeftParen | LeftBracket | Plus | Minus |
					 Star | And | Or | Tilde | Not | PlusPlus | MinusMinus | Doublecolon |
					 Semi | Identifier 
						=> {
							{
							/*InvokeRule expressionStatement*/
							recog.base.set_state(840);
							recog.expressionStatement()?;

							}
						}

					 LeftBrace 
						=> {
							{
							/*InvokeRule compoundStatement*/
							recog.base.set_state(841);
							recog.compoundStatement()?;

							}
						}

					 If | Switch 
						=> {
							{
							/*InvokeRule selectionStatement*/
							recog.base.set_state(842);
							recog.selectionStatement()?;

							}
						}

					 Do | For | While 
						=> {
							{
							/*InvokeRule iterationStatement*/
							recog.base.set_state(843);
							recog.iterationStatement()?;

							}
						}

					 Break | Continue | Goto | Return 
						=> {
							{
							/*InvokeRule jumpStatement*/
							recog.base.set_state(844);
							recog.jumpStatement()?;

							}
						}

					 Try 
						=> {
							{
							/*InvokeRule tryBlock*/
							recog.base.set_state(845);
							recog.tryBlock()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- labeledStatement ----------------
pub type LabeledStatementContextAll<'input> = LabeledStatementContext<'input>;


pub type LabeledStatementContext<'input> = BaseParserRuleContext<'input,LabeledStatementContextExt<'input>>;

#[derive(Clone)]
pub struct LabeledStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for LabeledStatementContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for LabeledStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_labeledStatement(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_labeledStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LabeledStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_labeledStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_labeledStatement }
}
antlr_rust::tid!{LabeledStatementContextExt<'a>}

impl<'input> LabeledStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LabeledStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LabeledStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LabeledStatementContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<LabeledStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Colon
/// Returns `None` if there is no child corresponding to token Colon
fn Colon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Colon, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token Case
/// Returns `None` if there is no child corresponding to token Case
fn Case(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Case, 0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Default
/// Returns `None` if there is no child corresponding to token Default
fn Default(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Default, 0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LabeledStatementContextAttrs<'input> for LabeledStatementContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn labeledStatement(&mut self,)
	-> Result<Rc<LabeledStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LabeledStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_labeledStatement);
        let mut _localctx: Rc<LabeledStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(851);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Alignas || _la==LeftBracket {
				{
				/*InvokeRule attributeSpecifierSeq*/
				recog.base.set_state(850);
				recog.attributeSpecifierSeq()?;

				}
			}

			recog.base.set_state(857);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Identifier 
				=> {
					{
					recog.base.set_state(853);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}

			 Case 
				=> {
					{
					recog.base.set_state(854);
					recog.base.match_token(Case,&mut recog.err_handler)?;

					/*InvokeRule constantExpression*/
					recog.base.set_state(855);
					recog.constantExpression()?;

					}
				}

			 Default 
				=> {
					{
					recog.base.set_state(856);
					recog.base.match_token(Default,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(859);
			recog.base.match_token(Colon,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(860);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expressionStatement ----------------
pub type ExpressionStatementContextAll<'input> = ExpressionStatementContext<'input>;


pub type ExpressionStatementContext<'input> = BaseParserRuleContext<'input,ExpressionStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ExpressionStatementContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ExpressionStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_expressionStatement(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_expressionStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExpressionStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expressionStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expressionStatement }
}
antlr_rust::tid!{ExpressionStatementContextExt<'a>}

impl<'input> ExpressionStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionStatementContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ExpressionStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExpressionStatementContextAttrs<'input> for ExpressionStatementContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expressionStatement(&mut self,)
	-> Result<Rc<ExpressionStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_expressionStatement);
        let mut _localctx: Rc<ExpressionStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(863);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 71)) & !0x3f) == 0 && ((1usize << (_la - 71)) & ((1usize << (Throw - 71)) | (1usize << (Typeid_ - 71)) | (1usize << (Typename_ - 71)) | (1usize << (Unsigned - 71)) | (1usize << (Void - 71)) | (1usize << (Wchar - 71)) | (1usize << (LeftParen - 71)) | (1usize << (LeftBracket - 71)) | (1usize << (Plus - 71)) | (1usize << (Minus - 71)) | (1usize << (Star - 71)) | (1usize << (And - 71)) | (1usize << (Or - 71)) | (1usize << (Tilde - 71)) | (1usize << (Not - 71)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
				{
				/*InvokeRule expression*/
				recog.base.set_state(862);
				recog.expression()?;

				}
			}

			recog.base.set_state(865);
			recog.base.match_token(Semi,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- compoundStatement ----------------
pub type CompoundStatementContextAll<'input> = CompoundStatementContext<'input>;


pub type CompoundStatementContext<'input> = BaseParserRuleContext<'input,CompoundStatementContextExt<'input>>;

#[derive(Clone)]
pub struct CompoundStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for CompoundStatementContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for CompoundStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_compoundStatement(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_compoundStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CompoundStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_compoundStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_compoundStatement }
}
antlr_rust::tid!{CompoundStatementContextExt<'a>}

impl<'input> CompoundStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CompoundStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CompoundStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CompoundStatementContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<CompoundStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LeftBrace
/// Returns `None` if there is no child corresponding to token LeftBrace
fn LeftBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBrace, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBrace
/// Returns `None` if there is no child corresponding to token RightBrace
fn RightBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBrace, 0)
}
fn statementSeq(&self) -> Option<Rc<StatementSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CompoundStatementContextAttrs<'input> for CompoundStatementContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn compoundStatement(&mut self,)
	-> Result<Rc<CompoundStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CompoundStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_compoundStatement);
        let mut _localctx: Rc<CompoundStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(867);
			recog.base.match_token(LeftBrace,&mut recog.err_handler)?;

			recog.base.set_state(869);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignas) | (1usize << Alignof) | (1usize << Asm) | (1usize << Auto) | (1usize << Bool) | (1usize << Break) | (1usize << Case) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Class) | (1usize << Const) | (1usize << Constexpr) | (1usize << Const_cast) | (1usize << Continue) | (1usize << Decltype) | (1usize << Default) | (1usize << Delete) | (1usize << Do) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (Enum - 33)) | (1usize << (Explicit - 33)) | (1usize << (Extern - 33)) | (1usize << (Float - 33)) | (1usize << (For - 33)) | (1usize << (Friend - 33)) | (1usize << (Goto - 33)) | (1usize << (If - 33)) | (1usize << (Inline - 33)) | (1usize << (Int - 33)) | (1usize << (Long - 33)) | (1usize << (Mutable - 33)) | (1usize << (Namespace - 33)) | (1usize << (New - 33)) | (1usize << (Noexcept - 33)) | (1usize << (Operator - 33)) | (1usize << (Register - 33)) | (1usize << (Reinterpret_cast - 33)) | (1usize << (Return - 33)) | (1usize << (Short - 33)) | (1usize << (Signed - 33)) | (1usize << (Sizeof - 33)) | (1usize << (Static - 33)) | (1usize << (Static_assert - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (Static_cast - 65)) | (1usize << (Struct - 65)) | (1usize << (Switch - 65)) | (1usize << (This - 65)) | (1usize << (Thread_local - 65)) | (1usize << (Throw - 65)) | (1usize << (Try - 65)) | (1usize << (Typedef - 65)) | (1usize << (Typeid_ - 65)) | (1usize << (Typename_ - 65)) | (1usize << (Union - 65)) | (1usize << (Unsigned - 65)) | (1usize << (Using - 65)) | (1usize << (Virtual - 65)) | (1usize << (Void - 65)) | (1usize << (Volatile - 65)) | (1usize << (Wchar - 65)) | (1usize << (While - 65)) | (1usize << (LeftParen - 65)) | (1usize << (LeftBracket - 65)) | (1usize << (LeftBrace - 65)) | (1usize << (Plus - 65)) | (1usize << (Minus - 65)) | (1usize << (Star - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (And - 97)) | (1usize << (Or - 97)) | (1usize << (Tilde - 97)) | (1usize << (Not - 97)) | (1usize << (AndAnd - 97)) | (1usize << (PlusPlus - 97)) | (1usize << (MinusMinus - 97)) | (1usize << (Doublecolon - 97)) | (1usize << (Semi - 97)))) != 0) || _la==Ellipsis || _la==Identifier {
				{
				/*InvokeRule statementSeq*/
				recog.base.set_state(868);
				recog.statementSeq()?;

				}
			}

			recog.base.set_state(871);
			recog.base.match_token(RightBrace,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statementSeq ----------------
pub type StatementSeqContextAll<'input> = StatementSeqContext<'input>;


pub type StatementSeqContext<'input> = BaseParserRuleContext<'input,StatementSeqContextExt<'input>>;

#[derive(Clone)]
pub struct StatementSeqContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for StatementSeqContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for StatementSeqContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statementSeq(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_statementSeq(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StatementSeqContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statementSeq }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statementSeq }
}
antlr_rust::tid!{StatementSeqContextExt<'a>}

impl<'input> StatementSeqContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementSeqContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementSeqContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementSeqContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<StatementSeqContextExt<'input>>{

fn statement_all(&self) ->  Vec<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statement(&self, i: usize) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> StatementSeqContextAttrs<'input> for StatementSeqContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statementSeq(&mut self,)
	-> Result<Rc<StatementSeqContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementSeqContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_statementSeq);
        let mut _localctx: Rc<StatementSeqContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(874); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule statement*/
				recog.base.set_state(873);
				recog.statement()?;

				}
				}
				recog.base.set_state(876); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignas) | (1usize << Alignof) | (1usize << Asm) | (1usize << Auto) | (1usize << Bool) | (1usize << Break) | (1usize << Case) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Class) | (1usize << Const) | (1usize << Constexpr) | (1usize << Const_cast) | (1usize << Continue) | (1usize << Decltype) | (1usize << Default) | (1usize << Delete) | (1usize << Do) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (Enum - 33)) | (1usize << (Explicit - 33)) | (1usize << (Extern - 33)) | (1usize << (Float - 33)) | (1usize << (For - 33)) | (1usize << (Friend - 33)) | (1usize << (Goto - 33)) | (1usize << (If - 33)) | (1usize << (Inline - 33)) | (1usize << (Int - 33)) | (1usize << (Long - 33)) | (1usize << (Mutable - 33)) | (1usize << (Namespace - 33)) | (1usize << (New - 33)) | (1usize << (Noexcept - 33)) | (1usize << (Operator - 33)) | (1usize << (Register - 33)) | (1usize << (Reinterpret_cast - 33)) | (1usize << (Return - 33)) | (1usize << (Short - 33)) | (1usize << (Signed - 33)) | (1usize << (Sizeof - 33)) | (1usize << (Static - 33)) | (1usize << (Static_assert - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (Static_cast - 65)) | (1usize << (Struct - 65)) | (1usize << (Switch - 65)) | (1usize << (This - 65)) | (1usize << (Thread_local - 65)) | (1usize << (Throw - 65)) | (1usize << (Try - 65)) | (1usize << (Typedef - 65)) | (1usize << (Typeid_ - 65)) | (1usize << (Typename_ - 65)) | (1usize << (Union - 65)) | (1usize << (Unsigned - 65)) | (1usize << (Using - 65)) | (1usize << (Virtual - 65)) | (1usize << (Void - 65)) | (1usize << (Volatile - 65)) | (1usize << (Wchar - 65)) | (1usize << (While - 65)) | (1usize << (LeftParen - 65)) | (1usize << (LeftBracket - 65)) | (1usize << (LeftBrace - 65)) | (1usize << (Plus - 65)) | (1usize << (Minus - 65)) | (1usize << (Star - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (And - 97)) | (1usize << (Or - 97)) | (1usize << (Tilde - 97)) | (1usize << (Not - 97)) | (1usize << (AndAnd - 97)) | (1usize << (PlusPlus - 97)) | (1usize << (MinusMinus - 97)) | (1usize << (Doublecolon - 97)) | (1usize << (Semi - 97)))) != 0) || _la==Ellipsis || _la==Identifier) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- selectionStatement ----------------
pub type SelectionStatementContextAll<'input> = SelectionStatementContext<'input>;


pub type SelectionStatementContext<'input> = BaseParserRuleContext<'input,SelectionStatementContextExt<'input>>;

#[derive(Clone)]
pub struct SelectionStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for SelectionStatementContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for SelectionStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_selectionStatement(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_selectionStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SelectionStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_selectionStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_selectionStatement }
}
antlr_rust::tid!{SelectionStatementContextExt<'a>}

impl<'input> SelectionStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SelectionStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SelectionStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SelectionStatementContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<SelectionStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token If
/// Returns `None` if there is no child corresponding to token If
fn If(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(If, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn condition(&self) -> Option<Rc<ConditionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn statement_all(&self) ->  Vec<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statement(&self, i: usize) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token Else
/// Returns `None` if there is no child corresponding to token Else
fn Else(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Else, 0)
}
/// Retrieves first TerminalNode corresponding to token Switch
/// Returns `None` if there is no child corresponding to token Switch
fn Switch(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Switch, 0)
}

}

impl<'input> SelectionStatementContextAttrs<'input> for SelectionStatementContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn selectionStatement(&mut self,)
	-> Result<Rc<SelectionStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SelectionStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_selectionStatement);
        let mut _localctx: Rc<SelectionStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(893);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 If 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(878);
					recog.base.match_token(If,&mut recog.err_handler)?;

					recog.base.set_state(879);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule condition*/
					recog.base.set_state(880);
					recog.condition()?;

					recog.base.set_state(881);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					/*InvokeRule statement*/
					recog.base.set_state(882);
					recog.statement()?;

					recog.base.set_state(885);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(81,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(883);
							recog.base.match_token(Else,&mut recog.err_handler)?;

							/*InvokeRule statement*/
							recog.base.set_state(884);
							recog.statement()?;

							}
						}

						_ => {}
					}
					}
				}

			 Switch 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(887);
					recog.base.match_token(Switch,&mut recog.err_handler)?;

					recog.base.set_state(888);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule condition*/
					recog.base.set_state(889);
					recog.condition()?;

					recog.base.set_state(890);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					/*InvokeRule statement*/
					recog.base.set_state(891);
					recog.statement()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- condition ----------------
pub type ConditionContextAll<'input> = ConditionContext<'input>;


pub type ConditionContext<'input> = BaseParserRuleContext<'input,ConditionContextExt<'input>>;

#[derive(Clone)]
pub struct ConditionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ConditionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ConditionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_condition(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_condition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConditionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_condition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_condition }
}
antlr_rust::tid!{ConditionContextExt<'a>}

impl<'input> ConditionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConditionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConditionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConditionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ConditionContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn declSpecifierSeq(&self) -> Option<Rc<DeclSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn declarator(&self) -> Option<Rc<DeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}
fn initializerClause(&self) -> Option<Rc<InitializerClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn bracedInitList(&self) -> Option<Rc<BracedInitListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConditionContextAttrs<'input> for ConditionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn condition(&mut self,)
	-> Result<Rc<ConditionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConditionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_condition);
        let mut _localctx: Rc<ConditionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(906);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(85,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expression*/
					recog.base.set_state(895);
					recog.expression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(897);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Alignas || _la==LeftBracket {
						{
						/*InvokeRule attributeSpecifierSeq*/
						recog.base.set_state(896);
						recog.attributeSpecifierSeq()?;

						}
					}

					/*InvokeRule declSpecifierSeq*/
					recog.base.set_state(899);
					recog.declSpecifierSeq()?;

					/*InvokeRule declarator*/
					recog.base.set_state(900);
					recog.declarator()?;

					recog.base.set_state(904);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 Assign 
						=> {
							{
							recog.base.set_state(901);
							recog.base.match_token(Assign,&mut recog.err_handler)?;

							/*InvokeRule initializerClause*/
							recog.base.set_state(902);
							recog.initializerClause()?;

							}
						}

					 LeftBrace 
						=> {
							{
							/*InvokeRule bracedInitList*/
							recog.base.set_state(903);
							recog.bracedInitList()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- iterationStatement ----------------
pub type IterationStatementContextAll<'input> = IterationStatementContext<'input>;


pub type IterationStatementContext<'input> = BaseParserRuleContext<'input,IterationStatementContextExt<'input>>;

#[derive(Clone)]
pub struct IterationStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for IterationStatementContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for IterationStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_iterationStatement(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_iterationStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IterationStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_iterationStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_iterationStatement }
}
antlr_rust::tid!{IterationStatementContextExt<'a>}

impl<'input> IterationStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IterationStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IterationStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IterationStatementContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<IterationStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token While
/// Returns `None` if there is no child corresponding to token While
fn While(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(While, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn condition(&self) -> Option<Rc<ConditionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Do
/// Returns `None` if there is no child corresponding to token Do
fn Do(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Do, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}
/// Retrieves first TerminalNode corresponding to token For
/// Returns `None` if there is no child corresponding to token For
fn For(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(For, 0)
}
fn forInitStatement(&self) -> Option<Rc<ForInitStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forRangeDeclaration(&self) -> Option<Rc<ForRangeDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Colon
/// Returns `None` if there is no child corresponding to token Colon
fn Colon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Colon, 0)
}
fn forRangeInitializer(&self) -> Option<Rc<ForRangeInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IterationStatementContextAttrs<'input> for IterationStatementContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn iterationStatement(&mut self,)
	-> Result<Rc<IterationStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IterationStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_iterationStatement);
        let mut _localctx: Rc<IterationStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(941);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 While 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(908);
					recog.base.match_token(While,&mut recog.err_handler)?;

					recog.base.set_state(909);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule condition*/
					recog.base.set_state(910);
					recog.condition()?;

					recog.base.set_state(911);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					/*InvokeRule statement*/
					recog.base.set_state(912);
					recog.statement()?;

					}
				}

			 Do 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(914);
					recog.base.match_token(Do,&mut recog.err_handler)?;

					/*InvokeRule statement*/
					recog.base.set_state(915);
					recog.statement()?;

					recog.base.set_state(916);
					recog.base.match_token(While,&mut recog.err_handler)?;

					recog.base.set_state(917);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(918);
					recog.expression()?;

					recog.base.set_state(919);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					recog.base.set_state(920);
					recog.base.match_token(Semi,&mut recog.err_handler)?;

					}
				}

			 For 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(922);
					recog.base.match_token(For,&mut recog.err_handler)?;

					recog.base.set_state(923);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					recog.base.set_state(936);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(88,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule forInitStatement*/
							recog.base.set_state(924);
							recog.forInitStatement()?;

							recog.base.set_state(926);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignas) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Class) | (1usize << Const) | (1usize << Constexpr) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (Enum - 33)) | (1usize << (Explicit - 33)) | (1usize << (Extern - 33)) | (1usize << (Float - 33)) | (1usize << (Friend - 33)) | (1usize << (Inline - 33)) | (1usize << (Int - 33)) | (1usize << (Long - 33)) | (1usize << (Mutable - 33)) | (1usize << (New - 33)) | (1usize << (Noexcept - 33)) | (1usize << (Operator - 33)) | (1usize << (Register - 33)) | (1usize << (Reinterpret_cast - 33)) | (1usize << (Short - 33)) | (1usize << (Signed - 33)) | (1usize << (Sizeof - 33)) | (1usize << (Static - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (Static_cast - 65)) | (1usize << (Struct - 65)) | (1usize << (This - 65)) | (1usize << (Thread_local - 65)) | (1usize << (Throw - 65)) | (1usize << (Typedef - 65)) | (1usize << (Typeid_ - 65)) | (1usize << (Typename_ - 65)) | (1usize << (Union - 65)) | (1usize << (Unsigned - 65)) | (1usize << (Virtual - 65)) | (1usize << (Void - 65)) | (1usize << (Volatile - 65)) | (1usize << (Wchar - 65)) | (1usize << (LeftParen - 65)) | (1usize << (LeftBracket - 65)) | (1usize << (Plus - 65)) | (1usize << (Minus - 65)) | (1usize << (Star - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (And - 97)) | (1usize << (Or - 97)) | (1usize << (Tilde - 97)) | (1usize << (Not - 97)) | (1usize << (PlusPlus - 97)) | (1usize << (MinusMinus - 97)) | (1usize << (Doublecolon - 97)))) != 0) || _la==Identifier {
								{
								/*InvokeRule condition*/
								recog.base.set_state(925);
								recog.condition()?;

								}
							}

							recog.base.set_state(928);
							recog.base.match_token(Semi,&mut recog.err_handler)?;

							recog.base.set_state(930);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 71)) & !0x3f) == 0 && ((1usize << (_la - 71)) & ((1usize << (Throw - 71)) | (1usize << (Typeid_ - 71)) | (1usize << (Typename_ - 71)) | (1usize << (Unsigned - 71)) | (1usize << (Void - 71)) | (1usize << (Wchar - 71)) | (1usize << (LeftParen - 71)) | (1usize << (LeftBracket - 71)) | (1usize << (Plus - 71)) | (1usize << (Minus - 71)) | (1usize << (Star - 71)) | (1usize << (And - 71)) | (1usize << (Or - 71)) | (1usize << (Tilde - 71)) | (1usize << (Not - 71)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
								{
								/*InvokeRule expression*/
								recog.base.set_state(929);
								recog.expression()?;

								}
							}

							}
						}
					,
						2 =>{
							{
							/*InvokeRule forRangeDeclaration*/
							recog.base.set_state(932);
							recog.forRangeDeclaration()?;

							recog.base.set_state(933);
							recog.base.match_token(Colon,&mut recog.err_handler)?;

							/*InvokeRule forRangeInitializer*/
							recog.base.set_state(934);
							recog.forRangeInitializer()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(938);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					/*InvokeRule statement*/
					recog.base.set_state(939);
					recog.statement()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forInitStatement ----------------
pub type ForInitStatementContextAll<'input> = ForInitStatementContext<'input>;


pub type ForInitStatementContext<'input> = BaseParserRuleContext<'input,ForInitStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ForInitStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ForInitStatementContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ForInitStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forInitStatement(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_forInitStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ForInitStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forInitStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forInitStatement }
}
antlr_rust::tid!{ForInitStatementContextExt<'a>}

impl<'input> ForInitStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForInitStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForInitStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForInitStatementContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ForInitStatementContextExt<'input>>{

fn expressionStatement(&self) -> Option<Rc<ExpressionStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn simpleDeclaration(&self) -> Option<Rc<SimpleDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForInitStatementContextAttrs<'input> for ForInitStatementContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forInitStatement(&mut self,)
	-> Result<Rc<ForInitStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForInitStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_forInitStatement);
        let mut _localctx: Rc<ForInitStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(945);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(90,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expressionStatement*/
					recog.base.set_state(943);
					recog.expressionStatement()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule simpleDeclaration*/
					recog.base.set_state(944);
					recog.simpleDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forRangeDeclaration ----------------
pub type ForRangeDeclarationContextAll<'input> = ForRangeDeclarationContext<'input>;


pub type ForRangeDeclarationContext<'input> = BaseParserRuleContext<'input,ForRangeDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ForRangeDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ForRangeDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ForRangeDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forRangeDeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_forRangeDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ForRangeDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forRangeDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forRangeDeclaration }
}
antlr_rust::tid!{ForRangeDeclarationContextExt<'a>}

impl<'input> ForRangeDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForRangeDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForRangeDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForRangeDeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ForRangeDeclarationContextExt<'input>>{

fn declSpecifierSeq(&self) -> Option<Rc<DeclSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn declarator(&self) -> Option<Rc<DeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForRangeDeclarationContextAttrs<'input> for ForRangeDeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forRangeDeclaration(&mut self,)
	-> Result<Rc<ForRangeDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForRangeDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 112, RULE_forRangeDeclaration);
        let mut _localctx: Rc<ForRangeDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(948);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Alignas || _la==LeftBracket {
				{
				/*InvokeRule attributeSpecifierSeq*/
				recog.base.set_state(947);
				recog.attributeSpecifierSeq()?;

				}
			}

			/*InvokeRule declSpecifierSeq*/
			recog.base.set_state(950);
			recog.declSpecifierSeq()?;

			/*InvokeRule declarator*/
			recog.base.set_state(951);
			recog.declarator()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forRangeInitializer ----------------
pub type ForRangeInitializerContextAll<'input> = ForRangeInitializerContext<'input>;


pub type ForRangeInitializerContext<'input> = BaseParserRuleContext<'input,ForRangeInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct ForRangeInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ForRangeInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ForRangeInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forRangeInitializer(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_forRangeInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ForRangeInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forRangeInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forRangeInitializer }
}
antlr_rust::tid!{ForRangeInitializerContextExt<'a>}

impl<'input> ForRangeInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForRangeInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForRangeInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForRangeInitializerContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ForRangeInitializerContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn bracedInitList(&self) -> Option<Rc<BracedInitListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForRangeInitializerContextAttrs<'input> for ForRangeInitializerContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forRangeInitializer(&mut self,)
	-> Result<Rc<ForRangeInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForRangeInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 114, RULE_forRangeInitializer);
        let mut _localctx: Rc<ForRangeInitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(955);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 IntegerLiteral | CharacterLiteral | FloatingLiteral | StringLiteral |
			 BooleanLiteral | PointerLiteral | UserDefinedLiteral | Alignof | Auto |
			 Bool | Char | Char16 | Char32 | Const_cast | Decltype | Delete | Double |
			 Dynamic_cast | Float | Int | Long | New | Noexcept | Operator | Reinterpret_cast |
			 Short | Signed | Sizeof | Static_cast | This | Throw | Typeid_ | Typename_ |
			 Unsigned | Void | Wchar | LeftParen | LeftBracket | Plus | Minus | Star |
			 And | Or | Tilde | Not | PlusPlus | MinusMinus | Doublecolon | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expression*/
					recog.base.set_state(953);
					recog.expression()?;

					}
				}

			 LeftBrace 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule bracedInitList*/
					recog.base.set_state(954);
					recog.bracedInitList()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- jumpStatement ----------------
pub type JumpStatementContextAll<'input> = JumpStatementContext<'input>;


pub type JumpStatementContext<'input> = BaseParserRuleContext<'input,JumpStatementContextExt<'input>>;

#[derive(Clone)]
pub struct JumpStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for JumpStatementContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for JumpStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_jumpStatement(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_jumpStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for JumpStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_jumpStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_jumpStatement }
}
antlr_rust::tid!{JumpStatementContextExt<'a>}

impl<'input> JumpStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<JumpStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,JumpStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait JumpStatementContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<JumpStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}
/// Retrieves first TerminalNode corresponding to token Break
/// Returns `None` if there is no child corresponding to token Break
fn Break(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Break, 0)
}
/// Retrieves first TerminalNode corresponding to token Continue
/// Returns `None` if there is no child corresponding to token Continue
fn Continue(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Continue, 0)
}
/// Retrieves first TerminalNode corresponding to token Return
/// Returns `None` if there is no child corresponding to token Return
fn Return(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Return, 0)
}
/// Retrieves first TerminalNode corresponding to token Goto
/// Returns `None` if there is no child corresponding to token Goto
fn Goto(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Goto, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn bracedInitList(&self) -> Option<Rc<BracedInitListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> JumpStatementContextAttrs<'input> for JumpStatementContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn jumpStatement(&mut self,)
	-> Result<Rc<JumpStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = JumpStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 116, RULE_jumpStatement);
        let mut _localctx: Rc<JumpStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(966);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Break 
				=> {
					{
					recog.base.set_state(957);
					recog.base.match_token(Break,&mut recog.err_handler)?;

					}
				}

			 Continue 
				=> {
					{
					recog.base.set_state(958);
					recog.base.match_token(Continue,&mut recog.err_handler)?;

					}
				}

			 Return 
				=> {
					{
					recog.base.set_state(959);
					recog.base.match_token(Return,&mut recog.err_handler)?;

					recog.base.set_state(962);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 IntegerLiteral | CharacterLiteral | FloatingLiteral | StringLiteral |
					 BooleanLiteral | PointerLiteral | UserDefinedLiteral | Alignof | Auto |
					 Bool | Char | Char16 | Char32 | Const_cast | Decltype | Delete | Double |
					 Dynamic_cast | Float | Int | Long | New | Noexcept | Operator | Reinterpret_cast |
					 Short | Signed | Sizeof | Static_cast | This | Throw | Typeid_ | Typename_ |
					 Unsigned | Void | Wchar | LeftParen | LeftBracket | Plus | Minus |
					 Star | And | Or | Tilde | Not | PlusPlus | MinusMinus | Doublecolon |
					 Identifier 
						=> {
					    	{
					    	/*InvokeRule expression*/
					    	recog.base.set_state(960);
					    	recog.expression()?;

					    	}
					    }

					 LeftBrace 
						=> {
					    	{
					    	/*InvokeRule bracedInitList*/
					    	recog.base.set_state(961);
					    	recog.bracedInitList()?;

					    	}
					    }

					 Semi 
						=> {
					    }

						_ => {}
					}
					}
				}

			 Goto 
				=> {
					{
					recog.base.set_state(964);
					recog.base.match_token(Goto,&mut recog.err_handler)?;

					recog.base.set_state(965);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(968);
			recog.base.match_token(Semi,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- declarationStatement ----------------
pub type DeclarationStatementContextAll<'input> = DeclarationStatementContext<'input>;


pub type DeclarationStatementContext<'input> = BaseParserRuleContext<'input,DeclarationStatementContextExt<'input>>;

#[derive(Clone)]
pub struct DeclarationStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for DeclarationStatementContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for DeclarationStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_declarationStatement(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_declarationStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DeclarationStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_declarationStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_declarationStatement }
}
antlr_rust::tid!{DeclarationStatementContextExt<'a>}

impl<'input> DeclarationStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeclarationStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeclarationStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeclarationStatementContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<DeclarationStatementContextExt<'input>>{

fn blockDeclaration(&self) -> Option<Rc<BlockDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DeclarationStatementContextAttrs<'input> for DeclarationStatementContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn declarationStatement(&mut self,)
	-> Result<Rc<DeclarationStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeclarationStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 118, RULE_declarationStatement);
        let mut _localctx: Rc<DeclarationStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule blockDeclaration*/
			recog.base.set_state(970);
			recog.blockDeclaration()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- declarationseq ----------------
pub type DeclarationseqContextAll<'input> = DeclarationseqContext<'input>;


pub type DeclarationseqContext<'input> = BaseParserRuleContext<'input,DeclarationseqContextExt<'input>>;

#[derive(Clone)]
pub struct DeclarationseqContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for DeclarationseqContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for DeclarationseqContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_declarationseq(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_declarationseq(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DeclarationseqContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_declarationseq }
	//fn type_rule_index() -> usize where Self: Sized { RULE_declarationseq }
}
antlr_rust::tid!{DeclarationseqContextExt<'a>}

impl<'input> DeclarationseqContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeclarationseqContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeclarationseqContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeclarationseqContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<DeclarationseqContextExt<'input>>{

fn declaration_all(&self) ->  Vec<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn declaration(&self, i: usize) -> Option<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> DeclarationseqContextAttrs<'input> for DeclarationseqContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn declarationseq(&mut self,)
	-> Result<Rc<DeclarationseqContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeclarationseqContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_declarationseq);
        let mut _localctx: Rc<DeclarationseqContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(973); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule declaration*/
				recog.base.set_state(972);
				recog.declaration()?;

				}
				}
				recog.base.set_state(975); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !(((((_la - 10)) & !0x3f) == 0 && ((1usize << (_la - 10)) & ((1usize << (Alignas - 10)) | (1usize << (Asm - 10)) | (1usize << (Auto - 10)) | (1usize << (Bool - 10)) | (1usize << (Char - 10)) | (1usize << (Char16 - 10)) | (1usize << (Char32 - 10)) | (1usize << (Class - 10)) | (1usize << (Const - 10)) | (1usize << (Constexpr - 10)) | (1usize << (Decltype - 10)) | (1usize << (Double - 10)) | (1usize << (Enum - 10)) | (1usize << (Explicit - 10)) | (1usize << (Extern - 10)) | (1usize << (Float - 10)) | (1usize << (Friend - 10)))) != 0) || ((((_la - 44)) & !0x3f) == 0 && ((1usize << (_la - 44)) & ((1usize << (Inline - 44)) | (1usize << (Int - 44)) | (1usize << (Long - 44)) | (1usize << (Mutable - 44)) | (1usize << (Namespace - 44)) | (1usize << (Operator - 44)) | (1usize << (Register - 44)) | (1usize << (Short - 44)) | (1usize << (Signed - 44)) | (1usize << (Static - 44)) | (1usize << (Static_assert - 44)) | (1usize << (Struct - 44)) | (1usize << (Template - 44)) | (1usize << (Thread_local - 44)) | (1usize << (Typedef - 44)))) != 0) || ((((_la - 76)) & !0x3f) == 0 && ((1usize << (_la - 76)) & ((1usize << (Typename_ - 76)) | (1usize << (Union - 76)) | (1usize << (Unsigned - 76)) | (1usize << (Using - 76)) | (1usize << (Virtual - 76)) | (1usize << (Void - 76)) | (1usize << (Volatile - 76)) | (1usize << (Wchar - 76)) | (1usize << (LeftParen - 76)) | (1usize << (LeftBracket - 76)) | (1usize << (Star - 76)) | (1usize << (And - 76)) | (1usize << (Tilde - 76)))) != 0) || ((((_la - 118)) & !0x3f) == 0 && ((1usize << (_la - 118)) & ((1usize << (AndAnd - 118)) | (1usize << (Doublecolon - 118)) | (1usize << (Semi - 118)) | (1usize << (Ellipsis - 118)) | (1usize << (Identifier - 118)))) != 0)) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- declaration ----------------
pub type DeclarationContextAll<'input> = DeclarationContext<'input>;


pub type DeclarationContext<'input> = BaseParserRuleContext<'input,DeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct DeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for DeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for DeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_declaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_declaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_declaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_declaration }
}
antlr_rust::tid!{DeclarationContextExt<'a>}

impl<'input> DeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<DeclarationContextExt<'input>>{

fn blockDeclaration(&self) -> Option<Rc<BlockDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionDefinition(&self) -> Option<Rc<FunctionDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn templateDeclaration(&self) -> Option<Rc<TemplateDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn explicitInstantiation(&self) -> Option<Rc<ExplicitInstantiationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn explicitSpecialization(&self) -> Option<Rc<ExplicitSpecializationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn linkageSpecification(&self) -> Option<Rc<LinkageSpecificationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn namespaceDefinition(&self) -> Option<Rc<NamespaceDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn emptyDeclaration_(&self) -> Option<Rc<EmptyDeclaration_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeDeclaration(&self) -> Option<Rc<AttributeDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DeclarationContextAttrs<'input> for DeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn declaration(&mut self,)
	-> Result<Rc<DeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_declaration);
        let mut _localctx: Rc<DeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(986);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(96,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule blockDeclaration*/
					recog.base.set_state(977);
					recog.blockDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule functionDefinition*/
					recog.base.set_state(978);
					recog.functionDefinition()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule templateDeclaration*/
					recog.base.set_state(979);
					recog.templateDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule explicitInstantiation*/
					recog.base.set_state(980);
					recog.explicitInstantiation()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule explicitSpecialization*/
					recog.base.set_state(981);
					recog.explicitSpecialization()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule linkageSpecification*/
					recog.base.set_state(982);
					recog.linkageSpecification()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule namespaceDefinition*/
					recog.base.set_state(983);
					recog.namespaceDefinition()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule emptyDeclaration_*/
					recog.base.set_state(984);
					recog.emptyDeclaration_()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule attributeDeclaration*/
					recog.base.set_state(985);
					recog.attributeDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- blockDeclaration ----------------
pub type BlockDeclarationContextAll<'input> = BlockDeclarationContext<'input>;


pub type BlockDeclarationContext<'input> = BaseParserRuleContext<'input,BlockDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct BlockDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for BlockDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for BlockDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_blockDeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_blockDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BlockDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_blockDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_blockDeclaration }
}
antlr_rust::tid!{BlockDeclarationContextExt<'a>}

impl<'input> BlockDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BlockDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BlockDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BlockDeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<BlockDeclarationContextExt<'input>>{

fn simpleDeclaration(&self) -> Option<Rc<SimpleDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn asmDefinition(&self) -> Option<Rc<AsmDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn namespaceAliasDefinition(&self) -> Option<Rc<NamespaceAliasDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn usingDeclaration(&self) -> Option<Rc<UsingDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn usingDirective(&self) -> Option<Rc<UsingDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn staticAssertDeclaration(&self) -> Option<Rc<StaticAssertDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aliasDeclaration(&self) -> Option<Rc<AliasDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn opaqueEnumDeclaration(&self) -> Option<Rc<OpaqueEnumDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BlockDeclarationContextAttrs<'input> for BlockDeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn blockDeclaration(&mut self,)
	-> Result<Rc<BlockDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BlockDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_blockDeclaration);
        let mut _localctx: Rc<BlockDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(996);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(97,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule simpleDeclaration*/
					recog.base.set_state(988);
					recog.simpleDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule asmDefinition*/
					recog.base.set_state(989);
					recog.asmDefinition()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule namespaceAliasDefinition*/
					recog.base.set_state(990);
					recog.namespaceAliasDefinition()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule usingDeclaration*/
					recog.base.set_state(991);
					recog.usingDeclaration()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule usingDirective*/
					recog.base.set_state(992);
					recog.usingDirective()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule staticAssertDeclaration*/
					recog.base.set_state(993);
					recog.staticAssertDeclaration()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule aliasDeclaration*/
					recog.base.set_state(994);
					recog.aliasDeclaration()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule opaqueEnumDeclaration*/
					recog.base.set_state(995);
					recog.opaqueEnumDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aliasDeclaration ----------------
pub type AliasDeclarationContextAll<'input> = AliasDeclarationContext<'input>;


pub type AliasDeclarationContext<'input> = BaseParserRuleContext<'input,AliasDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct AliasDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AliasDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AliasDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aliasDeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_aliasDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AliasDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aliasDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aliasDeclaration }
}
antlr_rust::tid!{AliasDeclarationContextExt<'a>}

impl<'input> AliasDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AliasDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AliasDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AliasDeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AliasDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Using
/// Returns `None` if there is no child corresponding to token Using
fn Using(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Using, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}
fn theTypeId(&self) -> Option<Rc<TheTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AliasDeclarationContextAttrs<'input> for AliasDeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aliasDeclaration(&mut self,)
	-> Result<Rc<AliasDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AliasDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_aliasDeclaration);
        let mut _localctx: Rc<AliasDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(998);
			recog.base.match_token(Using,&mut recog.err_handler)?;

			recog.base.set_state(999);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(1001);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Alignas || _la==LeftBracket {
				{
				/*InvokeRule attributeSpecifierSeq*/
				recog.base.set_state(1000);
				recog.attributeSpecifierSeq()?;

				}
			}

			recog.base.set_state(1003);
			recog.base.match_token(Assign,&mut recog.err_handler)?;

			/*InvokeRule theTypeId*/
			recog.base.set_state(1004);
			recog.theTypeId()?;

			recog.base.set_state(1005);
			recog.base.match_token(Semi,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleDeclaration ----------------
pub type SimpleDeclarationContextAll<'input> = SimpleDeclarationContext<'input>;


pub type SimpleDeclarationContext<'input> = BaseParserRuleContext<'input,SimpleDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for SimpleDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for SimpleDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_simpleDeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_simpleDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SimpleDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleDeclaration }
}
antlr_rust::tid!{SimpleDeclarationContextExt<'a>}

impl<'input> SimpleDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleDeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<SimpleDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}
fn declSpecifierSeq(&self) -> Option<Rc<DeclSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn initDeclaratorList(&self) -> Option<Rc<InitDeclaratorListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SimpleDeclarationContextAttrs<'input> for SimpleDeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleDeclaration(&mut self,)
	-> Result<Rc<SimpleDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_simpleDeclaration);
        let mut _localctx: Rc<SimpleDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1021);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Auto | Bool | Char | Char16 | Char32 | Class | Const | Constexpr | Decltype |
			 Double | Enum | Explicit | Extern | Float | Friend | Inline | Int | Long |
			 Mutable | Operator | Register | Short | Signed | Static | Struct | Thread_local |
			 Typedef | Typename_ | Union | Unsigned | Virtual | Void | Volatile |
			 Wchar | LeftParen | Star | And | Tilde | AndAnd | Doublecolon | Semi |
			 Ellipsis | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1008);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(99,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule declSpecifierSeq*/
							recog.base.set_state(1007);
							recog.declSpecifierSeq()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1011);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Decltype || _la==Operator || ((((_la - 85)) & !0x3f) == 0 && ((1usize << (_la - 85)) & ((1usize << (LeftParen - 85)) | (1usize << (Star - 85)) | (1usize << (And - 85)) | (1usize << (Tilde - 85)))) != 0) || ((((_la - 118)) & !0x3f) == 0 && ((1usize << (_la - 118)) & ((1usize << (AndAnd - 118)) | (1usize << (Doublecolon - 118)) | (1usize << (Ellipsis - 118)) | (1usize << (Identifier - 118)))) != 0) {
						{
						/*InvokeRule initDeclaratorList*/
						recog.base.set_state(1010);
						recog.initDeclaratorList()?;

						}
					}

					recog.base.set_state(1013);
					recog.base.match_token(Semi,&mut recog.err_handler)?;

					}
				}

			 Alignas | LeftBracket 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule attributeSpecifierSeq*/
					recog.base.set_state(1014);
					recog.attributeSpecifierSeq()?;

					recog.base.set_state(1016);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(101,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule declSpecifierSeq*/
							recog.base.set_state(1015);
							recog.declSpecifierSeq()?;

							}
						}

						_ => {}
					}
					/*InvokeRule initDeclaratorList*/
					recog.base.set_state(1018);
					recog.initDeclaratorList()?;

					recog.base.set_state(1019);
					recog.base.match_token(Semi,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- staticAssertDeclaration ----------------
pub type StaticAssertDeclarationContextAll<'input> = StaticAssertDeclarationContext<'input>;


pub type StaticAssertDeclarationContext<'input> = BaseParserRuleContext<'input,StaticAssertDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct StaticAssertDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for StaticAssertDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for StaticAssertDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_staticAssertDeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_staticAssertDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StaticAssertDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_staticAssertDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_staticAssertDeclaration }
}
antlr_rust::tid!{StaticAssertDeclarationContextExt<'a>}

impl<'input> StaticAssertDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StaticAssertDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StaticAssertDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StaticAssertDeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<StaticAssertDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Static_assert
/// Returns `None` if there is no child corresponding to token Static_assert
fn Static_assert(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Static_assert, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Comma
/// Returns `None` if there is no child corresponding to token Comma
fn Comma(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, 0)
}
/// Retrieves first TerminalNode corresponding to token StringLiteral
/// Returns `None` if there is no child corresponding to token StringLiteral
fn StringLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(StringLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}

}

impl<'input> StaticAssertDeclarationContextAttrs<'input> for StaticAssertDeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn staticAssertDeclaration(&mut self,)
	-> Result<Rc<StaticAssertDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StaticAssertDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_staticAssertDeclaration);
        let mut _localctx: Rc<StaticAssertDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1023);
			recog.base.match_token(Static_assert,&mut recog.err_handler)?;

			recog.base.set_state(1024);
			recog.base.match_token(LeftParen,&mut recog.err_handler)?;

			/*InvokeRule constantExpression*/
			recog.base.set_state(1025);
			recog.constantExpression()?;

			recog.base.set_state(1026);
			recog.base.match_token(Comma,&mut recog.err_handler)?;

			recog.base.set_state(1027);
			recog.base.match_token(StringLiteral,&mut recog.err_handler)?;

			recog.base.set_state(1028);
			recog.base.match_token(RightParen,&mut recog.err_handler)?;

			recog.base.set_state(1029);
			recog.base.match_token(Semi,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- emptyDeclaration_ ----------------
pub type EmptyDeclaration_ContextAll<'input> = EmptyDeclaration_Context<'input>;


pub type EmptyDeclaration_Context<'input> = BaseParserRuleContext<'input,EmptyDeclaration_ContextExt<'input>>;

#[derive(Clone)]
pub struct EmptyDeclaration_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for EmptyDeclaration_Context<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for EmptyDeclaration_Context<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_emptyDeclaration_(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_emptyDeclaration_(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EmptyDeclaration_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_emptyDeclaration_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_emptyDeclaration_ }
}
antlr_rust::tid!{EmptyDeclaration_ContextExt<'a>}

impl<'input> EmptyDeclaration_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EmptyDeclaration_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EmptyDeclaration_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EmptyDeclaration_ContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<EmptyDeclaration_ContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}

}

impl<'input> EmptyDeclaration_ContextAttrs<'input> for EmptyDeclaration_Context<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn emptyDeclaration_(&mut self,)
	-> Result<Rc<EmptyDeclaration_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EmptyDeclaration_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_emptyDeclaration_);
        let mut _localctx: Rc<EmptyDeclaration_ContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1031);
			recog.base.match_token(Semi,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- attributeDeclaration ----------------
pub type AttributeDeclarationContextAll<'input> = AttributeDeclarationContext<'input>;


pub type AttributeDeclarationContext<'input> = BaseParserRuleContext<'input,AttributeDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct AttributeDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AttributeDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AttributeDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_attributeDeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_attributeDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AttributeDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_attributeDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_attributeDeclaration }
}
antlr_rust::tid!{AttributeDeclarationContextExt<'a>}

impl<'input> AttributeDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AttributeDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AttributeDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AttributeDeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AttributeDeclarationContextExt<'input>>{

fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}

}

impl<'input> AttributeDeclarationContextAttrs<'input> for AttributeDeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn attributeDeclaration(&mut self,)
	-> Result<Rc<AttributeDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AttributeDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_attributeDeclaration);
        let mut _localctx: Rc<AttributeDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attributeSpecifierSeq*/
			recog.base.set_state(1033);
			recog.attributeSpecifierSeq()?;

			recog.base.set_state(1034);
			recog.base.match_token(Semi,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- declSpecifier ----------------
pub type DeclSpecifierContextAll<'input> = DeclSpecifierContext<'input>;


pub type DeclSpecifierContext<'input> = BaseParserRuleContext<'input,DeclSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct DeclSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for DeclSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for DeclSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_declSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_declSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DeclSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_declSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_declSpecifier }
}
antlr_rust::tid!{DeclSpecifierContextExt<'a>}

impl<'input> DeclSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeclSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeclSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeclSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<DeclSpecifierContextExt<'input>>{

fn storageClassSpecifier(&self) -> Option<Rc<StorageClassSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeSpecifier(&self) -> Option<Rc<TypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionSpecifier(&self) -> Option<Rc<FunctionSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Friend
/// Returns `None` if there is no child corresponding to token Friend
fn Friend(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Friend, 0)
}
/// Retrieves first TerminalNode corresponding to token Typedef
/// Returns `None` if there is no child corresponding to token Typedef
fn Typedef(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Typedef, 0)
}
/// Retrieves first TerminalNode corresponding to token Constexpr
/// Returns `None` if there is no child corresponding to token Constexpr
fn Constexpr(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Constexpr, 0)
}

}

impl<'input> DeclSpecifierContextAttrs<'input> for DeclSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn declSpecifier(&mut self,)
	-> Result<Rc<DeclSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeclSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_declSpecifier);
        let mut _localctx: Rc<DeclSpecifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1042);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Extern | Mutable | Register | Static | Thread_local 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule storageClassSpecifier*/
					recog.base.set_state(1036);
					recog.storageClassSpecifier()?;

					}
				}

			 Auto | Bool | Char | Char16 | Char32 | Class | Const | Decltype | Double |
			 Enum | Float | Int | Long | Short | Signed | Struct | Typename_ | Union |
			 Unsigned | Void | Volatile | Wchar | Doublecolon | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeSpecifier*/
					recog.base.set_state(1037);
					recog.typeSpecifier()?;

					}
				}

			 Explicit | Inline | Virtual 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule functionSpecifier*/
					recog.base.set_state(1038);
					recog.functionSpecifier()?;

					}
				}

			 Friend 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1039);
					recog.base.match_token(Friend,&mut recog.err_handler)?;

					}
				}

			 Typedef 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1040);
					recog.base.match_token(Typedef,&mut recog.err_handler)?;

					}
				}

			 Constexpr 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(1041);
					recog.base.match_token(Constexpr,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- declSpecifierSeq ----------------
pub type DeclSpecifierSeqContextAll<'input> = DeclSpecifierSeqContext<'input>;


pub type DeclSpecifierSeqContext<'input> = BaseParserRuleContext<'input,DeclSpecifierSeqContextExt<'input>>;

#[derive(Clone)]
pub struct DeclSpecifierSeqContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for DeclSpecifierSeqContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for DeclSpecifierSeqContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_declSpecifierSeq(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_declSpecifierSeq(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DeclSpecifierSeqContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_declSpecifierSeq }
	//fn type_rule_index() -> usize where Self: Sized { RULE_declSpecifierSeq }
}
antlr_rust::tid!{DeclSpecifierSeqContextExt<'a>}

impl<'input> DeclSpecifierSeqContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeclSpecifierSeqContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeclSpecifierSeqContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeclSpecifierSeqContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<DeclSpecifierSeqContextExt<'input>>{

fn declSpecifier_all(&self) ->  Vec<Rc<DeclSpecifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn declSpecifier(&self, i: usize) -> Option<Rc<DeclSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DeclSpecifierSeqContextAttrs<'input> for DeclSpecifierSeqContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn declSpecifierSeq(&mut self,)
	-> Result<Rc<DeclSpecifierSeqContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeclSpecifierSeqContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_declSpecifierSeq);
        let mut _localctx: Rc<DeclSpecifierSeqContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1045); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1+1;
			loop {
				match _alt {
				    x if x == 1+1=>
					{
					{
					/*InvokeRule declSpecifier*/
					recog.base.set_state(1044);
					recog.declSpecifier()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(1047); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(104,&mut recog.base)?;
				if _alt==1 || _alt==INVALID_ALT { break }
			}
			recog.base.set_state(1050);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(105,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule attributeSpecifierSeq*/
					recog.base.set_state(1049);
					recog.attributeSpecifierSeq()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- storageClassSpecifier ----------------
pub type StorageClassSpecifierContextAll<'input> = StorageClassSpecifierContext<'input>;


pub type StorageClassSpecifierContext<'input> = BaseParserRuleContext<'input,StorageClassSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct StorageClassSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for StorageClassSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for StorageClassSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_storageClassSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_storageClassSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StorageClassSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_storageClassSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_storageClassSpecifier }
}
antlr_rust::tid!{StorageClassSpecifierContextExt<'a>}

impl<'input> StorageClassSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StorageClassSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StorageClassSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StorageClassSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<StorageClassSpecifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Register
/// Returns `None` if there is no child corresponding to token Register
fn Register(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Register, 0)
}
/// Retrieves first TerminalNode corresponding to token Static
/// Returns `None` if there is no child corresponding to token Static
fn Static(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Static, 0)
}
/// Retrieves first TerminalNode corresponding to token Thread_local
/// Returns `None` if there is no child corresponding to token Thread_local
fn Thread_local(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Thread_local, 0)
}
/// Retrieves first TerminalNode corresponding to token Extern
/// Returns `None` if there is no child corresponding to token Extern
fn Extern(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Extern, 0)
}
/// Retrieves first TerminalNode corresponding to token Mutable
/// Returns `None` if there is no child corresponding to token Mutable
fn Mutable(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Mutable, 0)
}

}

impl<'input> StorageClassSpecifierContextAttrs<'input> for StorageClassSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn storageClassSpecifier(&mut self,)
	-> Result<Rc<StorageClassSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StorageClassSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_storageClassSpecifier);
        let mut _localctx: Rc<StorageClassSpecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1052);
			_la = recog.base.input.la(1);
			if { !(((((_la - 36)) & !0x3f) == 0 && ((1usize << (_la - 36)) & ((1usize << (Extern - 36)) | (1usize << (Mutable - 36)) | (1usize << (Register - 36)) | (1usize << (Static - 36)))) != 0) || _la==Thread_local) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionSpecifier ----------------
pub type FunctionSpecifierContextAll<'input> = FunctionSpecifierContext<'input>;


pub type FunctionSpecifierContext<'input> = BaseParserRuleContext<'input,FunctionSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for FunctionSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for FunctionSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_functionSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FunctionSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionSpecifier }
}
antlr_rust::tid!{FunctionSpecifierContextExt<'a>}

impl<'input> FunctionSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<FunctionSpecifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Inline
/// Returns `None` if there is no child corresponding to token Inline
fn Inline(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Inline, 0)
}
/// Retrieves first TerminalNode corresponding to token Virtual
/// Returns `None` if there is no child corresponding to token Virtual
fn Virtual(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Virtual, 0)
}
/// Retrieves first TerminalNode corresponding to token Explicit
/// Returns `None` if there is no child corresponding to token Explicit
fn Explicit(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Explicit, 0)
}

}

impl<'input> FunctionSpecifierContextAttrs<'input> for FunctionSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionSpecifier(&mut self,)
	-> Result<Rc<FunctionSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_functionSpecifier);
        let mut _localctx: Rc<FunctionSpecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1054);
			_la = recog.base.input.la(1);
			if { !(_la==Explicit || _la==Inline || _la==Virtual) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typedefName ----------------
pub type TypedefNameContextAll<'input> = TypedefNameContext<'input>;


pub type TypedefNameContext<'input> = BaseParserRuleContext<'input,TypedefNameContextExt<'input>>;

#[derive(Clone)]
pub struct TypedefNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TypedefNameContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TypedefNameContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typedefName(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_typedefName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypedefNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typedefName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typedefName }
}
antlr_rust::tid!{TypedefNameContextExt<'a>}

impl<'input> TypedefNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypedefNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypedefNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypedefNameContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TypedefNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> TypedefNameContextAttrs<'input> for TypedefNameContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typedefName(&mut self,)
	-> Result<Rc<TypedefNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypedefNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_typedefName);
        let mut _localctx: Rc<TypedefNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1056);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeSpecifier ----------------
pub type TypeSpecifierContextAll<'input> = TypeSpecifierContext<'input>;


pub type TypeSpecifierContext<'input> = BaseParserRuleContext<'input,TypeSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TypeSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TypeSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_typeSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeSpecifier }
}
antlr_rust::tid!{TypeSpecifierContextExt<'a>}

impl<'input> TypeSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TypeSpecifierContextExt<'input>>{

fn trailingTypeSpecifier(&self) -> Option<Rc<TrailingTypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classSpecifier(&self) -> Option<Rc<ClassSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enumSpecifier(&self) -> Option<Rc<EnumSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeSpecifierContextAttrs<'input> for TypeSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeSpecifier(&mut self,)
	-> Result<Rc<TypeSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_typeSpecifier);
        let mut _localctx: Rc<TypeSpecifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1061);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(106,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule trailingTypeSpecifier*/
					recog.base.set_state(1058);
					recog.trailingTypeSpecifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule classSpecifier*/
					recog.base.set_state(1059);
					recog.classSpecifier()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule enumSpecifier*/
					recog.base.set_state(1060);
					recog.enumSpecifier()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- trailingTypeSpecifier ----------------
pub type TrailingTypeSpecifierContextAll<'input> = TrailingTypeSpecifierContext<'input>;


pub type TrailingTypeSpecifierContext<'input> = BaseParserRuleContext<'input,TrailingTypeSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct TrailingTypeSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TrailingTypeSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TrailingTypeSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_trailingTypeSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_trailingTypeSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TrailingTypeSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_trailingTypeSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_trailingTypeSpecifier }
}
antlr_rust::tid!{TrailingTypeSpecifierContextExt<'a>}

impl<'input> TrailingTypeSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TrailingTypeSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TrailingTypeSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TrailingTypeSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TrailingTypeSpecifierContextExt<'input>>{

fn simpleTypeSpecifier(&self) -> Option<Rc<SimpleTypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn elaboratedTypeSpecifier(&self) -> Option<Rc<ElaboratedTypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeNameSpecifier(&self) -> Option<Rc<TypeNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn cvQualifier(&self) -> Option<Rc<CvQualifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TrailingTypeSpecifierContextAttrs<'input> for TrailingTypeSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn trailingTypeSpecifier(&mut self,)
	-> Result<Rc<TrailingTypeSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TrailingTypeSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_trailingTypeSpecifier);
        let mut _localctx: Rc<TrailingTypeSpecifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1067);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Auto | Bool | Char | Char16 | Char32 | Decltype | Double | Float | Int |
			 Long | Short | Signed | Unsigned | Void | Wchar | Doublecolon | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule simpleTypeSpecifier*/
					recog.base.set_state(1063);
					recog.simpleTypeSpecifier()?;

					}
				}

			 Class | Enum | Struct 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule elaboratedTypeSpecifier*/
					recog.base.set_state(1064);
					recog.elaboratedTypeSpecifier()?;

					}
				}

			 Typename_ 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule typeNameSpecifier*/
					recog.base.set_state(1065);
					recog.typeNameSpecifier()?;

					}
				}

			 Const | Volatile 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule cvQualifier*/
					recog.base.set_state(1066);
					recog.cvQualifier()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeSpecifierSeq ----------------
pub type TypeSpecifierSeqContextAll<'input> = TypeSpecifierSeqContext<'input>;


pub type TypeSpecifierSeqContext<'input> = BaseParserRuleContext<'input,TypeSpecifierSeqContextExt<'input>>;

#[derive(Clone)]
pub struct TypeSpecifierSeqContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TypeSpecifierSeqContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TypeSpecifierSeqContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeSpecifierSeq(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_typeSpecifierSeq(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeSpecifierSeqContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeSpecifierSeq }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeSpecifierSeq }
}
antlr_rust::tid!{TypeSpecifierSeqContextExt<'a>}

impl<'input> TypeSpecifierSeqContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeSpecifierSeqContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeSpecifierSeqContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeSpecifierSeqContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TypeSpecifierSeqContextExt<'input>>{

fn typeSpecifier_all(&self) ->  Vec<Rc<TypeSpecifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeSpecifier(&self, i: usize) -> Option<Rc<TypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeSpecifierSeqContextAttrs<'input> for TypeSpecifierSeqContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeSpecifierSeq(&mut self,)
	-> Result<Rc<TypeSpecifierSeqContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeSpecifierSeqContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_typeSpecifierSeq);
        let mut _localctx: Rc<TypeSpecifierSeqContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1070); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule typeSpecifier*/
					recog.base.set_state(1069);
					recog.typeSpecifier()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(1072); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(108,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			recog.base.set_state(1075);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(109,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule attributeSpecifierSeq*/
					recog.base.set_state(1074);
					recog.attributeSpecifierSeq()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- trailingTypeSpecifierSeq ----------------
pub type TrailingTypeSpecifierSeqContextAll<'input> = TrailingTypeSpecifierSeqContext<'input>;


pub type TrailingTypeSpecifierSeqContext<'input> = BaseParserRuleContext<'input,TrailingTypeSpecifierSeqContextExt<'input>>;

#[derive(Clone)]
pub struct TrailingTypeSpecifierSeqContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TrailingTypeSpecifierSeqContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TrailingTypeSpecifierSeqContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_trailingTypeSpecifierSeq(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_trailingTypeSpecifierSeq(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TrailingTypeSpecifierSeqContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_trailingTypeSpecifierSeq }
	//fn type_rule_index() -> usize where Self: Sized { RULE_trailingTypeSpecifierSeq }
}
antlr_rust::tid!{TrailingTypeSpecifierSeqContextExt<'a>}

impl<'input> TrailingTypeSpecifierSeqContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TrailingTypeSpecifierSeqContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TrailingTypeSpecifierSeqContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TrailingTypeSpecifierSeqContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TrailingTypeSpecifierSeqContextExt<'input>>{

fn trailingTypeSpecifier_all(&self) ->  Vec<Rc<TrailingTypeSpecifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn trailingTypeSpecifier(&self, i: usize) -> Option<Rc<TrailingTypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TrailingTypeSpecifierSeqContextAttrs<'input> for TrailingTypeSpecifierSeqContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn trailingTypeSpecifierSeq(&mut self,)
	-> Result<Rc<TrailingTypeSpecifierSeqContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TrailingTypeSpecifierSeqContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_trailingTypeSpecifierSeq);
        let mut _localctx: Rc<TrailingTypeSpecifierSeqContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1078); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule trailingTypeSpecifier*/
					recog.base.set_state(1077);
					recog.trailingTypeSpecifier()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(1080); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(110,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			recog.base.set_state(1083);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(111,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule attributeSpecifierSeq*/
					recog.base.set_state(1082);
					recog.attributeSpecifierSeq()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleTypeLengthModifier ----------------
pub type SimpleTypeLengthModifierContextAll<'input> = SimpleTypeLengthModifierContext<'input>;


pub type SimpleTypeLengthModifierContext<'input> = BaseParserRuleContext<'input,SimpleTypeLengthModifierContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleTypeLengthModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for SimpleTypeLengthModifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for SimpleTypeLengthModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_simpleTypeLengthModifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_simpleTypeLengthModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SimpleTypeLengthModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleTypeLengthModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleTypeLengthModifier }
}
antlr_rust::tid!{SimpleTypeLengthModifierContextExt<'a>}

impl<'input> SimpleTypeLengthModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleTypeLengthModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleTypeLengthModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleTypeLengthModifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<SimpleTypeLengthModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Short
/// Returns `None` if there is no child corresponding to token Short
fn Short(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Short, 0)
}
/// Retrieves first TerminalNode corresponding to token Long
/// Returns `None` if there is no child corresponding to token Long
fn Long(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Long, 0)
}

}

impl<'input> SimpleTypeLengthModifierContextAttrs<'input> for SimpleTypeLengthModifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleTypeLengthModifier(&mut self,)
	-> Result<Rc<SimpleTypeLengthModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleTypeLengthModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_simpleTypeLengthModifier);
        let mut _localctx: Rc<SimpleTypeLengthModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1085);
			_la = recog.base.input.la(1);
			if { !(_la==Long || _la==Short) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleTypeSignednessModifier ----------------
pub type SimpleTypeSignednessModifierContextAll<'input> = SimpleTypeSignednessModifierContext<'input>;


pub type SimpleTypeSignednessModifierContext<'input> = BaseParserRuleContext<'input,SimpleTypeSignednessModifierContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleTypeSignednessModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for SimpleTypeSignednessModifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for SimpleTypeSignednessModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_simpleTypeSignednessModifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_simpleTypeSignednessModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SimpleTypeSignednessModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleTypeSignednessModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleTypeSignednessModifier }
}
antlr_rust::tid!{SimpleTypeSignednessModifierContextExt<'a>}

impl<'input> SimpleTypeSignednessModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleTypeSignednessModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleTypeSignednessModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleTypeSignednessModifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<SimpleTypeSignednessModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Unsigned
/// Returns `None` if there is no child corresponding to token Unsigned
fn Unsigned(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Unsigned, 0)
}
/// Retrieves first TerminalNode corresponding to token Signed
/// Returns `None` if there is no child corresponding to token Signed
fn Signed(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Signed, 0)
}

}

impl<'input> SimpleTypeSignednessModifierContextAttrs<'input> for SimpleTypeSignednessModifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleTypeSignednessModifier(&mut self,)
	-> Result<Rc<SimpleTypeSignednessModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleTypeSignednessModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_simpleTypeSignednessModifier);
        let mut _localctx: Rc<SimpleTypeSignednessModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1087);
			_la = recog.base.input.la(1);
			if { !(_la==Signed || _la==Unsigned) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleTypeSpecifier ----------------
pub type SimpleTypeSpecifierContextAll<'input> = SimpleTypeSpecifierContext<'input>;


pub type SimpleTypeSpecifierContext<'input> = BaseParserRuleContext<'input,SimpleTypeSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleTypeSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for SimpleTypeSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for SimpleTypeSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_simpleTypeSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_simpleTypeSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SimpleTypeSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleTypeSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleTypeSpecifier }
}
antlr_rust::tid!{SimpleTypeSpecifierContextExt<'a>}

impl<'input> SimpleTypeSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleTypeSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleTypeSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleTypeSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<SimpleTypeSpecifierContextExt<'input>>{

fn theTypeName(&self) -> Option<Rc<TheTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Template
/// Returns `None` if there is no child corresponding to token Template
fn Template(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Template, 0)
}
fn simpleTemplateId(&self) -> Option<Rc<SimpleTemplateIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Char
/// Returns `None` if there is no child corresponding to token Char
fn Char(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Char, 0)
}
/// Retrieves first TerminalNode corresponding to token Char16
/// Returns `None` if there is no child corresponding to token Char16
fn Char16(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Char16, 0)
}
/// Retrieves first TerminalNode corresponding to token Char32
/// Returns `None` if there is no child corresponding to token Char32
fn Char32(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Char32, 0)
}
/// Retrieves first TerminalNode corresponding to token Wchar
/// Returns `None` if there is no child corresponding to token Wchar
fn Wchar(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Wchar, 0)
}
/// Retrieves first TerminalNode corresponding to token Bool
/// Returns `None` if there is no child corresponding to token Bool
fn Bool(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Bool, 0)
}
/// Retrieves first TerminalNode corresponding to token Short
/// Returns `None` if there is no child corresponding to token Short
fn Short(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Short, 0)
}
/// Retrieves first TerminalNode corresponding to token Int
/// Returns `None` if there is no child corresponding to token Int
fn Int(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Int, 0)
}
/// Retrieves first TerminalNode corresponding to token Long
/// Returns `None` if there is no child corresponding to token Long
fn Long(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Long, 0)
}
/// Retrieves first TerminalNode corresponding to token Float
/// Returns `None` if there is no child corresponding to token Float
fn Float(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Float, 0)
}
/// Retrieves first TerminalNode corresponding to token Signed
/// Returns `None` if there is no child corresponding to token Signed
fn Signed(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Signed, 0)
}
/// Retrieves first TerminalNode corresponding to token Unsigned
/// Returns `None` if there is no child corresponding to token Unsigned
fn Unsigned(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Unsigned, 0)
}
/// Retrieves first TerminalNode corresponding to token Double
/// Returns `None` if there is no child corresponding to token Double
fn Double(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Double, 0)
}
/// Retrieves first TerminalNode corresponding to token Void
/// Returns `None` if there is no child corresponding to token Void
fn Void(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Void, 0)
}
/// Retrieves first TerminalNode corresponding to token Auto
/// Returns `None` if there is no child corresponding to token Auto
fn Auto(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Auto, 0)
}
fn decltypeSpecifier(&self) -> Option<Rc<DecltypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SimpleTypeSpecifierContextAttrs<'input> for SimpleTypeSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleTypeSpecifier(&mut self,)
	-> Result<Rc<SimpleTypeSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleTypeSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_simpleTypeSpecifier);
        let mut _localctx: Rc<SimpleTypeSpecifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1113);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(113,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1090);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(112,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule nestedNameSpecifier*/
							recog.base.set_state(1089);
							recog.nestedNameSpecifier_rec(0)?;

							}
						}

						_ => {}
					}
					/*InvokeRule theTypeName*/
					recog.base.set_state(1092);
					recog.theTypeName()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule nestedNameSpecifier*/
					recog.base.set_state(1093);
					recog.nestedNameSpecifier_rec(0)?;

					recog.base.set_state(1094);
					recog.base.match_token(Template,&mut recog.err_handler)?;

					/*InvokeRule simpleTemplateId*/
					recog.base.set_state(1095);
					recog.simpleTemplateId()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1097);
					recog.base.match_token(Char,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1098);
					recog.base.match_token(Char16,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1099);
					recog.base.match_token(Char32,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(1100);
					recog.base.match_token(Wchar,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(1101);
					recog.base.match_token(Bool,&mut recog.err_handler)?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(1102);
					recog.base.match_token(Short,&mut recog.err_handler)?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					recog.base.set_state(1103);
					recog.base.match_token(Int,&mut recog.err_handler)?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					recog.base.set_state(1104);
					recog.base.match_token(Long,&mut recog.err_handler)?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					recog.base.set_state(1105);
					recog.base.match_token(Float,&mut recog.err_handler)?;

					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					recog.base.set_state(1106);
					recog.base.match_token(Signed,&mut recog.err_handler)?;

					}
				}
			,
				13 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					recog.base.set_state(1107);
					recog.base.match_token(Unsigned,&mut recog.err_handler)?;

					}
				}
			,
				14 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					recog.base.set_state(1108);
					recog.base.match_token(Float,&mut recog.err_handler)?;

					}
				}
			,
				15 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					recog.base.set_state(1109);
					recog.base.match_token(Double,&mut recog.err_handler)?;

					}
				}
			,
				16 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 16);
					recog.base.enter_outer_alt(None, 16);
					{
					recog.base.set_state(1110);
					recog.base.match_token(Void,&mut recog.err_handler)?;

					}
				}
			,
				17 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 17);
					recog.base.enter_outer_alt(None, 17);
					{
					recog.base.set_state(1111);
					recog.base.match_token(Auto,&mut recog.err_handler)?;

					}
				}
			,
				18 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 18);
					recog.base.enter_outer_alt(None, 18);
					{
					/*InvokeRule decltypeSpecifier*/
					recog.base.set_state(1112);
					recog.decltypeSpecifier()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- theTypeName ----------------
pub type TheTypeNameContextAll<'input> = TheTypeNameContext<'input>;


pub type TheTypeNameContext<'input> = BaseParserRuleContext<'input,TheTypeNameContextExt<'input>>;

#[derive(Clone)]
pub struct TheTypeNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TheTypeNameContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TheTypeNameContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_theTypeName(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_theTypeName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TheTypeNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_theTypeName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_theTypeName }
}
antlr_rust::tid!{TheTypeNameContextExt<'a>}

impl<'input> TheTypeNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TheTypeNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TheTypeNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TheTypeNameContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TheTypeNameContextExt<'input>>{

fn className(&self) -> Option<Rc<ClassNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enumName(&self) -> Option<Rc<EnumNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typedefName(&self) -> Option<Rc<TypedefNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn simpleTemplateId(&self) -> Option<Rc<SimpleTemplateIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TheTypeNameContextAttrs<'input> for TheTypeNameContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn theTypeName(&mut self,)
	-> Result<Rc<TheTypeNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TheTypeNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_theTypeName);
        let mut _localctx: Rc<TheTypeNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1119);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(114,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule className*/
					recog.base.set_state(1115);
					recog.className()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule enumName*/
					recog.base.set_state(1116);
					recog.enumName()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule typedefName*/
					recog.base.set_state(1117);
					recog.typedefName()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule simpleTemplateId*/
					recog.base.set_state(1118);
					recog.simpleTemplateId()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- decltypeSpecifier ----------------
pub type DecltypeSpecifierContextAll<'input> = DecltypeSpecifierContext<'input>;


pub type DecltypeSpecifierContext<'input> = BaseParserRuleContext<'input,DecltypeSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct DecltypeSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for DecltypeSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for DecltypeSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_decltypeSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_decltypeSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DecltypeSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_decltypeSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_decltypeSpecifier }
}
antlr_rust::tid!{DecltypeSpecifierContextExt<'a>}

impl<'input> DecltypeSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DecltypeSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DecltypeSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DecltypeSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<DecltypeSpecifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Decltype
/// Returns `None` if there is no child corresponding to token Decltype
fn Decltype(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Decltype, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Auto
/// Returns `None` if there is no child corresponding to token Auto
fn Auto(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Auto, 0)
}

}

impl<'input> DecltypeSpecifierContextAttrs<'input> for DecltypeSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn decltypeSpecifier(&mut self,)
	-> Result<Rc<DecltypeSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DecltypeSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_decltypeSpecifier);
        let mut _localctx: Rc<DecltypeSpecifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1121);
			recog.base.match_token(Decltype,&mut recog.err_handler)?;

			recog.base.set_state(1122);
			recog.base.match_token(LeftParen,&mut recog.err_handler)?;

			recog.base.set_state(1125);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(115,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule expression*/
					recog.base.set_state(1123);
					recog.expression()?;

					}
				}
			,
				2 =>{
					{
					recog.base.set_state(1124);
					recog.base.match_token(Auto,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1127);
			recog.base.match_token(RightParen,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elaboratedTypeSpecifier ----------------
pub type ElaboratedTypeSpecifierContextAll<'input> = ElaboratedTypeSpecifierContext<'input>;


pub type ElaboratedTypeSpecifierContext<'input> = BaseParserRuleContext<'input,ElaboratedTypeSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct ElaboratedTypeSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ElaboratedTypeSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ElaboratedTypeSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elaboratedTypeSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_elaboratedTypeSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ElaboratedTypeSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elaboratedTypeSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elaboratedTypeSpecifier }
}
antlr_rust::tid!{ElaboratedTypeSpecifierContextExt<'a>}

impl<'input> ElaboratedTypeSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElaboratedTypeSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElaboratedTypeSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElaboratedTypeSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ElaboratedTypeSpecifierContextExt<'input>>{

fn classKey(&self) -> Option<Rc<ClassKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn simpleTemplateId(&self) -> Option<Rc<SimpleTemplateIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Template
/// Returns `None` if there is no child corresponding to token Template
fn Template(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Template, 0)
}
/// Retrieves first TerminalNode corresponding to token Enum
/// Returns `None` if there is no child corresponding to token Enum
fn Enum(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Enum, 0)
}

}

impl<'input> ElaboratedTypeSpecifierContextAttrs<'input> for ElaboratedTypeSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elaboratedTypeSpecifier(&mut self,)
	-> Result<Rc<ElaboratedTypeSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElaboratedTypeSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_elaboratedTypeSpecifier);
        let mut _localctx: Rc<ElaboratedTypeSpecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1151);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Class | Struct 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classKey*/
					recog.base.set_state(1129);
					recog.classKey()?;

					recog.base.set_state(1144);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(119,&mut recog.base)? {
						1 =>{
							{
							recog.base.set_state(1131);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==Alignas || _la==LeftBracket {
								{
								/*InvokeRule attributeSpecifierSeq*/
								recog.base.set_state(1130);
								recog.attributeSpecifierSeq()?;

								}
							}

							recog.base.set_state(1134);
							recog.err_handler.sync(&mut recog.base)?;
							match  recog.interpreter.adaptive_predict(117,&mut recog.base)? {
								x if x == 1=>{
									{
									/*InvokeRule nestedNameSpecifier*/
									recog.base.set_state(1133);
									recog.nestedNameSpecifier_rec(0)?;

									}
								}

								_ => {}
							}
							recog.base.set_state(1136);
							recog.base.match_token(Identifier,&mut recog.err_handler)?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule simpleTemplateId*/
							recog.base.set_state(1137);
							recog.simpleTemplateId()?;

							}
						}
					,
						3 =>{
							{
							/*InvokeRule nestedNameSpecifier*/
							recog.base.set_state(1138);
							recog.nestedNameSpecifier_rec(0)?;

							recog.base.set_state(1140);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==Template {
								{
								recog.base.set_state(1139);
								recog.base.match_token(Template,&mut recog.err_handler)?;

								}
							}

							/*InvokeRule simpleTemplateId*/
							recog.base.set_state(1142);
							recog.simpleTemplateId()?;

							}
						}

						_ => {}
					}
					}
				}

			 Enum 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1146);
					recog.base.match_token(Enum,&mut recog.err_handler)?;

					recog.base.set_state(1148);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(120,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule nestedNameSpecifier*/
							recog.base.set_state(1147);
							recog.nestedNameSpecifier_rec(0)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1150);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumName ----------------
pub type EnumNameContextAll<'input> = EnumNameContext<'input>;


pub type EnumNameContext<'input> = BaseParserRuleContext<'input,EnumNameContextExt<'input>>;

#[derive(Clone)]
pub struct EnumNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for EnumNameContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for EnumNameContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumName(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_enumName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumName }
}
antlr_rust::tid!{EnumNameContextExt<'a>}

impl<'input> EnumNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumNameContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<EnumNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> EnumNameContextAttrs<'input> for EnumNameContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumName(&mut self,)
	-> Result<Rc<EnumNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_enumName);
        let mut _localctx: Rc<EnumNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1153);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumSpecifier ----------------
pub type EnumSpecifierContextAll<'input> = EnumSpecifierContext<'input>;


pub type EnumSpecifierContext<'input> = BaseParserRuleContext<'input,EnumSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct EnumSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for EnumSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for EnumSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_enumSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumSpecifier }
}
antlr_rust::tid!{EnumSpecifierContextExt<'a>}

impl<'input> EnumSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<EnumSpecifierContextExt<'input>>{

fn enumHead(&self) -> Option<Rc<EnumHeadContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftBrace
/// Returns `None` if there is no child corresponding to token LeftBrace
fn LeftBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBrace, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBrace
/// Returns `None` if there is no child corresponding to token RightBrace
fn RightBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBrace, 0)
}
fn enumeratorList(&self) -> Option<Rc<EnumeratorListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Comma
/// Returns `None` if there is no child corresponding to token Comma
fn Comma(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, 0)
}

}

impl<'input> EnumSpecifierContextAttrs<'input> for EnumSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumSpecifier(&mut self,)
	-> Result<Rc<EnumSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_enumSpecifier);
        let mut _localctx: Rc<EnumSpecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule enumHead*/
			recog.base.set_state(1155);
			recog.enumHead()?;

			recog.base.set_state(1156);
			recog.base.match_token(LeftBrace,&mut recog.err_handler)?;

			recog.base.set_state(1161);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Identifier {
				{
				/*InvokeRule enumeratorList*/
				recog.base.set_state(1157);
				recog.enumeratorList()?;

				recog.base.set_state(1159);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==Comma {
					{
					recog.base.set_state(1158);
					recog.base.match_token(Comma,&mut recog.err_handler)?;

					}
				}

				}
			}

			recog.base.set_state(1163);
			recog.base.match_token(RightBrace,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumHead ----------------
pub type EnumHeadContextAll<'input> = EnumHeadContext<'input>;


pub type EnumHeadContext<'input> = BaseParserRuleContext<'input,EnumHeadContextExt<'input>>;

#[derive(Clone)]
pub struct EnumHeadContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for EnumHeadContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for EnumHeadContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumHead(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_enumHead(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumHeadContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumHead }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumHead }
}
antlr_rust::tid!{EnumHeadContextExt<'a>}

impl<'input> EnumHeadContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumHeadContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumHeadContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumHeadContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<EnumHeadContextExt<'input>>{

fn enumkey(&self) -> Option<Rc<EnumkeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn enumbase(&self) -> Option<Rc<EnumbaseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumHeadContextAttrs<'input> for EnumHeadContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumHead(&mut self,)
	-> Result<Rc<EnumHeadContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumHeadContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_enumHead);
        let mut _localctx: Rc<EnumHeadContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule enumkey*/
			recog.base.set_state(1165);
			recog.enumkey()?;

			recog.base.set_state(1167);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Alignas || _la==LeftBracket {
				{
				/*InvokeRule attributeSpecifierSeq*/
				recog.base.set_state(1166);
				recog.attributeSpecifierSeq()?;

				}
			}

			recog.base.set_state(1173);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Decltype || _la==Doublecolon || _la==Identifier {
				{
				recog.base.set_state(1170);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(125,&mut recog.base)? {
					x if x == 1=>{
						{
						/*InvokeRule nestedNameSpecifier*/
						recog.base.set_state(1169);
						recog.nestedNameSpecifier_rec(0)?;

						}
					}

					_ => {}
				}
				recog.base.set_state(1172);
				recog.base.match_token(Identifier,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1176);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Colon {
				{
				/*InvokeRule enumbase*/
				recog.base.set_state(1175);
				recog.enumbase()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- opaqueEnumDeclaration ----------------
pub type OpaqueEnumDeclarationContextAll<'input> = OpaqueEnumDeclarationContext<'input>;


pub type OpaqueEnumDeclarationContext<'input> = BaseParserRuleContext<'input,OpaqueEnumDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct OpaqueEnumDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for OpaqueEnumDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for OpaqueEnumDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_opaqueEnumDeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_opaqueEnumDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for OpaqueEnumDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_opaqueEnumDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_opaqueEnumDeclaration }
}
antlr_rust::tid!{OpaqueEnumDeclarationContextExt<'a>}

impl<'input> OpaqueEnumDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OpaqueEnumDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OpaqueEnumDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OpaqueEnumDeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<OpaqueEnumDeclarationContextExt<'input>>{

fn enumkey(&self) -> Option<Rc<EnumkeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enumbase(&self) -> Option<Rc<EnumbaseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OpaqueEnumDeclarationContextAttrs<'input> for OpaqueEnumDeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn opaqueEnumDeclaration(&mut self,)
	-> Result<Rc<OpaqueEnumDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OpaqueEnumDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_opaqueEnumDeclaration);
        let mut _localctx: Rc<OpaqueEnumDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule enumkey*/
			recog.base.set_state(1178);
			recog.enumkey()?;

			recog.base.set_state(1180);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Alignas || _la==LeftBracket {
				{
				/*InvokeRule attributeSpecifierSeq*/
				recog.base.set_state(1179);
				recog.attributeSpecifierSeq()?;

				}
			}

			recog.base.set_state(1182);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(1184);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Colon {
				{
				/*InvokeRule enumbase*/
				recog.base.set_state(1183);
				recog.enumbase()?;

				}
			}

			recog.base.set_state(1186);
			recog.base.match_token(Semi,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumkey ----------------
pub type EnumkeyContextAll<'input> = EnumkeyContext<'input>;


pub type EnumkeyContext<'input> = BaseParserRuleContext<'input,EnumkeyContextExt<'input>>;

#[derive(Clone)]
pub struct EnumkeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for EnumkeyContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for EnumkeyContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumkey(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_enumkey(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumkeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumkey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumkey }
}
antlr_rust::tid!{EnumkeyContextExt<'a>}

impl<'input> EnumkeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumkeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumkeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumkeyContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<EnumkeyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Enum
/// Returns `None` if there is no child corresponding to token Enum
fn Enum(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Enum, 0)
}
/// Retrieves first TerminalNode corresponding to token Class
/// Returns `None` if there is no child corresponding to token Class
fn Class(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Class, 0)
}
/// Retrieves first TerminalNode corresponding to token Struct
/// Returns `None` if there is no child corresponding to token Struct
fn Struct(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Struct, 0)
}

}

impl<'input> EnumkeyContextAttrs<'input> for EnumkeyContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumkey(&mut self,)
	-> Result<Rc<EnumkeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumkeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_enumkey);
        let mut _localctx: Rc<EnumkeyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1188);
			recog.base.match_token(Enum,&mut recog.err_handler)?;

			recog.base.set_state(1190);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Class || _la==Struct {
				{
				recog.base.set_state(1189);
				_la = recog.base.input.la(1);
				if { !(_la==Class || _la==Struct) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumbase ----------------
pub type EnumbaseContextAll<'input> = EnumbaseContext<'input>;


pub type EnumbaseContext<'input> = BaseParserRuleContext<'input,EnumbaseContextExt<'input>>;

#[derive(Clone)]
pub struct EnumbaseContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for EnumbaseContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for EnumbaseContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumbase(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_enumbase(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumbaseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumbase }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumbase }
}
antlr_rust::tid!{EnumbaseContextExt<'a>}

impl<'input> EnumbaseContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumbaseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumbaseContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumbaseContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<EnumbaseContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Colon
/// Returns `None` if there is no child corresponding to token Colon
fn Colon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Colon, 0)
}
fn typeSpecifierSeq(&self) -> Option<Rc<TypeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumbaseContextAttrs<'input> for EnumbaseContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumbase(&mut self,)
	-> Result<Rc<EnumbaseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumbaseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_enumbase);
        let mut _localctx: Rc<EnumbaseContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1192);
			recog.base.match_token(Colon,&mut recog.err_handler)?;

			/*InvokeRule typeSpecifierSeq*/
			recog.base.set_state(1193);
			recog.typeSpecifierSeq()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumeratorList ----------------
pub type EnumeratorListContextAll<'input> = EnumeratorListContext<'input>;


pub type EnumeratorListContext<'input> = BaseParserRuleContext<'input,EnumeratorListContextExt<'input>>;

#[derive(Clone)]
pub struct EnumeratorListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for EnumeratorListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for EnumeratorListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumeratorList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_enumeratorList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumeratorListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumeratorList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumeratorList }
}
antlr_rust::tid!{EnumeratorListContextExt<'a>}

impl<'input> EnumeratorListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumeratorListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumeratorListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumeratorListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<EnumeratorListContextExt<'input>>{

fn enumeratorDefinition_all(&self) ->  Vec<Rc<EnumeratorDefinitionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn enumeratorDefinition(&self, i: usize) -> Option<Rc<EnumeratorDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}

}

impl<'input> EnumeratorListContextAttrs<'input> for EnumeratorListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumeratorList(&mut self,)
	-> Result<Rc<EnumeratorListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumeratorListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_enumeratorList);
        let mut _localctx: Rc<EnumeratorListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule enumeratorDefinition*/
			recog.base.set_state(1195);
			recog.enumeratorDefinition()?;

			recog.base.set_state(1200);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(131,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1196);
					recog.base.match_token(Comma,&mut recog.err_handler)?;

					/*InvokeRule enumeratorDefinition*/
					recog.base.set_state(1197);
					recog.enumeratorDefinition()?;

					}
					} 
				}
				recog.base.set_state(1202);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(131,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumeratorDefinition ----------------
pub type EnumeratorDefinitionContextAll<'input> = EnumeratorDefinitionContext<'input>;


pub type EnumeratorDefinitionContext<'input> = BaseParserRuleContext<'input,EnumeratorDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct EnumeratorDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for EnumeratorDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for EnumeratorDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumeratorDefinition(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_enumeratorDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumeratorDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumeratorDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumeratorDefinition }
}
antlr_rust::tid!{EnumeratorDefinitionContextExt<'a>}

impl<'input> EnumeratorDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumeratorDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumeratorDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumeratorDefinitionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<EnumeratorDefinitionContextExt<'input>>{

fn enumerator(&self) -> Option<Rc<EnumeratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumeratorDefinitionContextAttrs<'input> for EnumeratorDefinitionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumeratorDefinition(&mut self,)
	-> Result<Rc<EnumeratorDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumeratorDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_enumeratorDefinition);
        let mut _localctx: Rc<EnumeratorDefinitionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule enumerator*/
			recog.base.set_state(1203);
			recog.enumerator()?;

			recog.base.set_state(1206);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Assign {
				{
				recog.base.set_state(1204);
				recog.base.match_token(Assign,&mut recog.err_handler)?;

				/*InvokeRule constantExpression*/
				recog.base.set_state(1205);
				recog.constantExpression()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumerator ----------------
pub type EnumeratorContextAll<'input> = EnumeratorContext<'input>;


pub type EnumeratorContext<'input> = BaseParserRuleContext<'input,EnumeratorContextExt<'input>>;

#[derive(Clone)]
pub struct EnumeratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for EnumeratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for EnumeratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumerator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_enumerator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumeratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumerator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumerator }
}
antlr_rust::tid!{EnumeratorContextExt<'a>}

impl<'input> EnumeratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumeratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumeratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumeratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<EnumeratorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> EnumeratorContextAttrs<'input> for EnumeratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumerator(&mut self,)
	-> Result<Rc<EnumeratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumeratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_enumerator);
        let mut _localctx: Rc<EnumeratorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1208);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- namespaceName ----------------
pub type NamespaceNameContextAll<'input> = NamespaceNameContext<'input>;


pub type NamespaceNameContext<'input> = BaseParserRuleContext<'input,NamespaceNameContextExt<'input>>;

#[derive(Clone)]
pub struct NamespaceNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NamespaceNameContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NamespaceNameContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_namespaceName(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_namespaceName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NamespaceNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_namespaceName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_namespaceName }
}
antlr_rust::tid!{NamespaceNameContextExt<'a>}

impl<'input> NamespaceNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NamespaceNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NamespaceNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NamespaceNameContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NamespaceNameContextExt<'input>>{

fn originalNamespaceName(&self) -> Option<Rc<OriginalNamespaceNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn namespaceAlias(&self) -> Option<Rc<NamespaceAliasContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NamespaceNameContextAttrs<'input> for NamespaceNameContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn namespaceName(&mut self,)
	-> Result<Rc<NamespaceNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NamespaceNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_namespaceName);
        let mut _localctx: Rc<NamespaceNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1212);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(133,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule originalNamespaceName*/
					recog.base.set_state(1210);
					recog.originalNamespaceName()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule namespaceAlias*/
					recog.base.set_state(1211);
					recog.namespaceAlias()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- originalNamespaceName ----------------
pub type OriginalNamespaceNameContextAll<'input> = OriginalNamespaceNameContext<'input>;


pub type OriginalNamespaceNameContext<'input> = BaseParserRuleContext<'input,OriginalNamespaceNameContextExt<'input>>;

#[derive(Clone)]
pub struct OriginalNamespaceNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for OriginalNamespaceNameContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for OriginalNamespaceNameContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_originalNamespaceName(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_originalNamespaceName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for OriginalNamespaceNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_originalNamespaceName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_originalNamespaceName }
}
antlr_rust::tid!{OriginalNamespaceNameContextExt<'a>}

impl<'input> OriginalNamespaceNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OriginalNamespaceNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OriginalNamespaceNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OriginalNamespaceNameContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<OriginalNamespaceNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> OriginalNamespaceNameContextAttrs<'input> for OriginalNamespaceNameContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn originalNamespaceName(&mut self,)
	-> Result<Rc<OriginalNamespaceNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OriginalNamespaceNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_originalNamespaceName);
        let mut _localctx: Rc<OriginalNamespaceNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1214);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- namespaceDefinition ----------------
pub type NamespaceDefinitionContextAll<'input> = NamespaceDefinitionContext<'input>;


pub type NamespaceDefinitionContext<'input> = BaseParserRuleContext<'input,NamespaceDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct NamespaceDefinitionContextExt<'input>{
	pub namespaceBody: Option<Rc<DeclarationseqContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NamespaceDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NamespaceDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_namespaceDefinition(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_namespaceDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NamespaceDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_namespaceDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_namespaceDefinition }
}
antlr_rust::tid!{NamespaceDefinitionContextExt<'a>}

impl<'input> NamespaceDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NamespaceDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NamespaceDefinitionContextExt{
				namespaceBody: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait NamespaceDefinitionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NamespaceDefinitionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Namespace
/// Returns `None` if there is no child corresponding to token Namespace
fn Namespace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Namespace, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftBrace
/// Returns `None` if there is no child corresponding to token LeftBrace
fn LeftBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBrace, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBrace
/// Returns `None` if there is no child corresponding to token RightBrace
fn RightBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBrace, 0)
}
/// Retrieves first TerminalNode corresponding to token Inline
/// Returns `None` if there is no child corresponding to token Inline
fn Inline(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Inline, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn originalNamespaceName(&self) -> Option<Rc<OriginalNamespaceNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn declarationseq(&self) -> Option<Rc<DeclarationseqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NamespaceDefinitionContextAttrs<'input> for NamespaceDefinitionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn namespaceDefinition(&mut self,)
	-> Result<Rc<NamespaceDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NamespaceDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_namespaceDefinition);
        let mut _localctx: Rc<NamespaceDefinitionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1217);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Inline {
				{
				recog.base.set_state(1216);
				recog.base.match_token(Inline,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1219);
			recog.base.match_token(Namespace,&mut recog.err_handler)?;

			recog.base.set_state(1222);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(135,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1220);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}

				x if x == 2=>{
					{
					/*InvokeRule originalNamespaceName*/
					recog.base.set_state(1221);
					recog.originalNamespaceName()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1224);
			recog.base.match_token(LeftBrace,&mut recog.err_handler)?;

			recog.base.set_state(1226);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 10)) & !0x3f) == 0 && ((1usize << (_la - 10)) & ((1usize << (Alignas - 10)) | (1usize << (Asm - 10)) | (1usize << (Auto - 10)) | (1usize << (Bool - 10)) | (1usize << (Char - 10)) | (1usize << (Char16 - 10)) | (1usize << (Char32 - 10)) | (1usize << (Class - 10)) | (1usize << (Const - 10)) | (1usize << (Constexpr - 10)) | (1usize << (Decltype - 10)) | (1usize << (Double - 10)) | (1usize << (Enum - 10)) | (1usize << (Explicit - 10)) | (1usize << (Extern - 10)) | (1usize << (Float - 10)) | (1usize << (Friend - 10)))) != 0) || ((((_la - 44)) & !0x3f) == 0 && ((1usize << (_la - 44)) & ((1usize << (Inline - 44)) | (1usize << (Int - 44)) | (1usize << (Long - 44)) | (1usize << (Mutable - 44)) | (1usize << (Namespace - 44)) | (1usize << (Operator - 44)) | (1usize << (Register - 44)) | (1usize << (Short - 44)) | (1usize << (Signed - 44)) | (1usize << (Static - 44)) | (1usize << (Static_assert - 44)) | (1usize << (Struct - 44)) | (1usize << (Template - 44)) | (1usize << (Thread_local - 44)) | (1usize << (Typedef - 44)))) != 0) || ((((_la - 76)) & !0x3f) == 0 && ((1usize << (_la - 76)) & ((1usize << (Typename_ - 76)) | (1usize << (Union - 76)) | (1usize << (Unsigned - 76)) | (1usize << (Using - 76)) | (1usize << (Virtual - 76)) | (1usize << (Void - 76)) | (1usize << (Volatile - 76)) | (1usize << (Wchar - 76)) | (1usize << (LeftParen - 76)) | (1usize << (LeftBracket - 76)) | (1usize << (Star - 76)) | (1usize << (And - 76)) | (1usize << (Tilde - 76)))) != 0) || ((((_la - 118)) & !0x3f) == 0 && ((1usize << (_la - 118)) & ((1usize << (AndAnd - 118)) | (1usize << (Doublecolon - 118)) | (1usize << (Semi - 118)) | (1usize << (Ellipsis - 118)) | (1usize << (Identifier - 118)))) != 0) {
				{
				/*InvokeRule declarationseq*/
				recog.base.set_state(1225);
				let tmp = recog.declarationseq()?;
				 cast_mut::<_,NamespaceDefinitionContext >(&mut _localctx).namespaceBody = Some(tmp.clone());
				  

				}
			}

			recog.base.set_state(1228);
			recog.base.match_token(RightBrace,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- namespaceAlias ----------------
pub type NamespaceAliasContextAll<'input> = NamespaceAliasContext<'input>;


pub type NamespaceAliasContext<'input> = BaseParserRuleContext<'input,NamespaceAliasContextExt<'input>>;

#[derive(Clone)]
pub struct NamespaceAliasContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NamespaceAliasContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NamespaceAliasContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_namespaceAlias(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_namespaceAlias(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NamespaceAliasContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_namespaceAlias }
	//fn type_rule_index() -> usize where Self: Sized { RULE_namespaceAlias }
}
antlr_rust::tid!{NamespaceAliasContextExt<'a>}

impl<'input> NamespaceAliasContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NamespaceAliasContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NamespaceAliasContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NamespaceAliasContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NamespaceAliasContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> NamespaceAliasContextAttrs<'input> for NamespaceAliasContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn namespaceAlias(&mut self,)
	-> Result<Rc<NamespaceAliasContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NamespaceAliasContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_namespaceAlias);
        let mut _localctx: Rc<NamespaceAliasContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1230);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- namespaceAliasDefinition ----------------
pub type NamespaceAliasDefinitionContextAll<'input> = NamespaceAliasDefinitionContext<'input>;


pub type NamespaceAliasDefinitionContext<'input> = BaseParserRuleContext<'input,NamespaceAliasDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct NamespaceAliasDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NamespaceAliasDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NamespaceAliasDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_namespaceAliasDefinition(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_namespaceAliasDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NamespaceAliasDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_namespaceAliasDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_namespaceAliasDefinition }
}
antlr_rust::tid!{NamespaceAliasDefinitionContextExt<'a>}

impl<'input> NamespaceAliasDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NamespaceAliasDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NamespaceAliasDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NamespaceAliasDefinitionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NamespaceAliasDefinitionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Namespace
/// Returns `None` if there is no child corresponding to token Namespace
fn Namespace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Namespace, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}
fn qualifiednamespacespecifier(&self) -> Option<Rc<QualifiednamespacespecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}

}

impl<'input> NamespaceAliasDefinitionContextAttrs<'input> for NamespaceAliasDefinitionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn namespaceAliasDefinition(&mut self,)
	-> Result<Rc<NamespaceAliasDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NamespaceAliasDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_namespaceAliasDefinition);
        let mut _localctx: Rc<NamespaceAliasDefinitionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1232);
			recog.base.match_token(Namespace,&mut recog.err_handler)?;

			recog.base.set_state(1233);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(1234);
			recog.base.match_token(Assign,&mut recog.err_handler)?;

			/*InvokeRule qualifiednamespacespecifier*/
			recog.base.set_state(1235);
			recog.qualifiednamespacespecifier()?;

			recog.base.set_state(1236);
			recog.base.match_token(Semi,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- qualifiednamespacespecifier ----------------
pub type QualifiednamespacespecifierContextAll<'input> = QualifiednamespacespecifierContext<'input>;


pub type QualifiednamespacespecifierContext<'input> = BaseParserRuleContext<'input,QualifiednamespacespecifierContextExt<'input>>;

#[derive(Clone)]
pub struct QualifiednamespacespecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for QualifiednamespacespecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for QualifiednamespacespecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_qualifiednamespacespecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_qualifiednamespacespecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for QualifiednamespacespecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_qualifiednamespacespecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_qualifiednamespacespecifier }
}
antlr_rust::tid!{QualifiednamespacespecifierContextExt<'a>}

impl<'input> QualifiednamespacespecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QualifiednamespacespecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QualifiednamespacespecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait QualifiednamespacespecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<QualifiednamespacespecifierContextExt<'input>>{

fn namespaceName(&self) -> Option<Rc<NamespaceNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> QualifiednamespacespecifierContextAttrs<'input> for QualifiednamespacespecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn qualifiednamespacespecifier(&mut self,)
	-> Result<Rc<QualifiednamespacespecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QualifiednamespacespecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_qualifiednamespacespecifier);
        let mut _localctx: Rc<QualifiednamespacespecifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1239);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(137,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule nestedNameSpecifier*/
					recog.base.set_state(1238);
					recog.nestedNameSpecifier_rec(0)?;

					}
				}

				_ => {}
			}
			/*InvokeRule namespaceName*/
			recog.base.set_state(1241);
			recog.namespaceName()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- usingDeclaration ----------------
pub type UsingDeclarationContextAll<'input> = UsingDeclarationContext<'input>;


pub type UsingDeclarationContext<'input> = BaseParserRuleContext<'input,UsingDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct UsingDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for UsingDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for UsingDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_usingDeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_usingDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UsingDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_usingDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_usingDeclaration }
}
antlr_rust::tid!{UsingDeclarationContextExt<'a>}

impl<'input> UsingDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UsingDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UsingDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UsingDeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<UsingDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Using
/// Returns `None` if there is no child corresponding to token Using
fn Using(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Using, 0)
}
fn unqualifiedId(&self) -> Option<Rc<UnqualifiedIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Doublecolon
/// Returns `None` if there is no child corresponding to token Doublecolon
fn Doublecolon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Doublecolon, 0)
}
/// Retrieves first TerminalNode corresponding to token Typename_
/// Returns `None` if there is no child corresponding to token Typename_
fn Typename_(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Typename_, 0)
}

}

impl<'input> UsingDeclarationContextAttrs<'input> for UsingDeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn usingDeclaration(&mut self,)
	-> Result<Rc<UsingDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UsingDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_usingDeclaration);
        let mut _localctx: Rc<UsingDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1243);
			recog.base.match_token(Using,&mut recog.err_handler)?;

			recog.base.set_state(1249);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(139,&mut recog.base)? {
				1 =>{
					{
					recog.base.set_state(1245);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Typename_ {
						{
						recog.base.set_state(1244);
						recog.base.match_token(Typename_,&mut recog.err_handler)?;

						}
					}

					/*InvokeRule nestedNameSpecifier*/
					recog.base.set_state(1247);
					recog.nestedNameSpecifier_rec(0)?;

					}
				}
			,
				2 =>{
					{
					recog.base.set_state(1248);
					recog.base.match_token(Doublecolon,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule unqualifiedId*/
			recog.base.set_state(1251);
			recog.unqualifiedId()?;

			recog.base.set_state(1252);
			recog.base.match_token(Semi,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- usingDirective ----------------
pub type UsingDirectiveContextAll<'input> = UsingDirectiveContext<'input>;


pub type UsingDirectiveContext<'input> = BaseParserRuleContext<'input,UsingDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct UsingDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for UsingDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for UsingDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_usingDirective(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_usingDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UsingDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_usingDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_usingDirective }
}
antlr_rust::tid!{UsingDirectiveContextExt<'a>}

impl<'input> UsingDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UsingDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UsingDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UsingDirectiveContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<UsingDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Using
/// Returns `None` if there is no child corresponding to token Using
fn Using(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Using, 0)
}
/// Retrieves first TerminalNode corresponding to token Namespace
/// Returns `None` if there is no child corresponding to token Namespace
fn Namespace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Namespace, 0)
}
fn namespaceName(&self) -> Option<Rc<NamespaceNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UsingDirectiveContextAttrs<'input> for UsingDirectiveContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn usingDirective(&mut self,)
	-> Result<Rc<UsingDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UsingDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_usingDirective);
        let mut _localctx: Rc<UsingDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1255);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Alignas || _la==LeftBracket {
				{
				/*InvokeRule attributeSpecifierSeq*/
				recog.base.set_state(1254);
				recog.attributeSpecifierSeq()?;

				}
			}

			recog.base.set_state(1257);
			recog.base.match_token(Using,&mut recog.err_handler)?;

			recog.base.set_state(1258);
			recog.base.match_token(Namespace,&mut recog.err_handler)?;

			recog.base.set_state(1260);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(141,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule nestedNameSpecifier*/
					recog.base.set_state(1259);
					recog.nestedNameSpecifier_rec(0)?;

					}
				}

				_ => {}
			}
			/*InvokeRule namespaceName*/
			recog.base.set_state(1262);
			recog.namespaceName()?;

			recog.base.set_state(1263);
			recog.base.match_token(Semi,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- asmDefinition ----------------
pub type AsmDefinitionContextAll<'input> = AsmDefinitionContext<'input>;


pub type AsmDefinitionContext<'input> = BaseParserRuleContext<'input,AsmDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct AsmDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AsmDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AsmDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_asmDefinition(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_asmDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AsmDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_asmDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_asmDefinition }
}
antlr_rust::tid!{AsmDefinitionContextExt<'a>}

impl<'input> AsmDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AsmDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AsmDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AsmDefinitionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AsmDefinitionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Asm
/// Returns `None` if there is no child corresponding to token Asm
fn Asm(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Asm, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
/// Retrieves first TerminalNode corresponding to token StringLiteral
/// Returns `None` if there is no child corresponding to token StringLiteral
fn StringLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(StringLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}

}

impl<'input> AsmDefinitionContextAttrs<'input> for AsmDefinitionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn asmDefinition(&mut self,)
	-> Result<Rc<AsmDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AsmDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_asmDefinition);
        let mut _localctx: Rc<AsmDefinitionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1265);
			recog.base.match_token(Asm,&mut recog.err_handler)?;

			recog.base.set_state(1266);
			recog.base.match_token(LeftParen,&mut recog.err_handler)?;

			recog.base.set_state(1267);
			recog.base.match_token(StringLiteral,&mut recog.err_handler)?;

			recog.base.set_state(1268);
			recog.base.match_token(RightParen,&mut recog.err_handler)?;

			recog.base.set_state(1269);
			recog.base.match_token(Semi,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- linkageSpecification ----------------
pub type LinkageSpecificationContextAll<'input> = LinkageSpecificationContext<'input>;


pub type LinkageSpecificationContext<'input> = BaseParserRuleContext<'input,LinkageSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct LinkageSpecificationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for LinkageSpecificationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for LinkageSpecificationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_linkageSpecification(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_linkageSpecification(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LinkageSpecificationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_linkageSpecification }
	//fn type_rule_index() -> usize where Self: Sized { RULE_linkageSpecification }
}
antlr_rust::tid!{LinkageSpecificationContextExt<'a>}

impl<'input> LinkageSpecificationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LinkageSpecificationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LinkageSpecificationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LinkageSpecificationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<LinkageSpecificationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Extern
/// Returns `None` if there is no child corresponding to token Extern
fn Extern(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Extern, 0)
}
/// Retrieves first TerminalNode corresponding to token StringLiteral
/// Returns `None` if there is no child corresponding to token StringLiteral
fn StringLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(StringLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftBrace
/// Returns `None` if there is no child corresponding to token LeftBrace
fn LeftBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBrace, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBrace
/// Returns `None` if there is no child corresponding to token RightBrace
fn RightBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBrace, 0)
}
fn declaration(&self) -> Option<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn declarationseq(&self) -> Option<Rc<DeclarationseqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LinkageSpecificationContextAttrs<'input> for LinkageSpecificationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn linkageSpecification(&mut self,)
	-> Result<Rc<LinkageSpecificationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LinkageSpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_linkageSpecification);
        let mut _localctx: Rc<LinkageSpecificationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1271);
			recog.base.match_token(Extern,&mut recog.err_handler)?;

			recog.base.set_state(1272);
			recog.base.match_token(StringLiteral,&mut recog.err_handler)?;

			recog.base.set_state(1279);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LeftBrace 
				=> {
					{
					recog.base.set_state(1273);
					recog.base.match_token(LeftBrace,&mut recog.err_handler)?;

					recog.base.set_state(1275);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if ((((_la - 10)) & !0x3f) == 0 && ((1usize << (_la - 10)) & ((1usize << (Alignas - 10)) | (1usize << (Asm - 10)) | (1usize << (Auto - 10)) | (1usize << (Bool - 10)) | (1usize << (Char - 10)) | (1usize << (Char16 - 10)) | (1usize << (Char32 - 10)) | (1usize << (Class - 10)) | (1usize << (Const - 10)) | (1usize << (Constexpr - 10)) | (1usize << (Decltype - 10)) | (1usize << (Double - 10)) | (1usize << (Enum - 10)) | (1usize << (Explicit - 10)) | (1usize << (Extern - 10)) | (1usize << (Float - 10)) | (1usize << (Friend - 10)))) != 0) || ((((_la - 44)) & !0x3f) == 0 && ((1usize << (_la - 44)) & ((1usize << (Inline - 44)) | (1usize << (Int - 44)) | (1usize << (Long - 44)) | (1usize << (Mutable - 44)) | (1usize << (Namespace - 44)) | (1usize << (Operator - 44)) | (1usize << (Register - 44)) | (1usize << (Short - 44)) | (1usize << (Signed - 44)) | (1usize << (Static - 44)) | (1usize << (Static_assert - 44)) | (1usize << (Struct - 44)) | (1usize << (Template - 44)) | (1usize << (Thread_local - 44)) | (1usize << (Typedef - 44)))) != 0) || ((((_la - 76)) & !0x3f) == 0 && ((1usize << (_la - 76)) & ((1usize << (Typename_ - 76)) | (1usize << (Union - 76)) | (1usize << (Unsigned - 76)) | (1usize << (Using - 76)) | (1usize << (Virtual - 76)) | (1usize << (Void - 76)) | (1usize << (Volatile - 76)) | (1usize << (Wchar - 76)) | (1usize << (LeftParen - 76)) | (1usize << (LeftBracket - 76)) | (1usize << (Star - 76)) | (1usize << (And - 76)) | (1usize << (Tilde - 76)))) != 0) || ((((_la - 118)) & !0x3f) == 0 && ((1usize << (_la - 118)) & ((1usize << (AndAnd - 118)) | (1usize << (Doublecolon - 118)) | (1usize << (Semi - 118)) | (1usize << (Ellipsis - 118)) | (1usize << (Identifier - 118)))) != 0) {
						{
						/*InvokeRule declarationseq*/
						recog.base.set_state(1274);
						recog.declarationseq()?;

						}
					}

					recog.base.set_state(1277);
					recog.base.match_token(RightBrace,&mut recog.err_handler)?;

					}
				}

			 Alignas | Asm | Auto | Bool | Char | Char16 | Char32 | Class | Const |
			 Constexpr | Decltype | Double | Enum | Explicit | Extern | Float | Friend |
			 Inline | Int | Long | Mutable | Namespace | Operator | Register | Short |
			 Signed | Static | Static_assert | Struct | Template | Thread_local |
			 Typedef | Typename_ | Union | Unsigned | Using | Virtual | Void | Volatile |
			 Wchar | LeftParen | LeftBracket | Star | And | Tilde | AndAnd | Doublecolon |
			 Semi | Ellipsis | Identifier 
				=> {
					{
					/*InvokeRule declaration*/
					recog.base.set_state(1278);
					recog.declaration()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- attributeSpecifierSeq ----------------
pub type AttributeSpecifierSeqContextAll<'input> = AttributeSpecifierSeqContext<'input>;


pub type AttributeSpecifierSeqContext<'input> = BaseParserRuleContext<'input,AttributeSpecifierSeqContextExt<'input>>;

#[derive(Clone)]
pub struct AttributeSpecifierSeqContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AttributeSpecifierSeqContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AttributeSpecifierSeqContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_attributeSpecifierSeq(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_attributeSpecifierSeq(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AttributeSpecifierSeqContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_attributeSpecifierSeq }
	//fn type_rule_index() -> usize where Self: Sized { RULE_attributeSpecifierSeq }
}
antlr_rust::tid!{AttributeSpecifierSeqContextExt<'a>}

impl<'input> AttributeSpecifierSeqContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AttributeSpecifierSeqContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AttributeSpecifierSeqContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AttributeSpecifierSeqContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AttributeSpecifierSeqContextExt<'input>>{

fn attributeSpecifier_all(&self) ->  Vec<Rc<AttributeSpecifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn attributeSpecifier(&self, i: usize) -> Option<Rc<AttributeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AttributeSpecifierSeqContextAttrs<'input> for AttributeSpecifierSeqContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn attributeSpecifierSeq(&mut self,)
	-> Result<Rc<AttributeSpecifierSeqContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AttributeSpecifierSeqContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_attributeSpecifierSeq);
        let mut _localctx: Rc<AttributeSpecifierSeqContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1282); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule attributeSpecifier*/
					recog.base.set_state(1281);
					recog.attributeSpecifier()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(1284); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(144,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- attributeSpecifier ----------------
pub type AttributeSpecifierContextAll<'input> = AttributeSpecifierContext<'input>;


pub type AttributeSpecifierContext<'input> = BaseParserRuleContext<'input,AttributeSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct AttributeSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AttributeSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AttributeSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_attributeSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_attributeSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AttributeSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_attributeSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_attributeSpecifier }
}
antlr_rust::tid!{AttributeSpecifierContextExt<'a>}

impl<'input> AttributeSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AttributeSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AttributeSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AttributeSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AttributeSpecifierContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token LeftBracket in current rule
fn LeftBracket_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LeftBracket, starting from 0.
/// Returns `None` if number of children corresponding to token LeftBracket is less or equal than `i`.
fn LeftBracket(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBracket, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RightBracket in current rule
fn RightBracket_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RightBracket, starting from 0.
/// Returns `None` if number of children corresponding to token RightBracket is less or equal than `i`.
fn RightBracket(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBracket, i)
}
fn attributeList(&self) -> Option<Rc<AttributeListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn alignmentspecifier(&self) -> Option<Rc<AlignmentspecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AttributeSpecifierContextAttrs<'input> for AttributeSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn attributeSpecifier(&mut self,)
	-> Result<Rc<AttributeSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AttributeSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_attributeSpecifier);
        let mut _localctx: Rc<AttributeSpecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1294);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LeftBracket 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1286);
					recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

					recog.base.set_state(1287);
					recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

					recog.base.set_state(1289);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Identifier {
						{
						/*InvokeRule attributeList*/
						recog.base.set_state(1288);
						recog.attributeList()?;

						}
					}

					recog.base.set_state(1291);
					recog.base.match_token(RightBracket,&mut recog.err_handler)?;

					recog.base.set_state(1292);
					recog.base.match_token(RightBracket,&mut recog.err_handler)?;

					}
				}

			 Alignas 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule alignmentspecifier*/
					recog.base.set_state(1293);
					recog.alignmentspecifier()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- alignmentspecifier ----------------
pub type AlignmentspecifierContextAll<'input> = AlignmentspecifierContext<'input>;


pub type AlignmentspecifierContext<'input> = BaseParserRuleContext<'input,AlignmentspecifierContextExt<'input>>;

#[derive(Clone)]
pub struct AlignmentspecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AlignmentspecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AlignmentspecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_alignmentspecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_alignmentspecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AlignmentspecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_alignmentspecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_alignmentspecifier }
}
antlr_rust::tid!{AlignmentspecifierContextExt<'a>}

impl<'input> AlignmentspecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AlignmentspecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AlignmentspecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AlignmentspecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AlignmentspecifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Alignas
/// Returns `None` if there is no child corresponding to token Alignas
fn Alignas(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Alignas, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn theTypeId(&self) -> Option<Rc<TheTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Ellipsis
/// Returns `None` if there is no child corresponding to token Ellipsis
fn Ellipsis(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, 0)
}

}

impl<'input> AlignmentspecifierContextAttrs<'input> for AlignmentspecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn alignmentspecifier(&mut self,)
	-> Result<Rc<AlignmentspecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AlignmentspecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_alignmentspecifier);
        let mut _localctx: Rc<AlignmentspecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1296);
			recog.base.match_token(Alignas,&mut recog.err_handler)?;

			recog.base.set_state(1297);
			recog.base.match_token(LeftParen,&mut recog.err_handler)?;

			recog.base.set_state(1300);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(147,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule theTypeId*/
					recog.base.set_state(1298);
					recog.theTypeId()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule constantExpression*/
					recog.base.set_state(1299);
					recog.constantExpression()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1303);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Ellipsis {
				{
				recog.base.set_state(1302);
				recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1305);
			recog.base.match_token(RightParen,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- attributeList ----------------
pub type AttributeListContextAll<'input> = AttributeListContext<'input>;


pub type AttributeListContext<'input> = BaseParserRuleContext<'input,AttributeListContextExt<'input>>;

#[derive(Clone)]
pub struct AttributeListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AttributeListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AttributeListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_attributeList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_attributeList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AttributeListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_attributeList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_attributeList }
}
antlr_rust::tid!{AttributeListContextExt<'a>}

impl<'input> AttributeListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AttributeListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AttributeListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AttributeListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AttributeListContextExt<'input>>{

fn attribute_all(&self) ->  Vec<Rc<AttributeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn attribute(&self, i: usize) -> Option<Rc<AttributeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}
/// Retrieves first TerminalNode corresponding to token Ellipsis
/// Returns `None` if there is no child corresponding to token Ellipsis
fn Ellipsis(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, 0)
}

}

impl<'input> AttributeListContextAttrs<'input> for AttributeListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn attributeList(&mut self,)
	-> Result<Rc<AttributeListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AttributeListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_attributeList);
        let mut _localctx: Rc<AttributeListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule attribute*/
			recog.base.set_state(1307);
			recog.attribute()?;

			recog.base.set_state(1312);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Comma {
				{
				{
				recog.base.set_state(1308);
				recog.base.match_token(Comma,&mut recog.err_handler)?;

				/*InvokeRule attribute*/
				recog.base.set_state(1309);
				recog.attribute()?;

				}
				}
				recog.base.set_state(1314);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1316);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Ellipsis {
				{
				recog.base.set_state(1315);
				recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- attribute ----------------
pub type AttributeContextAll<'input> = AttributeContext<'input>;


pub type AttributeContext<'input> = BaseParserRuleContext<'input,AttributeContextExt<'input>>;

#[derive(Clone)]
pub struct AttributeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AttributeContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AttributeContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_attribute(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_attribute(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AttributeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_attribute }
	//fn type_rule_index() -> usize where Self: Sized { RULE_attribute }
}
antlr_rust::tid!{AttributeContextExt<'a>}

impl<'input> AttributeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AttributeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AttributeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AttributeContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AttributeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn attributeNamespace(&self) -> Option<Rc<AttributeNamespaceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Doublecolon
/// Returns `None` if there is no child corresponding to token Doublecolon
fn Doublecolon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Doublecolon, 0)
}
fn attributeArgumentClause(&self) -> Option<Rc<AttributeArgumentClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AttributeContextAttrs<'input> for AttributeContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn attribute(&mut self,)
	-> Result<Rc<AttributeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AttributeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_attribute);
        let mut _localctx: Rc<AttributeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1321);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(151,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule attributeNamespace*/
					recog.base.set_state(1318);
					recog.attributeNamespace()?;

					recog.base.set_state(1319);
					recog.base.match_token(Doublecolon,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1323);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			recog.base.set_state(1325);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LeftParen {
				{
				/*InvokeRule attributeArgumentClause*/
				recog.base.set_state(1324);
				recog.attributeArgumentClause()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- attributeNamespace ----------------
pub type AttributeNamespaceContextAll<'input> = AttributeNamespaceContext<'input>;


pub type AttributeNamespaceContext<'input> = BaseParserRuleContext<'input,AttributeNamespaceContextExt<'input>>;

#[derive(Clone)]
pub struct AttributeNamespaceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AttributeNamespaceContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AttributeNamespaceContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_attributeNamespace(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_attributeNamespace(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AttributeNamespaceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_attributeNamespace }
	//fn type_rule_index() -> usize where Self: Sized { RULE_attributeNamespace }
}
antlr_rust::tid!{AttributeNamespaceContextExt<'a>}

impl<'input> AttributeNamespaceContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AttributeNamespaceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AttributeNamespaceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AttributeNamespaceContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AttributeNamespaceContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> AttributeNamespaceContextAttrs<'input> for AttributeNamespaceContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn attributeNamespace(&mut self,)
	-> Result<Rc<AttributeNamespaceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AttributeNamespaceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_attributeNamespace);
        let mut _localctx: Rc<AttributeNamespaceContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1327);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- attributeArgumentClause ----------------
pub type AttributeArgumentClauseContextAll<'input> = AttributeArgumentClauseContext<'input>;


pub type AttributeArgumentClauseContext<'input> = BaseParserRuleContext<'input,AttributeArgumentClauseContextExt<'input>>;

#[derive(Clone)]
pub struct AttributeArgumentClauseContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AttributeArgumentClauseContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AttributeArgumentClauseContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_attributeArgumentClause(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_attributeArgumentClause(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AttributeArgumentClauseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_attributeArgumentClause }
	//fn type_rule_index() -> usize where Self: Sized { RULE_attributeArgumentClause }
}
antlr_rust::tid!{AttributeArgumentClauseContextExt<'a>}

impl<'input> AttributeArgumentClauseContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AttributeArgumentClauseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AttributeArgumentClauseContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AttributeArgumentClauseContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AttributeArgumentClauseContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn balancedTokenSeq(&self) -> Option<Rc<BalancedTokenSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AttributeArgumentClauseContextAttrs<'input> for AttributeArgumentClauseContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn attributeArgumentClause(&mut self,)
	-> Result<Rc<AttributeArgumentClauseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AttributeArgumentClauseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_attributeArgumentClause);
        let mut _localctx: Rc<AttributeArgumentClauseContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1329);
			recog.base.match_token(LeftParen,&mut recog.err_handler)?;

			recog.base.set_state(1331);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << MultiLineMacro) | (1usize << Directive) | (1usize << Alignas) | (1usize << Alignof) | (1usize << Asm) | (1usize << Auto) | (1usize << Bool) | (1usize << Break) | (1usize << Case) | (1usize << Catch) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Class) | (1usize << Const) | (1usize << Constexpr) | (1usize << Const_cast) | (1usize << Continue) | (1usize << Decltype) | (1usize << Default) | (1usize << Delete) | (1usize << Do) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (Else - 32)) | (1usize << (Enum - 32)) | (1usize << (Explicit - 32)) | (1usize << (Export - 32)) | (1usize << (Extern - 32)) | (1usize << (False_ - 32)) | (1usize << (Final - 32)) | (1usize << (Float - 32)) | (1usize << (For - 32)) | (1usize << (Friend - 32)) | (1usize << (Goto - 32)) | (1usize << (If - 32)) | (1usize << (Inline - 32)) | (1usize << (Int - 32)) | (1usize << (Long - 32)) | (1usize << (Mutable - 32)) | (1usize << (Namespace - 32)) | (1usize << (New - 32)) | (1usize << (Noexcept - 32)) | (1usize << (Nullptr - 32)) | (1usize << (Operator - 32)) | (1usize << (Override - 32)) | (1usize << (Private - 32)) | (1usize << (Protected - 32)) | (1usize << (Public - 32)) | (1usize << (Register - 32)) | (1usize << (Reinterpret_cast - 32)) | (1usize << (Return - 32)) | (1usize << (Short - 32)) | (1usize << (Signed - 32)) | (1usize << (Sizeof - 32)) | (1usize << (Static - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (Static_assert - 64)) | (1usize << (Static_cast - 64)) | (1usize << (Struct - 64)) | (1usize << (Switch - 64)) | (1usize << (Template - 64)) | (1usize << (This - 64)) | (1usize << (Thread_local - 64)) | (1usize << (Throw - 64)) | (1usize << (True_ - 64)) | (1usize << (Try - 64)) | (1usize << (Typedef - 64)) | (1usize << (Typeid_ - 64)) | (1usize << (Typename_ - 64)) | (1usize << (Union - 64)) | (1usize << (Unsigned - 64)) | (1usize << (Using - 64)) | (1usize << (Virtual - 64)) | (1usize << (Void - 64)) | (1usize << (Volatile - 64)) | (1usize << (Wchar - 64)) | (1usize << (While - 64)) | (1usize << (LeftParen - 64)) | (1usize << (LeftBracket - 64)) | (1usize << (LeftBrace - 64)) | (1usize << (Plus - 64)) | (1usize << (Minus - 64)) | (1usize << (Star - 64)) | (1usize << (Div - 64)) | (1usize << (Mod - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (Caret - 96)) | (1usize << (And - 96)) | (1usize << (Or - 96)) | (1usize << (Tilde - 96)) | (1usize << (Not - 96)) | (1usize << (Assign - 96)) | (1usize << (Less - 96)) | (1usize << (Greater - 96)) | (1usize << (PlusAssign - 96)) | (1usize << (MinusAssign - 96)) | (1usize << (StarAssign - 96)) | (1usize << (DivAssign - 96)) | (1usize << (ModAssign - 96)) | (1usize << (XorAssign - 96)) | (1usize << (AndAssign - 96)) | (1usize << (OrAssign - 96)) | (1usize << (LeftShiftAssign - 96)) | (1usize << (RightShiftAssign - 96)) | (1usize << (Equal - 96)) | (1usize << (NotEqual - 96)) | (1usize << (LessEqual - 96)) | (1usize << (GreaterEqual - 96)) | (1usize << (AndAnd - 96)) | (1usize << (OrOr - 96)) | (1usize << (PlusPlus - 96)) | (1usize << (MinusMinus - 96)) | (1usize << (Comma - 96)) | (1usize << (ArrowStar - 96)) | (1usize << (Arrow - 96)) | (1usize << (Question - 96)) | (1usize << (Colon - 96)) | (1usize << (Doublecolon - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (Semi - 128)) | (1usize << (Dot - 128)) | (1usize << (DotStar - 128)) | (1usize << (Ellipsis - 128)) | (1usize << (Identifier - 128)) | (1usize << (DecimalLiteral - 128)) | (1usize << (OctalLiteral - 128)) | (1usize << (HexadecimalLiteral - 128)) | (1usize << (BinaryLiteral - 128)) | (1usize << (Integersuffix - 128)) | (1usize << (UserDefinedIntegerLiteral - 128)) | (1usize << (UserDefinedFloatingLiteral - 128)) | (1usize << (UserDefinedStringLiteral - 128)) | (1usize << (UserDefinedCharacterLiteral - 128)) | (1usize << (Whitespace - 128)) | (1usize << (Newline - 128)) | (1usize << (BlockComment - 128)) | (1usize << (LineComment - 128)))) != 0) {
				{
				/*InvokeRule balancedTokenSeq*/
				recog.base.set_state(1330);
				recog.balancedTokenSeq()?;

				}
			}

			recog.base.set_state(1333);
			recog.base.match_token(RightParen,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- balancedTokenSeq ----------------
pub type BalancedTokenSeqContextAll<'input> = BalancedTokenSeqContext<'input>;


pub type BalancedTokenSeqContext<'input> = BaseParserRuleContext<'input,BalancedTokenSeqContextExt<'input>>;

#[derive(Clone)]
pub struct BalancedTokenSeqContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for BalancedTokenSeqContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for BalancedTokenSeqContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_balancedTokenSeq(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_balancedTokenSeq(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BalancedTokenSeqContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_balancedTokenSeq }
	//fn type_rule_index() -> usize where Self: Sized { RULE_balancedTokenSeq }
}
antlr_rust::tid!{BalancedTokenSeqContextExt<'a>}

impl<'input> BalancedTokenSeqContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BalancedTokenSeqContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BalancedTokenSeqContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BalancedTokenSeqContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<BalancedTokenSeqContextExt<'input>>{

fn balancedtoken_all(&self) ->  Vec<Rc<BalancedtokenContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn balancedtoken(&self, i: usize) -> Option<Rc<BalancedtokenContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> BalancedTokenSeqContextAttrs<'input> for BalancedTokenSeqContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn balancedTokenSeq(&mut self,)
	-> Result<Rc<BalancedTokenSeqContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BalancedTokenSeqContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_balancedTokenSeq);
        let mut _localctx: Rc<BalancedTokenSeqContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1336); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule balancedtoken*/
				recog.base.set_state(1335);
				recog.balancedtoken()?;

				}
				}
				recog.base.set_state(1338); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << MultiLineMacro) | (1usize << Directive) | (1usize << Alignas) | (1usize << Alignof) | (1usize << Asm) | (1usize << Auto) | (1usize << Bool) | (1usize << Break) | (1usize << Case) | (1usize << Catch) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Class) | (1usize << Const) | (1usize << Constexpr) | (1usize << Const_cast) | (1usize << Continue) | (1usize << Decltype) | (1usize << Default) | (1usize << Delete) | (1usize << Do) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (Else - 32)) | (1usize << (Enum - 32)) | (1usize << (Explicit - 32)) | (1usize << (Export - 32)) | (1usize << (Extern - 32)) | (1usize << (False_ - 32)) | (1usize << (Final - 32)) | (1usize << (Float - 32)) | (1usize << (For - 32)) | (1usize << (Friend - 32)) | (1usize << (Goto - 32)) | (1usize << (If - 32)) | (1usize << (Inline - 32)) | (1usize << (Int - 32)) | (1usize << (Long - 32)) | (1usize << (Mutable - 32)) | (1usize << (Namespace - 32)) | (1usize << (New - 32)) | (1usize << (Noexcept - 32)) | (1usize << (Nullptr - 32)) | (1usize << (Operator - 32)) | (1usize << (Override - 32)) | (1usize << (Private - 32)) | (1usize << (Protected - 32)) | (1usize << (Public - 32)) | (1usize << (Register - 32)) | (1usize << (Reinterpret_cast - 32)) | (1usize << (Return - 32)) | (1usize << (Short - 32)) | (1usize << (Signed - 32)) | (1usize << (Sizeof - 32)) | (1usize << (Static - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (Static_assert - 64)) | (1usize << (Static_cast - 64)) | (1usize << (Struct - 64)) | (1usize << (Switch - 64)) | (1usize << (Template - 64)) | (1usize << (This - 64)) | (1usize << (Thread_local - 64)) | (1usize << (Throw - 64)) | (1usize << (True_ - 64)) | (1usize << (Try - 64)) | (1usize << (Typedef - 64)) | (1usize << (Typeid_ - 64)) | (1usize << (Typename_ - 64)) | (1usize << (Union - 64)) | (1usize << (Unsigned - 64)) | (1usize << (Using - 64)) | (1usize << (Virtual - 64)) | (1usize << (Void - 64)) | (1usize << (Volatile - 64)) | (1usize << (Wchar - 64)) | (1usize << (While - 64)) | (1usize << (LeftParen - 64)) | (1usize << (LeftBracket - 64)) | (1usize << (LeftBrace - 64)) | (1usize << (Plus - 64)) | (1usize << (Minus - 64)) | (1usize << (Star - 64)) | (1usize << (Div - 64)) | (1usize << (Mod - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (Caret - 96)) | (1usize << (And - 96)) | (1usize << (Or - 96)) | (1usize << (Tilde - 96)) | (1usize << (Not - 96)) | (1usize << (Assign - 96)) | (1usize << (Less - 96)) | (1usize << (Greater - 96)) | (1usize << (PlusAssign - 96)) | (1usize << (MinusAssign - 96)) | (1usize << (StarAssign - 96)) | (1usize << (DivAssign - 96)) | (1usize << (ModAssign - 96)) | (1usize << (XorAssign - 96)) | (1usize << (AndAssign - 96)) | (1usize << (OrAssign - 96)) | (1usize << (LeftShiftAssign - 96)) | (1usize << (RightShiftAssign - 96)) | (1usize << (Equal - 96)) | (1usize << (NotEqual - 96)) | (1usize << (LessEqual - 96)) | (1usize << (GreaterEqual - 96)) | (1usize << (AndAnd - 96)) | (1usize << (OrOr - 96)) | (1usize << (PlusPlus - 96)) | (1usize << (MinusMinus - 96)) | (1usize << (Comma - 96)) | (1usize << (ArrowStar - 96)) | (1usize << (Arrow - 96)) | (1usize << (Question - 96)) | (1usize << (Colon - 96)) | (1usize << (Doublecolon - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (Semi - 128)) | (1usize << (Dot - 128)) | (1usize << (DotStar - 128)) | (1usize << (Ellipsis - 128)) | (1usize << (Identifier - 128)) | (1usize << (DecimalLiteral - 128)) | (1usize << (OctalLiteral - 128)) | (1usize << (HexadecimalLiteral - 128)) | (1usize << (BinaryLiteral - 128)) | (1usize << (Integersuffix - 128)) | (1usize << (UserDefinedIntegerLiteral - 128)) | (1usize << (UserDefinedFloatingLiteral - 128)) | (1usize << (UserDefinedStringLiteral - 128)) | (1usize << (UserDefinedCharacterLiteral - 128)) | (1usize << (Whitespace - 128)) | (1usize << (Newline - 128)) | (1usize << (BlockComment - 128)) | (1usize << (LineComment - 128)))) != 0)) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- balancedtoken ----------------
pub type BalancedtokenContextAll<'input> = BalancedtokenContext<'input>;


pub type BalancedtokenContext<'input> = BaseParserRuleContext<'input,BalancedtokenContextExt<'input>>;

#[derive(Clone)]
pub struct BalancedtokenContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for BalancedtokenContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for BalancedtokenContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_balancedtoken(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_balancedtoken(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BalancedtokenContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_balancedtoken }
	//fn type_rule_index() -> usize where Self: Sized { RULE_balancedtoken }
}
antlr_rust::tid!{BalancedtokenContextExt<'a>}

impl<'input> BalancedtokenContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BalancedtokenContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BalancedtokenContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BalancedtokenContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<BalancedtokenContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token LeftParen in current rule
fn LeftParen_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LeftParen, starting from 0.
/// Returns `None` if number of children corresponding to token LeftParen is less or equal than `i`.
fn LeftParen(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, i)
}
fn balancedTokenSeq(&self) -> Option<Rc<BalancedTokenSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token RightParen in current rule
fn RightParen_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RightParen, starting from 0.
/// Returns `None` if number of children corresponding to token RightParen is less or equal than `i`.
fn RightParen(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, i)
}
/// Retrieves all `TerminalNode`s corresponding to token LeftBracket in current rule
fn LeftBracket_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LeftBracket, starting from 0.
/// Returns `None` if number of children corresponding to token LeftBracket is less or equal than `i`.
fn LeftBracket(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBracket, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RightBracket in current rule
fn RightBracket_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RightBracket, starting from 0.
/// Returns `None` if number of children corresponding to token RightBracket is less or equal than `i`.
fn RightBracket(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBracket, i)
}
/// Retrieves all `TerminalNode`s corresponding to token LeftBrace in current rule
fn LeftBrace_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LeftBrace, starting from 0.
/// Returns `None` if number of children corresponding to token LeftBrace is less or equal than `i`.
fn LeftBrace(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBrace, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RightBrace in current rule
fn RightBrace_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RightBrace, starting from 0.
/// Returns `None` if number of children corresponding to token RightBrace is less or equal than `i`.
fn RightBrace(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBrace, i)
}

}

impl<'input> BalancedtokenContextAttrs<'input> for BalancedtokenContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn balancedtoken(&mut self,)
	-> Result<Rc<BalancedtokenContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BalancedtokenContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_balancedtoken);
        let mut _localctx: Rc<BalancedtokenContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(1357);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LeftParen 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1340);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule balancedTokenSeq*/
					recog.base.set_state(1341);
					recog.balancedTokenSeq()?;

					recog.base.set_state(1342);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}

			 LeftBracket 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1344);
					recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

					/*InvokeRule balancedTokenSeq*/
					recog.base.set_state(1345);
					recog.balancedTokenSeq()?;

					recog.base.set_state(1346);
					recog.base.match_token(RightBracket,&mut recog.err_handler)?;

					}
				}

			 LeftBrace 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1348);
					recog.base.match_token(LeftBrace,&mut recog.err_handler)?;

					/*InvokeRule balancedTokenSeq*/
					recog.base.set_state(1349);
					recog.balancedTokenSeq()?;

					recog.base.set_state(1350);
					recog.base.match_token(RightBrace,&mut recog.err_handler)?;

					}
				}

			 IntegerLiteral | CharacterLiteral | FloatingLiteral | StringLiteral |
			 BooleanLiteral | PointerLiteral | UserDefinedLiteral | MultiLineMacro |
			 Directive | Alignas | Alignof | Asm | Auto | Bool | Break | Case | Catch |
			 Char | Char16 | Char32 | Class | Const | Constexpr | Const_cast | Continue |
			 Decltype | Default | Delete | Do | Double | Dynamic_cast | Else | Enum |
			 Explicit | Export | Extern | False_ | Final | Float | For | Friend |
			 Goto | If | Inline | Int | Long | Mutable | Namespace | New | Noexcept |
			 Nullptr | Operator | Override | Private | Protected | Public | Register |
			 Reinterpret_cast | Return | Short | Signed | Sizeof | Static | Static_assert |
			 Static_cast | Struct | Switch | Template | This | Thread_local | Throw |
			 True_ | Try | Typedef | Typeid_ | Typename_ | Union | Unsigned | Using |
			 Virtual | Void | Volatile | Wchar | While | Plus | Minus | Star | Div |
			 Mod | Caret | And | Or | Tilde | Not | Assign | Less | Greater | PlusAssign |
			 MinusAssign | StarAssign | DivAssign | ModAssign | XorAssign | AndAssign |
			 OrAssign | LeftShiftAssign | RightShiftAssign | Equal | NotEqual | LessEqual |
			 GreaterEqual | AndAnd | OrOr | PlusPlus | MinusMinus | Comma | ArrowStar |
			 Arrow | Question | Colon | Doublecolon | Semi | Dot | DotStar | Ellipsis |
			 Identifier | DecimalLiteral | OctalLiteral | HexadecimalLiteral | BinaryLiteral |
			 Integersuffix | UserDefinedIntegerLiteral | UserDefinedFloatingLiteral |
			 UserDefinedStringLiteral | UserDefinedCharacterLiteral | Whitespace |
			 Newline | BlockComment | LineComment 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1353); 
					recog.err_handler.sync(&mut recog.base)?;
					_alt = 1;
					loop {
						match _alt {
						    x if x == 1=>
							{
							{
							recog.base.set_state(1352);
							_la = recog.base.input.la(1);
							if { _la <= 0 || (((((_la - 85)) & !0x3f) == 0 && ((1usize << (_la - 85)) & ((1usize << (LeftParen - 85)) | (1usize << (RightParen - 85)) | (1usize << (LeftBracket - 85)) | (1usize << (RightBracket - 85)) | (1usize << (LeftBrace - 85)) | (1usize << (RightBrace - 85)))) != 0)) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
							}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(1355); 
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(155,&mut recog.base)?;
						if _alt==2 || _alt==INVALID_ALT { break }
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- initDeclaratorList ----------------
pub type InitDeclaratorListContextAll<'input> = InitDeclaratorListContext<'input>;


pub type InitDeclaratorListContext<'input> = BaseParserRuleContext<'input,InitDeclaratorListContextExt<'input>>;

#[derive(Clone)]
pub struct InitDeclaratorListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for InitDeclaratorListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for InitDeclaratorListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_initDeclaratorList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_initDeclaratorList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InitDeclaratorListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_initDeclaratorList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_initDeclaratorList }
}
antlr_rust::tid!{InitDeclaratorListContextExt<'a>}

impl<'input> InitDeclaratorListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InitDeclaratorListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InitDeclaratorListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InitDeclaratorListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<InitDeclaratorListContextExt<'input>>{

fn initDeclarator_all(&self) ->  Vec<Rc<InitDeclaratorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn initDeclarator(&self, i: usize) -> Option<Rc<InitDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}

}

impl<'input> InitDeclaratorListContextAttrs<'input> for InitDeclaratorListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn initDeclaratorList(&mut self,)
	-> Result<Rc<InitDeclaratorListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InitDeclaratorListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_initDeclaratorList);
        let mut _localctx: Rc<InitDeclaratorListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule initDeclarator*/
			recog.base.set_state(1359);
			recog.initDeclarator()?;

			recog.base.set_state(1364);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Comma {
				{
				{
				recog.base.set_state(1360);
				recog.base.match_token(Comma,&mut recog.err_handler)?;

				/*InvokeRule initDeclarator*/
				recog.base.set_state(1361);
				recog.initDeclarator()?;

				}
				}
				recog.base.set_state(1366);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- initDeclarator ----------------
pub type InitDeclaratorContextAll<'input> = InitDeclaratorContext<'input>;


pub type InitDeclaratorContext<'input> = BaseParserRuleContext<'input,InitDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct InitDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for InitDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for InitDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_initDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_initDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InitDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_initDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_initDeclarator }
}
antlr_rust::tid!{InitDeclaratorContextExt<'a>}

impl<'input> InitDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InitDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InitDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InitDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<InitDeclaratorContextExt<'input>>{

fn declarator(&self) -> Option<Rc<DeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn initializer(&self) -> Option<Rc<InitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InitDeclaratorContextAttrs<'input> for InitDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn initDeclarator(&mut self,)
	-> Result<Rc<InitDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InitDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_initDeclarator);
        let mut _localctx: Rc<InitDeclaratorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule declarator*/
			recog.base.set_state(1367);
			recog.declarator()?;

			recog.base.set_state(1369);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 85)) & !0x3f) == 0 && ((1usize << (_la - 85)) & ((1usize << (LeftParen - 85)) | (1usize << (LeftBrace - 85)) | (1usize << (Assign - 85)))) != 0) {
				{
				/*InvokeRule initializer*/
				recog.base.set_state(1368);
				recog.initializer()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- declarator ----------------
pub type DeclaratorContextAll<'input> = DeclaratorContext<'input>;


pub type DeclaratorContext<'input> = BaseParserRuleContext<'input,DeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct DeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for DeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for DeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_declarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_declarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_declarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_declarator }
}
antlr_rust::tid!{DeclaratorContextExt<'a>}

impl<'input> DeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<DeclaratorContextExt<'input>>{

fn pointerDeclarator(&self) -> Option<Rc<PointerDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn noPointerDeclarator(&self) -> Option<Rc<NoPointerDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parametersAndQualifiers(&self) -> Option<Rc<ParametersAndQualifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn trailingReturnType(&self) -> Option<Rc<TrailingReturnTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DeclaratorContextAttrs<'input> for DeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn declarator(&mut self,)
	-> Result<Rc<DeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_declarator);
        let mut _localctx: Rc<DeclaratorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1376);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(159,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule pointerDeclarator*/
					recog.base.set_state(1371);
					recog.pointerDeclarator()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule noPointerDeclarator*/
					recog.base.set_state(1372);
					recog.noPointerDeclarator_rec(0)?;

					/*InvokeRule parametersAndQualifiers*/
					recog.base.set_state(1373);
					recog.parametersAndQualifiers()?;

					/*InvokeRule trailingReturnType*/
					recog.base.set_state(1374);
					recog.trailingReturnType()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pointerDeclarator ----------------
pub type PointerDeclaratorContextAll<'input> = PointerDeclaratorContext<'input>;


pub type PointerDeclaratorContext<'input> = BaseParserRuleContext<'input,PointerDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct PointerDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for PointerDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for PointerDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pointerDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_pointerDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PointerDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pointerDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pointerDeclarator }
}
antlr_rust::tid!{PointerDeclaratorContextExt<'a>}

impl<'input> PointerDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PointerDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PointerDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PointerDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<PointerDeclaratorContextExt<'input>>{

fn noPointerDeclarator(&self) -> Option<Rc<NoPointerDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pointerOperator_all(&self) ->  Vec<Rc<PointerOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn pointerOperator(&self, i: usize) -> Option<Rc<PointerOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Const in current rule
fn Const_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Const, starting from 0.
/// Returns `None` if number of children corresponding to token Const is less or equal than `i`.
fn Const(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Const, i)
}

}

impl<'input> PointerDeclaratorContextAttrs<'input> for PointerDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pointerDeclarator(&mut self,)
	-> Result<Rc<PointerDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PointerDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_pointerDeclarator);
        let mut _localctx: Rc<PointerDeclaratorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1384);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(161,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule pointerOperator*/
					recog.base.set_state(1378);
					recog.pointerOperator()?;

					recog.base.set_state(1380);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Const {
						{
						recog.base.set_state(1379);
						recog.base.match_token(Const,&mut recog.err_handler)?;

						}
					}

					}
					} 
				}
				recog.base.set_state(1386);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(161,&mut recog.base)?;
			}
			/*InvokeRule noPointerDeclarator*/
			recog.base.set_state(1387);
			recog.noPointerDeclarator_rec(0)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- noPointerDeclarator ----------------
pub type NoPointerDeclaratorContextAll<'input> = NoPointerDeclaratorContext<'input>;


pub type NoPointerDeclaratorContext<'input> = BaseParserRuleContext<'input,NoPointerDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct NoPointerDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NoPointerDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NoPointerDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_noPointerDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_noPointerDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NoPointerDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_noPointerDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_noPointerDeclarator }
}
antlr_rust::tid!{NoPointerDeclaratorContextExt<'a>}

impl<'input> NoPointerDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NoPointerDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NoPointerDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NoPointerDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NoPointerDeclaratorContextExt<'input>>{

fn declaratorid(&self) -> Option<Rc<DeclaratoridContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn pointerDeclarator(&self) -> Option<Rc<PointerDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn noPointerDeclarator(&self) -> Option<Rc<NoPointerDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parametersAndQualifiers(&self) -> Option<Rc<ParametersAndQualifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftBracket
/// Returns `None` if there is no child corresponding to token LeftBracket
fn LeftBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBracket, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBracket
/// Returns `None` if there is no child corresponding to token RightBracket
fn RightBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBracket, 0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NoPointerDeclaratorContextAttrs<'input> for NoPointerDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  noPointerDeclarator(&mut self,)
	-> Result<Rc<NoPointerDeclaratorContextAll<'input>>,ANTLRError> {
		self.noPointerDeclarator_rec(0)
	}

	fn noPointerDeclarator_rec(&mut self, _p: isize)
	-> Result<Rc<NoPointerDeclaratorContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = NoPointerDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 230, RULE_noPointerDeclarator, _p);
	    let mut _localctx: Rc<NoPointerDeclaratorContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 230;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1398);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Decltype | Operator | Tilde | Doublecolon | Ellipsis | Identifier 
				=> {
					{
					/*InvokeRule declaratorid*/
					recog.base.set_state(1390);
					recog.declaratorid()?;

					recog.base.set_state(1392);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(162,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule attributeSpecifierSeq*/
							recog.base.set_state(1391);
							recog.attributeSpecifierSeq()?;

							}
						}

						_ => {}
					}
					}
				}

			 LeftParen 
				=> {
					{
					recog.base.set_state(1394);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule pointerDeclarator*/
					recog.base.set_state(1395);
					recog.pointerDeclarator()?;

					recog.base.set_state(1396);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(1414);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(167,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = NoPointerDeclaratorContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_noPointerDeclarator);
					_localctx = tmp;
					recog.base.set_state(1400);
					if !({recog.precpred(None, 2)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
					}
					recog.base.set_state(1410);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 LeftParen 
						=> {
							{
							/*InvokeRule parametersAndQualifiers*/
							recog.base.set_state(1401);
							recog.parametersAndQualifiers()?;

							}
						}

					 LeftBracket 
						=> {
							{
							recog.base.set_state(1402);
							recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

							recog.base.set_state(1404);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 75)) & !0x3f) == 0 && ((1usize << (_la - 75)) & ((1usize << (Typeid_ - 75)) | (1usize << (Typename_ - 75)) | (1usize << (Unsigned - 75)) | (1usize << (Void - 75)) | (1usize << (Wchar - 75)) | (1usize << (LeftParen - 75)) | (1usize << (LeftBracket - 75)) | (1usize << (Plus - 75)) | (1usize << (Minus - 75)) | (1usize << (Star - 75)) | (1usize << (And - 75)) | (1usize << (Or - 75)) | (1usize << (Tilde - 75)) | (1usize << (Not - 75)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
								{
								/*InvokeRule constantExpression*/
								recog.base.set_state(1403);
								recog.constantExpression()?;

								}
							}

							recog.base.set_state(1406);
							recog.base.match_token(RightBracket,&mut recog.err_handler)?;

							recog.base.set_state(1408);
							recog.err_handler.sync(&mut recog.base)?;
							match  recog.interpreter.adaptive_predict(165,&mut recog.base)? {
								x if x == 1=>{
									{
									/*InvokeRule attributeSpecifierSeq*/
									recog.base.set_state(1407);
									recog.attributeSpecifierSeq()?;

									}
								}

								_ => {}
							}
							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
					} 
				}
				recog.base.set_state(1416);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(167,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- parametersAndQualifiers ----------------
pub type ParametersAndQualifiersContextAll<'input> = ParametersAndQualifiersContext<'input>;


pub type ParametersAndQualifiersContext<'input> = BaseParserRuleContext<'input,ParametersAndQualifiersContextExt<'input>>;

#[derive(Clone)]
pub struct ParametersAndQualifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ParametersAndQualifiersContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ParametersAndQualifiersContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parametersAndQualifiers(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_parametersAndQualifiers(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ParametersAndQualifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parametersAndQualifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parametersAndQualifiers }
}
antlr_rust::tid!{ParametersAndQualifiersContextExt<'a>}

impl<'input> ParametersAndQualifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParametersAndQualifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParametersAndQualifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParametersAndQualifiersContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ParametersAndQualifiersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn parameterDeclarationClause(&self) -> Option<Rc<ParameterDeclarationClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn cvqualifierseq(&self) -> Option<Rc<CvqualifierseqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn refqualifier(&self) -> Option<Rc<RefqualifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn exceptionSpecification(&self) -> Option<Rc<ExceptionSpecificationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ParametersAndQualifiersContextAttrs<'input> for ParametersAndQualifiersContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parametersAndQualifiers(&mut self,)
	-> Result<Rc<ParametersAndQualifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParametersAndQualifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_parametersAndQualifiers);
        let mut _localctx: Rc<ParametersAndQualifiersContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1417);
			recog.base.match_token(LeftParen,&mut recog.err_handler)?;

			recog.base.set_state(1419);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << Alignas) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Class) | (1usize << Const) | (1usize << Constexpr) | (1usize << Decltype) | (1usize << Double))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (Enum - 33)) | (1usize << (Explicit - 33)) | (1usize << (Extern - 33)) | (1usize << (Float - 33)) | (1usize << (Friend - 33)) | (1usize << (Inline - 33)) | (1usize << (Int - 33)) | (1usize << (Long - 33)) | (1usize << (Mutable - 33)) | (1usize << (Register - 33)) | (1usize << (Short - 33)) | (1usize << (Signed - 33)) | (1usize << (Static - 33)))) != 0) || ((((_la - 66)) & !0x3f) == 0 && ((1usize << (_la - 66)) & ((1usize << (Struct - 66)) | (1usize << (Thread_local - 66)) | (1usize << (Typedef - 66)) | (1usize << (Typename_ - 66)) | (1usize << (Union - 66)) | (1usize << (Unsigned - 66)) | (1usize << (Virtual - 66)) | (1usize << (Void - 66)) | (1usize << (Volatile - 66)) | (1usize << (Wchar - 66)) | (1usize << (LeftBracket - 66)))) != 0) || _la==Doublecolon || _la==Identifier {
				{
				/*InvokeRule parameterDeclarationClause*/
				recog.base.set_state(1418);
				recog.parameterDeclarationClause()?;

				}
			}

			recog.base.set_state(1421);
			recog.base.match_token(RightParen,&mut recog.err_handler)?;

			recog.base.set_state(1423);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(169,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule cvqualifierseq*/
					recog.base.set_state(1422);
					recog.cvqualifierseq()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1426);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(170,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule refqualifier*/
					recog.base.set_state(1425);
					recog.refqualifier()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1429);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(171,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule exceptionSpecification*/
					recog.base.set_state(1428);
					recog.exceptionSpecification()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1432);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(172,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule attributeSpecifierSeq*/
					recog.base.set_state(1431);
					recog.attributeSpecifierSeq()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- trailingReturnType ----------------
pub type TrailingReturnTypeContextAll<'input> = TrailingReturnTypeContext<'input>;


pub type TrailingReturnTypeContext<'input> = BaseParserRuleContext<'input,TrailingReturnTypeContextExt<'input>>;

#[derive(Clone)]
pub struct TrailingReturnTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TrailingReturnTypeContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TrailingReturnTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_trailingReturnType(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_trailingReturnType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TrailingReturnTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_trailingReturnType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_trailingReturnType }
}
antlr_rust::tid!{TrailingReturnTypeContextExt<'a>}

impl<'input> TrailingReturnTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TrailingReturnTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TrailingReturnTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TrailingReturnTypeContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TrailingReturnTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Arrow
/// Returns `None` if there is no child corresponding to token Arrow
fn Arrow(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Arrow, 0)
}
fn trailingTypeSpecifierSeq(&self) -> Option<Rc<TrailingTypeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn abstractDeclarator(&self) -> Option<Rc<AbstractDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TrailingReturnTypeContextAttrs<'input> for TrailingReturnTypeContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn trailingReturnType(&mut self,)
	-> Result<Rc<TrailingReturnTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TrailingReturnTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_trailingReturnType);
        let mut _localctx: Rc<TrailingReturnTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1434);
			recog.base.match_token(Arrow,&mut recog.err_handler)?;

			/*InvokeRule trailingTypeSpecifierSeq*/
			recog.base.set_state(1435);
			recog.trailingTypeSpecifierSeq()?;

			recog.base.set_state(1437);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(173,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule abstractDeclarator*/
					recog.base.set_state(1436);
					recog.abstractDeclarator()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pointerOperator ----------------
pub type PointerOperatorContextAll<'input> = PointerOperatorContext<'input>;


pub type PointerOperatorContext<'input> = BaseParserRuleContext<'input,PointerOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct PointerOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for PointerOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for PointerOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pointerOperator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_pointerOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PointerOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pointerOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pointerOperator }
}
antlr_rust::tid!{PointerOperatorContextExt<'a>}

impl<'input> PointerOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PointerOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PointerOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PointerOperatorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<PointerOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token And
/// Returns `None` if there is no child corresponding to token And
fn And(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(And, 0)
}
/// Retrieves first TerminalNode corresponding to token AndAnd
/// Returns `None` if there is no child corresponding to token AndAnd
fn AndAnd(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(AndAnd, 0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Star
/// Returns `None` if there is no child corresponding to token Star
fn Star(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Star, 0)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn cvqualifierseq(&self) -> Option<Rc<CvqualifierseqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PointerOperatorContextAttrs<'input> for PointerOperatorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pointerOperator(&mut self,)
	-> Result<Rc<PointerOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PointerOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_pointerOperator);
        let mut _localctx: Rc<PointerOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1453);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 And | AndAnd 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1439);
					_la = recog.base.input.la(1);
					if { !(_la==And || _la==AndAnd) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(1441);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(174,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule attributeSpecifierSeq*/
							recog.base.set_state(1440);
							recog.attributeSpecifierSeq()?;

							}
						}

						_ => {}
					}
					}
				}

			 Decltype | Star | Doublecolon | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1444);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Decltype || _la==Doublecolon || _la==Identifier {
						{
						/*InvokeRule nestedNameSpecifier*/
						recog.base.set_state(1443);
						recog.nestedNameSpecifier_rec(0)?;

						}
					}

					recog.base.set_state(1446);
					recog.base.match_token(Star,&mut recog.err_handler)?;

					recog.base.set_state(1448);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(176,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule attributeSpecifierSeq*/
							recog.base.set_state(1447);
							recog.attributeSpecifierSeq()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1451);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(177,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule cvqualifierseq*/
							recog.base.set_state(1450);
							recog.cvqualifierseq()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cvqualifierseq ----------------
pub type CvqualifierseqContextAll<'input> = CvqualifierseqContext<'input>;


pub type CvqualifierseqContext<'input> = BaseParserRuleContext<'input,CvqualifierseqContextExt<'input>>;

#[derive(Clone)]
pub struct CvqualifierseqContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for CvqualifierseqContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for CvqualifierseqContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_cvqualifierseq(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_cvqualifierseq(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CvqualifierseqContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cvqualifierseq }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cvqualifierseq }
}
antlr_rust::tid!{CvqualifierseqContextExt<'a>}

impl<'input> CvqualifierseqContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CvqualifierseqContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CvqualifierseqContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CvqualifierseqContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<CvqualifierseqContextExt<'input>>{

fn cvQualifier_all(&self) ->  Vec<Rc<CvQualifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn cvQualifier(&self, i: usize) -> Option<Rc<CvQualifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CvqualifierseqContextAttrs<'input> for CvqualifierseqContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cvqualifierseq(&mut self,)
	-> Result<Rc<CvqualifierseqContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CvqualifierseqContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_cvqualifierseq);
        let mut _localctx: Rc<CvqualifierseqContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1456); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule cvQualifier*/
					recog.base.set_state(1455);
					recog.cvQualifier()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(1458); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(179,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cvQualifier ----------------
pub type CvQualifierContextAll<'input> = CvQualifierContext<'input>;


pub type CvQualifierContext<'input> = BaseParserRuleContext<'input,CvQualifierContextExt<'input>>;

#[derive(Clone)]
pub struct CvQualifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for CvQualifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for CvQualifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_cvQualifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_cvQualifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CvQualifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cvQualifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cvQualifier }
}
antlr_rust::tid!{CvQualifierContextExt<'a>}

impl<'input> CvQualifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CvQualifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CvQualifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CvQualifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<CvQualifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Const
/// Returns `None` if there is no child corresponding to token Const
fn Const(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Const, 0)
}
/// Retrieves first TerminalNode corresponding to token Volatile
/// Returns `None` if there is no child corresponding to token Volatile
fn Volatile(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Volatile, 0)
}

}

impl<'input> CvQualifierContextAttrs<'input> for CvQualifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cvQualifier(&mut self,)
	-> Result<Rc<CvQualifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CvQualifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 240, RULE_cvQualifier);
        let mut _localctx: Rc<CvQualifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1460);
			_la = recog.base.input.la(1);
			if { !(_la==Const || _la==Volatile) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- refqualifier ----------------
pub type RefqualifierContextAll<'input> = RefqualifierContext<'input>;


pub type RefqualifierContext<'input> = BaseParserRuleContext<'input,RefqualifierContextExt<'input>>;

#[derive(Clone)]
pub struct RefqualifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for RefqualifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for RefqualifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_refqualifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_refqualifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RefqualifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_refqualifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_refqualifier }
}
antlr_rust::tid!{RefqualifierContextExt<'a>}

impl<'input> RefqualifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RefqualifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RefqualifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RefqualifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<RefqualifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token And
/// Returns `None` if there is no child corresponding to token And
fn And(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(And, 0)
}
/// Retrieves first TerminalNode corresponding to token AndAnd
/// Returns `None` if there is no child corresponding to token AndAnd
fn AndAnd(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(AndAnd, 0)
}

}

impl<'input> RefqualifierContextAttrs<'input> for RefqualifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn refqualifier(&mut self,)
	-> Result<Rc<RefqualifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RefqualifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 242, RULE_refqualifier);
        let mut _localctx: Rc<RefqualifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1462);
			_la = recog.base.input.la(1);
			if { !(_la==And || _la==AndAnd) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- declaratorid ----------------
pub type DeclaratoridContextAll<'input> = DeclaratoridContext<'input>;


pub type DeclaratoridContext<'input> = BaseParserRuleContext<'input,DeclaratoridContextExt<'input>>;

#[derive(Clone)]
pub struct DeclaratoridContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for DeclaratoridContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for DeclaratoridContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_declaratorid(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_declaratorid(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DeclaratoridContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_declaratorid }
	//fn type_rule_index() -> usize where Self: Sized { RULE_declaratorid }
}
antlr_rust::tid!{DeclaratoridContextExt<'a>}

impl<'input> DeclaratoridContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeclaratoridContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeclaratoridContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeclaratoridContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<DeclaratoridContextExt<'input>>{

fn idExpression(&self) -> Option<Rc<IdExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Ellipsis
/// Returns `None` if there is no child corresponding to token Ellipsis
fn Ellipsis(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, 0)
}

}

impl<'input> DeclaratoridContextAttrs<'input> for DeclaratoridContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn declaratorid(&mut self,)
	-> Result<Rc<DeclaratoridContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeclaratoridContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 244, RULE_declaratorid);
        let mut _localctx: Rc<DeclaratoridContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1465);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Ellipsis {
				{
				recog.base.set_state(1464);
				recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

				}
			}

			/*InvokeRule idExpression*/
			recog.base.set_state(1467);
			recog.idExpression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- theTypeId ----------------
pub type TheTypeIdContextAll<'input> = TheTypeIdContext<'input>;


pub type TheTypeIdContext<'input> = BaseParserRuleContext<'input,TheTypeIdContextExt<'input>>;

#[derive(Clone)]
pub struct TheTypeIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TheTypeIdContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TheTypeIdContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_theTypeId(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_theTypeId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TheTypeIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_theTypeId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_theTypeId }
}
antlr_rust::tid!{TheTypeIdContextExt<'a>}

impl<'input> TheTypeIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TheTypeIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TheTypeIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TheTypeIdContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TheTypeIdContextExt<'input>>{

fn typeSpecifierSeq(&self) -> Option<Rc<TypeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn abstractDeclarator(&self) -> Option<Rc<AbstractDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TheTypeIdContextAttrs<'input> for TheTypeIdContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn theTypeId(&mut self,)
	-> Result<Rc<TheTypeIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TheTypeIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 246, RULE_theTypeId);
        let mut _localctx: Rc<TheTypeIdContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typeSpecifierSeq*/
			recog.base.set_state(1469);
			recog.typeSpecifierSeq()?;

			recog.base.set_state(1471);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(181,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule abstractDeclarator*/
					recog.base.set_state(1470);
					recog.abstractDeclarator()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- abstractDeclarator ----------------
pub type AbstractDeclaratorContextAll<'input> = AbstractDeclaratorContext<'input>;


pub type AbstractDeclaratorContext<'input> = BaseParserRuleContext<'input,AbstractDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct AbstractDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AbstractDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AbstractDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_abstractDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_abstractDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AbstractDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_abstractDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_abstractDeclarator }
}
antlr_rust::tid!{AbstractDeclaratorContextExt<'a>}

impl<'input> AbstractDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AbstractDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AbstractDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AbstractDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AbstractDeclaratorContextExt<'input>>{

fn pointerAbstractDeclarator(&self) -> Option<Rc<PointerAbstractDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parametersAndQualifiers(&self) -> Option<Rc<ParametersAndQualifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn trailingReturnType(&self) -> Option<Rc<TrailingReturnTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn noPointerAbstractDeclarator(&self) -> Option<Rc<NoPointerAbstractDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn abstractPackDeclarator(&self) -> Option<Rc<AbstractPackDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AbstractDeclaratorContextAttrs<'input> for AbstractDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn abstractDeclarator(&mut self,)
	-> Result<Rc<AbstractDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AbstractDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 248, RULE_abstractDeclarator);
        let mut _localctx: Rc<AbstractDeclaratorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1481);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(183,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule pointerAbstractDeclarator*/
					recog.base.set_state(1473);
					recog.pointerAbstractDeclarator()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1475);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(182,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule noPointerAbstractDeclarator*/
							recog.base.set_state(1474);
							recog.noPointerAbstractDeclarator_rec(0)?;

							}
						}

						_ => {}
					}
					/*InvokeRule parametersAndQualifiers*/
					recog.base.set_state(1477);
					recog.parametersAndQualifiers()?;

					/*InvokeRule trailingReturnType*/
					recog.base.set_state(1478);
					recog.trailingReturnType()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule abstractPackDeclarator*/
					recog.base.set_state(1480);
					recog.abstractPackDeclarator()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pointerAbstractDeclarator ----------------
pub type PointerAbstractDeclaratorContextAll<'input> = PointerAbstractDeclaratorContext<'input>;


pub type PointerAbstractDeclaratorContext<'input> = BaseParserRuleContext<'input,PointerAbstractDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct PointerAbstractDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for PointerAbstractDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for PointerAbstractDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pointerAbstractDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_pointerAbstractDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PointerAbstractDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pointerAbstractDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pointerAbstractDeclarator }
}
antlr_rust::tid!{PointerAbstractDeclaratorContextExt<'a>}

impl<'input> PointerAbstractDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PointerAbstractDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PointerAbstractDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PointerAbstractDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<PointerAbstractDeclaratorContextExt<'input>>{

fn noPointerAbstractDeclarator(&self) -> Option<Rc<NoPointerAbstractDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pointerOperator_all(&self) ->  Vec<Rc<PointerOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn pointerOperator(&self, i: usize) -> Option<Rc<PointerOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PointerAbstractDeclaratorContextAttrs<'input> for PointerAbstractDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pointerAbstractDeclarator(&mut self,)
	-> Result<Rc<PointerAbstractDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PointerAbstractDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 250, RULE_pointerAbstractDeclarator);
        let mut _localctx: Rc<PointerAbstractDeclaratorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(1492);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LeftParen | LeftBracket 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule noPointerAbstractDeclarator*/
					recog.base.set_state(1483);
					recog.noPointerAbstractDeclarator_rec(0)?;

					}
				}

			 Decltype | Star | And | AndAnd | Doublecolon | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1485); 
					recog.err_handler.sync(&mut recog.base)?;
					_alt = 1;
					loop {
						match _alt {
						    x if x == 1=>
							{
							{
							/*InvokeRule pointerOperator*/
							recog.base.set_state(1484);
							recog.pointerOperator()?;

							}
							}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(1487); 
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(184,&mut recog.base)?;
						if _alt==2 || _alt==INVALID_ALT { break }
					}
					recog.base.set_state(1490);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(185,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule noPointerAbstractDeclarator*/
							recog.base.set_state(1489);
							recog.noPointerAbstractDeclarator_rec(0)?;

							}
						}

						_ => {}
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- noPointerAbstractDeclarator ----------------
pub type NoPointerAbstractDeclaratorContextAll<'input> = NoPointerAbstractDeclaratorContext<'input>;


pub type NoPointerAbstractDeclaratorContext<'input> = BaseParserRuleContext<'input,NoPointerAbstractDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct NoPointerAbstractDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NoPointerAbstractDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NoPointerAbstractDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_noPointerAbstractDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_noPointerAbstractDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NoPointerAbstractDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_noPointerAbstractDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_noPointerAbstractDeclarator }
}
antlr_rust::tid!{NoPointerAbstractDeclaratorContextExt<'a>}

impl<'input> NoPointerAbstractDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NoPointerAbstractDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NoPointerAbstractDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NoPointerAbstractDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NoPointerAbstractDeclaratorContextExt<'input>>{

fn parametersAndQualifiers(&self) -> Option<Rc<ParametersAndQualifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftBracket
/// Returns `None` if there is no child corresponding to token LeftBracket
fn LeftBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBracket, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBracket
/// Returns `None` if there is no child corresponding to token RightBracket
fn RightBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBracket, 0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn pointerAbstractDeclarator(&self) -> Option<Rc<PointerAbstractDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn noPointerAbstractDeclarator_all(&self) ->  Vec<Rc<NoPointerAbstractDeclaratorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn noPointerAbstractDeclarator(&self, i: usize) -> Option<Rc<NoPointerAbstractDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> NoPointerAbstractDeclaratorContextAttrs<'input> for NoPointerAbstractDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  noPointerAbstractDeclarator(&mut self,)
	-> Result<Rc<NoPointerAbstractDeclaratorContextAll<'input>>,ANTLRError> {
		self.noPointerAbstractDeclarator_rec(0)
	}

	fn noPointerAbstractDeclarator_rec(&mut self, _p: isize)
	-> Result<Rc<NoPointerAbstractDeclaratorContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = NoPointerAbstractDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 252, RULE_noPointerAbstractDeclarator, _p);
	    let mut _localctx: Rc<NoPointerAbstractDeclaratorContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 252;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1508);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(189,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule parametersAndQualifiers*/
					recog.base.set_state(1495);
					recog.parametersAndQualifiers()?;

					}
				}
			,
				2 =>{
					{
					recog.base.set_state(1496);
					recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

					recog.base.set_state(1498);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 75)) & !0x3f) == 0 && ((1usize << (_la - 75)) & ((1usize << (Typeid_ - 75)) | (1usize << (Typename_ - 75)) | (1usize << (Unsigned - 75)) | (1usize << (Void - 75)) | (1usize << (Wchar - 75)) | (1usize << (LeftParen - 75)) | (1usize << (LeftBracket - 75)) | (1usize << (Plus - 75)) | (1usize << (Minus - 75)) | (1usize << (Star - 75)) | (1usize << (And - 75)) | (1usize << (Or - 75)) | (1usize << (Tilde - 75)) | (1usize << (Not - 75)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
						{
						/*InvokeRule constantExpression*/
						recog.base.set_state(1497);
						recog.constantExpression()?;

						}
					}

					recog.base.set_state(1500);
					recog.base.match_token(RightBracket,&mut recog.err_handler)?;

					recog.base.set_state(1502);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(188,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule attributeSpecifierSeq*/
							recog.base.set_state(1501);
							recog.attributeSpecifierSeq()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				3 =>{
					{
					recog.base.set_state(1504);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule pointerAbstractDeclarator*/
					recog.base.set_state(1505);
					recog.pointerAbstractDeclarator()?;

					recog.base.set_state(1506);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(1525);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(193,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = NoPointerAbstractDeclaratorContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_noPointerAbstractDeclarator);
					_localctx = tmp;
					recog.base.set_state(1510);
					if !({recog.precpred(None, 4)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 4)".to_owned()), None))?;
					}
					recog.base.set_state(1521);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(192,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule parametersAndQualifiers*/
							recog.base.set_state(1511);
							recog.parametersAndQualifiers()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule noPointerAbstractDeclarator*/
							recog.base.set_state(1512);
							recog.noPointerAbstractDeclarator_rec(0)?;

							recog.base.set_state(1513);
							recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

							recog.base.set_state(1515);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 75)) & !0x3f) == 0 && ((1usize << (_la - 75)) & ((1usize << (Typeid_ - 75)) | (1usize << (Typename_ - 75)) | (1usize << (Unsigned - 75)) | (1usize << (Void - 75)) | (1usize << (Wchar - 75)) | (1usize << (LeftParen - 75)) | (1usize << (LeftBracket - 75)) | (1usize << (Plus - 75)) | (1usize << (Minus - 75)) | (1usize << (Star - 75)) | (1usize << (And - 75)) | (1usize << (Or - 75)) | (1usize << (Tilde - 75)) | (1usize << (Not - 75)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
								{
								/*InvokeRule constantExpression*/
								recog.base.set_state(1514);
								recog.constantExpression()?;

								}
							}

							recog.base.set_state(1517);
							recog.base.match_token(RightBracket,&mut recog.err_handler)?;

							recog.base.set_state(1519);
							recog.err_handler.sync(&mut recog.base)?;
							match  recog.interpreter.adaptive_predict(191,&mut recog.base)? {
								x if x == 1=>{
									{
									/*InvokeRule attributeSpecifierSeq*/
									recog.base.set_state(1518);
									recog.attributeSpecifierSeq()?;

									}
								}

								_ => {}
							}
							}
						}

						_ => {}
					}
					}
					} 
				}
				recog.base.set_state(1527);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(193,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- abstractPackDeclarator ----------------
pub type AbstractPackDeclaratorContextAll<'input> = AbstractPackDeclaratorContext<'input>;


pub type AbstractPackDeclaratorContext<'input> = BaseParserRuleContext<'input,AbstractPackDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct AbstractPackDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AbstractPackDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AbstractPackDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_abstractPackDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_abstractPackDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AbstractPackDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_abstractPackDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_abstractPackDeclarator }
}
antlr_rust::tid!{AbstractPackDeclaratorContextExt<'a>}

impl<'input> AbstractPackDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AbstractPackDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AbstractPackDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AbstractPackDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AbstractPackDeclaratorContextExt<'input>>{

fn noPointerAbstractPackDeclarator(&self) -> Option<Rc<NoPointerAbstractPackDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pointerOperator_all(&self) ->  Vec<Rc<PointerOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn pointerOperator(&self, i: usize) -> Option<Rc<PointerOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AbstractPackDeclaratorContextAttrs<'input> for AbstractPackDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn abstractPackDeclarator(&mut self,)
	-> Result<Rc<AbstractPackDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AbstractPackDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 254, RULE_abstractPackDeclarator);
        let mut _localctx: Rc<AbstractPackDeclaratorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1531);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Decltype || ((((_la - 93)) & !0x3f) == 0 && ((1usize << (_la - 93)) & ((1usize << (Star - 93)) | (1usize << (And - 93)) | (1usize << (AndAnd - 93)))) != 0) || _la==Doublecolon || _la==Identifier {
				{
				{
				/*InvokeRule pointerOperator*/
				recog.base.set_state(1528);
				recog.pointerOperator()?;

				}
				}
				recog.base.set_state(1533);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule noPointerAbstractPackDeclarator*/
			recog.base.set_state(1534);
			recog.noPointerAbstractPackDeclarator_rec(0)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- noPointerAbstractPackDeclarator ----------------
pub type NoPointerAbstractPackDeclaratorContextAll<'input> = NoPointerAbstractPackDeclaratorContext<'input>;


pub type NoPointerAbstractPackDeclaratorContext<'input> = BaseParserRuleContext<'input,NoPointerAbstractPackDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct NoPointerAbstractPackDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NoPointerAbstractPackDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NoPointerAbstractPackDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_noPointerAbstractPackDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_noPointerAbstractPackDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NoPointerAbstractPackDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_noPointerAbstractPackDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_noPointerAbstractPackDeclarator }
}
antlr_rust::tid!{NoPointerAbstractPackDeclaratorContextExt<'a>}

impl<'input> NoPointerAbstractPackDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NoPointerAbstractPackDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NoPointerAbstractPackDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NoPointerAbstractPackDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NoPointerAbstractPackDeclaratorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Ellipsis
/// Returns `None` if there is no child corresponding to token Ellipsis
fn Ellipsis(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, 0)
}
fn noPointerAbstractPackDeclarator(&self) -> Option<Rc<NoPointerAbstractPackDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parametersAndQualifiers(&self) -> Option<Rc<ParametersAndQualifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftBracket
/// Returns `None` if there is no child corresponding to token LeftBracket
fn LeftBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBracket, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBracket
/// Returns `None` if there is no child corresponding to token RightBracket
fn RightBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBracket, 0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NoPointerAbstractPackDeclaratorContextAttrs<'input> for NoPointerAbstractPackDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  noPointerAbstractPackDeclarator(&mut self,)
	-> Result<Rc<NoPointerAbstractPackDeclaratorContextAll<'input>>,ANTLRError> {
		self.noPointerAbstractPackDeclarator_rec(0)
	}

	fn noPointerAbstractPackDeclarator_rec(&mut self, _p: isize)
	-> Result<Rc<NoPointerAbstractPackDeclaratorContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = NoPointerAbstractPackDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 256, RULE_noPointerAbstractPackDeclarator, _p);
	    let mut _localctx: Rc<NoPointerAbstractPackDeclaratorContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 256;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			recog.base.set_state(1537);
			recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(1553);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(198,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = NoPointerAbstractPackDeclaratorContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_noPointerAbstractPackDeclarator);
					_localctx = tmp;
					recog.base.set_state(1539);
					if !({recog.precpred(None, 2)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
					}
					recog.base.set_state(1549);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 LeftParen 
						=> {
							{
							/*InvokeRule parametersAndQualifiers*/
							recog.base.set_state(1540);
							recog.parametersAndQualifiers()?;

							}
						}

					 LeftBracket 
						=> {
							{
							recog.base.set_state(1541);
							recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

							recog.base.set_state(1543);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 75)) & !0x3f) == 0 && ((1usize << (_la - 75)) & ((1usize << (Typeid_ - 75)) | (1usize << (Typename_ - 75)) | (1usize << (Unsigned - 75)) | (1usize << (Void - 75)) | (1usize << (Wchar - 75)) | (1usize << (LeftParen - 75)) | (1usize << (LeftBracket - 75)) | (1usize << (Plus - 75)) | (1usize << (Minus - 75)) | (1usize << (Star - 75)) | (1usize << (And - 75)) | (1usize << (Or - 75)) | (1usize << (Tilde - 75)) | (1usize << (Not - 75)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
								{
								/*InvokeRule constantExpression*/
								recog.base.set_state(1542);
								recog.constantExpression()?;

								}
							}

							recog.base.set_state(1545);
							recog.base.match_token(RightBracket,&mut recog.err_handler)?;

							recog.base.set_state(1547);
							recog.err_handler.sync(&mut recog.base)?;
							match  recog.interpreter.adaptive_predict(196,&mut recog.base)? {
								x if x == 1=>{
									{
									/*InvokeRule attributeSpecifierSeq*/
									recog.base.set_state(1546);
									recog.attributeSpecifierSeq()?;

									}
								}

								_ => {}
							}
							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
					} 
				}
				recog.base.set_state(1555);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(198,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- parameterDeclarationClause ----------------
pub type ParameterDeclarationClauseContextAll<'input> = ParameterDeclarationClauseContext<'input>;


pub type ParameterDeclarationClauseContext<'input> = BaseParserRuleContext<'input,ParameterDeclarationClauseContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterDeclarationClauseContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ParameterDeclarationClauseContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ParameterDeclarationClauseContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parameterDeclarationClause(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_parameterDeclarationClause(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ParameterDeclarationClauseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameterDeclarationClause }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameterDeclarationClause }
}
antlr_rust::tid!{ParameterDeclarationClauseContextExt<'a>}

impl<'input> ParameterDeclarationClauseContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterDeclarationClauseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterDeclarationClauseContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterDeclarationClauseContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ParameterDeclarationClauseContextExt<'input>>{

fn parameterDeclarationList(&self) -> Option<Rc<ParameterDeclarationListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Ellipsis
/// Returns `None` if there is no child corresponding to token Ellipsis
fn Ellipsis(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, 0)
}
/// Retrieves first TerminalNode corresponding to token Comma
/// Returns `None` if there is no child corresponding to token Comma
fn Comma(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, 0)
}

}

impl<'input> ParameterDeclarationClauseContextAttrs<'input> for ParameterDeclarationClauseContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameterDeclarationClause(&mut self,)
	-> Result<Rc<ParameterDeclarationClauseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterDeclarationClauseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 258, RULE_parameterDeclarationClause);
        let mut _localctx: Rc<ParameterDeclarationClauseContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule parameterDeclarationList*/
			recog.base.set_state(1556);
			recog.parameterDeclarationList()?;

			recog.base.set_state(1561);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Comma || _la==Ellipsis {
				{
				recog.base.set_state(1558);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==Comma {
					{
					recog.base.set_state(1557);
					recog.base.match_token(Comma,&mut recog.err_handler)?;

					}
				}

				recog.base.set_state(1560);
				recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parameterDeclarationList ----------------
pub type ParameterDeclarationListContextAll<'input> = ParameterDeclarationListContext<'input>;


pub type ParameterDeclarationListContext<'input> = BaseParserRuleContext<'input,ParameterDeclarationListContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterDeclarationListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ParameterDeclarationListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ParameterDeclarationListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parameterDeclarationList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_parameterDeclarationList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ParameterDeclarationListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameterDeclarationList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameterDeclarationList }
}
antlr_rust::tid!{ParameterDeclarationListContextExt<'a>}

impl<'input> ParameterDeclarationListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterDeclarationListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterDeclarationListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterDeclarationListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ParameterDeclarationListContextExt<'input>>{

fn parameterDeclaration_all(&self) ->  Vec<Rc<ParameterDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn parameterDeclaration(&self, i: usize) -> Option<Rc<ParameterDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}

}

impl<'input> ParameterDeclarationListContextAttrs<'input> for ParameterDeclarationListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameterDeclarationList(&mut self,)
	-> Result<Rc<ParameterDeclarationListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterDeclarationListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 260, RULE_parameterDeclarationList);
        let mut _localctx: Rc<ParameterDeclarationListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule parameterDeclaration*/
			recog.base.set_state(1563);
			recog.parameterDeclaration()?;

			recog.base.set_state(1568);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(201,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1564);
					recog.base.match_token(Comma,&mut recog.err_handler)?;

					/*InvokeRule parameterDeclaration*/
					recog.base.set_state(1565);
					recog.parameterDeclaration()?;

					}
					} 
				}
				recog.base.set_state(1570);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(201,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parameterDeclaration ----------------
pub type ParameterDeclarationContextAll<'input> = ParameterDeclarationContext<'input>;


pub type ParameterDeclarationContext<'input> = BaseParserRuleContext<'input,ParameterDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ParameterDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ParameterDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parameterDeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_parameterDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ParameterDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameterDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameterDeclaration }
}
antlr_rust::tid!{ParameterDeclarationContextExt<'a>}

impl<'input> ParameterDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterDeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ParameterDeclarationContextExt<'input>>{

fn declSpecifierSeq(&self) -> Option<Rc<DeclSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn declarator(&self) -> Option<Rc<DeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}
fn initializerClause(&self) -> Option<Rc<InitializerClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn abstractDeclarator(&self) -> Option<Rc<AbstractDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ParameterDeclarationContextAttrs<'input> for ParameterDeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameterDeclaration(&mut self,)
	-> Result<Rc<ParameterDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 262, RULE_parameterDeclaration);
        let mut _localctx: Rc<ParameterDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1572);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Alignas || _la==LeftBracket {
				{
				/*InvokeRule attributeSpecifierSeq*/
				recog.base.set_state(1571);
				recog.attributeSpecifierSeq()?;

				}
			}

			/*InvokeRule declSpecifierSeq*/
			recog.base.set_state(1574);
			recog.declSpecifierSeq()?;

			recog.base.set_state(1579);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(204,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule declarator*/
					recog.base.set_state(1575);
					recog.declarator()?;

					}
				}
			,
				2 =>{
					{
					recog.base.set_state(1577);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(203,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule abstractDeclarator*/
							recog.base.set_state(1576);
							recog.abstractDeclarator()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			recog.base.set_state(1583);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Assign {
				{
				recog.base.set_state(1581);
				recog.base.match_token(Assign,&mut recog.err_handler)?;

				/*InvokeRule initializerClause*/
				recog.base.set_state(1582);
				recog.initializerClause()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionDefinition ----------------
pub type FunctionDefinitionContextAll<'input> = FunctionDefinitionContext<'input>;


pub type FunctionDefinitionContext<'input> = BaseParserRuleContext<'input,FunctionDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for FunctionDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for FunctionDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionDefinition(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_functionDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FunctionDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionDefinition }
}
antlr_rust::tid!{FunctionDefinitionContextExt<'a>}

impl<'input> FunctionDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionDefinitionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<FunctionDefinitionContextExt<'input>>{

fn declarator(&self) -> Option<Rc<DeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionBody(&self) -> Option<Rc<FunctionBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn declSpecifierSeq(&self) -> Option<Rc<DeclSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn virtualSpecifierSeq(&self) -> Option<Rc<VirtualSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FunctionDefinitionContextAttrs<'input> for FunctionDefinitionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionDefinition(&mut self,)
	-> Result<Rc<FunctionDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 264, RULE_functionDefinition);
        let mut _localctx: Rc<FunctionDefinitionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1586);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Alignas || _la==LeftBracket {
				{
				/*InvokeRule attributeSpecifierSeq*/
				recog.base.set_state(1585);
				recog.attributeSpecifierSeq()?;

				}
			}

			recog.base.set_state(1589);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(207,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule declSpecifierSeq*/
					recog.base.set_state(1588);
					recog.declSpecifierSeq()?;

					}
				}

				_ => {}
			}
			/*InvokeRule declarator*/
			recog.base.set_state(1591);
			recog.declarator()?;

			recog.base.set_state(1593);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Final || _la==Override {
				{
				/*InvokeRule virtualSpecifierSeq*/
				recog.base.set_state(1592);
				recog.virtualSpecifierSeq()?;

				}
			}

			/*InvokeRule functionBody*/
			recog.base.set_state(1595);
			recog.functionBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionBody ----------------
pub type FunctionBodyContextAll<'input> = FunctionBodyContext<'input>;


pub type FunctionBodyContext<'input> = BaseParserRuleContext<'input,FunctionBodyContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for FunctionBodyContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for FunctionBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionBody(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_functionBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FunctionBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionBody }
}
antlr_rust::tid!{FunctionBodyContextExt<'a>}

impl<'input> FunctionBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionBodyContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<FunctionBodyContextExt<'input>>{

fn compoundStatement(&self) -> Option<Rc<CompoundStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constructorInitializer(&self) -> Option<Rc<ConstructorInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionTryBlock(&self) -> Option<Rc<FunctionTryBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}
/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}
/// Retrieves first TerminalNode corresponding to token Default
/// Returns `None` if there is no child corresponding to token Default
fn Default(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Default, 0)
}
/// Retrieves first TerminalNode corresponding to token Delete
/// Returns `None` if there is no child corresponding to token Delete
fn Delete(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Delete, 0)
}

}

impl<'input> FunctionBodyContextAttrs<'input> for FunctionBodyContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionBody(&mut self,)
	-> Result<Rc<FunctionBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 266, RULE_functionBody);
        let mut _localctx: Rc<FunctionBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1605);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LeftBrace | Colon 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1598);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Colon {
						{
						/*InvokeRule constructorInitializer*/
						recog.base.set_state(1597);
						recog.constructorInitializer()?;

						}
					}

					/*InvokeRule compoundStatement*/
					recog.base.set_state(1600);
					recog.compoundStatement()?;

					}
				}

			 Try 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule functionTryBlock*/
					recog.base.set_state(1601);
					recog.functionTryBlock()?;

					}
				}

			 Assign 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1602);
					recog.base.match_token(Assign,&mut recog.err_handler)?;

					recog.base.set_state(1603);
					_la = recog.base.input.la(1);
					if { !(_la==Default || _la==Delete) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(1604);
					recog.base.match_token(Semi,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- initializer ----------------
pub type InitializerContextAll<'input> = InitializerContext<'input>;


pub type InitializerContext<'input> = BaseParserRuleContext<'input,InitializerContextExt<'input>>;

#[derive(Clone)]
pub struct InitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for InitializerContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for InitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_initializer(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_initializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_initializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_initializer }
}
antlr_rust::tid!{InitializerContextExt<'a>}

impl<'input> InitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InitializerContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<InitializerContextExt<'input>>{

fn braceOrEqualInitializer(&self) -> Option<Rc<BraceOrEqualInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn expressionList(&self) -> Option<Rc<ExpressionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}

}

impl<'input> InitializerContextAttrs<'input> for InitializerContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn initializer(&mut self,)
	-> Result<Rc<InitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 268, RULE_initializer);
        let mut _localctx: Rc<InitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1612);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LeftBrace | Assign 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule braceOrEqualInitializer*/
					recog.base.set_state(1607);
					recog.braceOrEqualInitializer()?;

					}
				}

			 LeftParen 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1608);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule expressionList*/
					recog.base.set_state(1609);
					recog.expressionList()?;

					recog.base.set_state(1610);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- braceOrEqualInitializer ----------------
pub type BraceOrEqualInitializerContextAll<'input> = BraceOrEqualInitializerContext<'input>;


pub type BraceOrEqualInitializerContext<'input> = BaseParserRuleContext<'input,BraceOrEqualInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct BraceOrEqualInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for BraceOrEqualInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for BraceOrEqualInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_braceOrEqualInitializer(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_braceOrEqualInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BraceOrEqualInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_braceOrEqualInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_braceOrEqualInitializer }
}
antlr_rust::tid!{BraceOrEqualInitializerContextExt<'a>}

impl<'input> BraceOrEqualInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BraceOrEqualInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BraceOrEqualInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BraceOrEqualInitializerContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<BraceOrEqualInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}
fn initializerClause(&self) -> Option<Rc<InitializerClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn bracedInitList(&self) -> Option<Rc<BracedInitListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BraceOrEqualInitializerContextAttrs<'input> for BraceOrEqualInitializerContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn braceOrEqualInitializer(&mut self,)
	-> Result<Rc<BraceOrEqualInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BraceOrEqualInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 270, RULE_braceOrEqualInitializer);
        let mut _localctx: Rc<BraceOrEqualInitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1617);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Assign 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1614);
					recog.base.match_token(Assign,&mut recog.err_handler)?;

					/*InvokeRule initializerClause*/
					recog.base.set_state(1615);
					recog.initializerClause()?;

					}
				}

			 LeftBrace 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule bracedInitList*/
					recog.base.set_state(1616);
					recog.bracedInitList()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- initializerClause ----------------
pub type InitializerClauseContextAll<'input> = InitializerClauseContext<'input>;


pub type InitializerClauseContext<'input> = BaseParserRuleContext<'input,InitializerClauseContextExt<'input>>;

#[derive(Clone)]
pub struct InitializerClauseContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for InitializerClauseContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for InitializerClauseContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_initializerClause(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_initializerClause(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InitializerClauseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_initializerClause }
	//fn type_rule_index() -> usize where Self: Sized { RULE_initializerClause }
}
antlr_rust::tid!{InitializerClauseContextExt<'a>}

impl<'input> InitializerClauseContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InitializerClauseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InitializerClauseContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InitializerClauseContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<InitializerClauseContextExt<'input>>{

fn assignmentExpression(&self) -> Option<Rc<AssignmentExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn bracedInitList(&self) -> Option<Rc<BracedInitListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InitializerClauseContextAttrs<'input> for InitializerClauseContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn initializerClause(&mut self,)
	-> Result<Rc<InitializerClauseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InitializerClauseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 272, RULE_initializerClause);
        let mut _localctx: Rc<InitializerClauseContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1621);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 IntegerLiteral | CharacterLiteral | FloatingLiteral | StringLiteral |
			 BooleanLiteral | PointerLiteral | UserDefinedLiteral | Alignof | Auto |
			 Bool | Char | Char16 | Char32 | Const_cast | Decltype | Delete | Double |
			 Dynamic_cast | Float | Int | Long | New | Noexcept | Operator | Reinterpret_cast |
			 Short | Signed | Sizeof | Static_cast | This | Throw | Typeid_ | Typename_ |
			 Unsigned | Void | Wchar | LeftParen | LeftBracket | Plus | Minus | Star |
			 And | Or | Tilde | Not | PlusPlus | MinusMinus | Doublecolon | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule assignmentExpression*/
					recog.base.set_state(1619);
					recog.assignmentExpression()?;

					}
				}

			 LeftBrace 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule bracedInitList*/
					recog.base.set_state(1620);
					recog.bracedInitList()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- initializerList ----------------
pub type InitializerListContextAll<'input> = InitializerListContext<'input>;


pub type InitializerListContext<'input> = BaseParserRuleContext<'input,InitializerListContextExt<'input>>;

#[derive(Clone)]
pub struct InitializerListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for InitializerListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for InitializerListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_initializerList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_initializerList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InitializerListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_initializerList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_initializerList }
}
antlr_rust::tid!{InitializerListContextExt<'a>}

impl<'input> InitializerListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InitializerListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InitializerListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InitializerListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<InitializerListContextExt<'input>>{

fn initializerClause_all(&self) ->  Vec<Rc<InitializerClauseContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn initializerClause(&self, i: usize) -> Option<Rc<InitializerClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Ellipsis in current rule
fn Ellipsis_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Ellipsis, starting from 0.
/// Returns `None` if number of children corresponding to token Ellipsis is less or equal than `i`.
fn Ellipsis(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}

}

impl<'input> InitializerListContextAttrs<'input> for InitializerListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn initializerList(&mut self,)
	-> Result<Rc<InitializerListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InitializerListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 274, RULE_initializerList);
        let mut _localctx: Rc<InitializerListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule initializerClause*/
			recog.base.set_state(1623);
			recog.initializerClause()?;

			recog.base.set_state(1625);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Ellipsis {
				{
				recog.base.set_state(1624);
				recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1634);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(216,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1627);
					recog.base.match_token(Comma,&mut recog.err_handler)?;

					/*InvokeRule initializerClause*/
					recog.base.set_state(1628);
					recog.initializerClause()?;

					recog.base.set_state(1630);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Ellipsis {
						{
						recog.base.set_state(1629);
						recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

						}
					}

					}
					} 
				}
				recog.base.set_state(1636);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(216,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- bracedInitList ----------------
pub type BracedInitListContextAll<'input> = BracedInitListContext<'input>;


pub type BracedInitListContext<'input> = BaseParserRuleContext<'input,BracedInitListContextExt<'input>>;

#[derive(Clone)]
pub struct BracedInitListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for BracedInitListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for BracedInitListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_bracedInitList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_bracedInitList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BracedInitListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_bracedInitList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_bracedInitList }
}
antlr_rust::tid!{BracedInitListContextExt<'a>}

impl<'input> BracedInitListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BracedInitListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BracedInitListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BracedInitListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<BracedInitListContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LeftBrace
/// Returns `None` if there is no child corresponding to token LeftBrace
fn LeftBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBrace, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBrace
/// Returns `None` if there is no child corresponding to token RightBrace
fn RightBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBrace, 0)
}
fn initializerList(&self) -> Option<Rc<InitializerListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Comma
/// Returns `None` if there is no child corresponding to token Comma
fn Comma(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, 0)
}

}

impl<'input> BracedInitListContextAttrs<'input> for BracedInitListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn bracedInitList(&mut self,)
	-> Result<Rc<BracedInitListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BracedInitListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 276, RULE_bracedInitList);
        let mut _localctx: Rc<BracedInitListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1637);
			recog.base.match_token(LeftBrace,&mut recog.err_handler)?;

			recog.base.set_state(1642);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 71)) & !0x3f) == 0 && ((1usize << (_la - 71)) & ((1usize << (Throw - 71)) | (1usize << (Typeid_ - 71)) | (1usize << (Typename_ - 71)) | (1usize << (Unsigned - 71)) | (1usize << (Void - 71)) | (1usize << (Wchar - 71)) | (1usize << (LeftParen - 71)) | (1usize << (LeftBracket - 71)) | (1usize << (LeftBrace - 71)) | (1usize << (Plus - 71)) | (1usize << (Minus - 71)) | (1usize << (Star - 71)) | (1usize << (And - 71)) | (1usize << (Or - 71)) | (1usize << (Tilde - 71)) | (1usize << (Not - 71)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
				{
				/*InvokeRule initializerList*/
				recog.base.set_state(1638);
				recog.initializerList()?;

				recog.base.set_state(1640);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==Comma {
					{
					recog.base.set_state(1639);
					recog.base.match_token(Comma,&mut recog.err_handler)?;

					}
				}

				}
			}

			recog.base.set_state(1644);
			recog.base.match_token(RightBrace,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- className ----------------
pub type ClassNameContextAll<'input> = ClassNameContext<'input>;


pub type ClassNameContext<'input> = BaseParserRuleContext<'input,ClassNameContextExt<'input>>;

#[derive(Clone)]
pub struct ClassNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ClassNameContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ClassNameContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_className(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_className(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_className }
	//fn type_rule_index() -> usize where Self: Sized { RULE_className }
}
antlr_rust::tid!{ClassNameContextExt<'a>}

impl<'input> ClassNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassNameContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ClassNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn simpleTemplateId(&self) -> Option<Rc<SimpleTemplateIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassNameContextAttrs<'input> for ClassNameContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn className(&mut self,)
	-> Result<Rc<ClassNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 278, RULE_className);
        let mut _localctx: Rc<ClassNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1648);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(219,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1646);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule simpleTemplateId*/
					recog.base.set_state(1647);
					recog.simpleTemplateId()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classSpecifier ----------------
pub type ClassSpecifierContextAll<'input> = ClassSpecifierContext<'input>;


pub type ClassSpecifierContext<'input> = BaseParserRuleContext<'input,ClassSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct ClassSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ClassSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ClassSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_classSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classSpecifier }
}
antlr_rust::tid!{ClassSpecifierContextExt<'a>}

impl<'input> ClassSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ClassSpecifierContextExt<'input>>{

fn classHead(&self) -> Option<Rc<ClassHeadContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftBrace
/// Returns `None` if there is no child corresponding to token LeftBrace
fn LeftBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBrace, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBrace
/// Returns `None` if there is no child corresponding to token RightBrace
fn RightBrace(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBrace, 0)
}
fn memberSpecification(&self) -> Option<Rc<MemberSpecificationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassSpecifierContextAttrs<'input> for ClassSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classSpecifier(&mut self,)
	-> Result<Rc<ClassSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 280, RULE_classSpecifier);
        let mut _localctx: Rc<ClassSpecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule classHead*/
			recog.base.set_state(1650);
			recog.classHead()?;

			recog.base.set_state(1651);
			recog.base.match_token(LeftBrace,&mut recog.err_handler)?;

			recog.base.set_state(1653);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 10)) & !0x3f) == 0 && ((1usize << (_la - 10)) & ((1usize << (Alignas - 10)) | (1usize << (Auto - 10)) | (1usize << (Bool - 10)) | (1usize << (Char - 10)) | (1usize << (Char16 - 10)) | (1usize << (Char32 - 10)) | (1usize << (Class - 10)) | (1usize << (Const - 10)) | (1usize << (Constexpr - 10)) | (1usize << (Decltype - 10)) | (1usize << (Double - 10)) | (1usize << (Enum - 10)) | (1usize << (Explicit - 10)) | (1usize << (Extern - 10)) | (1usize << (Float - 10)) | (1usize << (Friend - 10)))) != 0) || ((((_la - 44)) & !0x3f) == 0 && ((1usize << (_la - 44)) & ((1usize << (Inline - 44)) | (1usize << (Int - 44)) | (1usize << (Long - 44)) | (1usize << (Mutable - 44)) | (1usize << (Operator - 44)) | (1usize << (Private - 44)) | (1usize << (Protected - 44)) | (1usize << (Public - 44)) | (1usize << (Register - 44)) | (1usize << (Short - 44)) | (1usize << (Signed - 44)) | (1usize << (Static - 44)) | (1usize << (Static_assert - 44)) | (1usize << (Struct - 44)) | (1usize << (Template - 44)) | (1usize << (Thread_local - 44)) | (1usize << (Typedef - 44)))) != 0) || ((((_la - 76)) & !0x3f) == 0 && ((1usize << (_la - 76)) & ((1usize << (Typename_ - 76)) | (1usize << (Union - 76)) | (1usize << (Unsigned - 76)) | (1usize << (Using - 76)) | (1usize << (Virtual - 76)) | (1usize << (Void - 76)) | (1usize << (Volatile - 76)) | (1usize << (Wchar - 76)) | (1usize << (LeftParen - 76)) | (1usize << (LeftBracket - 76)) | (1usize << (Star - 76)) | (1usize << (And - 76)) | (1usize << (Tilde - 76)))) != 0) || ((((_la - 118)) & !0x3f) == 0 && ((1usize << (_la - 118)) & ((1usize << (AndAnd - 118)) | (1usize << (Colon - 118)) | (1usize << (Doublecolon - 118)) | (1usize << (Semi - 118)) | (1usize << (Ellipsis - 118)) | (1usize << (Identifier - 118)))) != 0) {
				{
				/*InvokeRule memberSpecification*/
				recog.base.set_state(1652);
				recog.memberSpecification()?;

				}
			}

			recog.base.set_state(1655);
			recog.base.match_token(RightBrace,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classHead ----------------
pub type ClassHeadContextAll<'input> = ClassHeadContext<'input>;


pub type ClassHeadContext<'input> = BaseParserRuleContext<'input,ClassHeadContextExt<'input>>;

#[derive(Clone)]
pub struct ClassHeadContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ClassHeadContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ClassHeadContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classHead(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_classHead(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassHeadContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classHead }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classHead }
}
antlr_rust::tid!{ClassHeadContextExt<'a>}

impl<'input> ClassHeadContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassHeadContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassHeadContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassHeadContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ClassHeadContextExt<'input>>{

fn classKey(&self) -> Option<Rc<ClassKeyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classHeadName(&self) -> Option<Rc<ClassHeadNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn baseClause(&self) -> Option<Rc<BaseClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classVirtSpecifier(&self) -> Option<Rc<ClassVirtSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Union
/// Returns `None` if there is no child corresponding to token Union
fn Union(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Union, 0)
}

}

impl<'input> ClassHeadContextAttrs<'input> for ClassHeadContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classHead(&mut self,)
	-> Result<Rc<ClassHeadContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassHeadContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 282, RULE_classHead);
        let mut _localctx: Rc<ClassHeadContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1680);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Class | Struct 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classKey*/
					recog.base.set_state(1657);
					recog.classKey()?;

					recog.base.set_state(1659);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Alignas || _la==LeftBracket {
						{
						/*InvokeRule attributeSpecifierSeq*/
						recog.base.set_state(1658);
						recog.attributeSpecifierSeq()?;

						}
					}

					recog.base.set_state(1665);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Decltype || _la==Doublecolon || _la==Identifier {
						{
						/*InvokeRule classHeadName*/
						recog.base.set_state(1661);
						recog.classHeadName()?;

						recog.base.set_state(1663);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==Final {
							{
							/*InvokeRule classVirtSpecifier*/
							recog.base.set_state(1662);
							recog.classVirtSpecifier()?;

							}
						}

						}
					}

					recog.base.set_state(1668);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Colon {
						{
						/*InvokeRule baseClause*/
						recog.base.set_state(1667);
						recog.baseClause()?;

						}
					}

					}
				}

			 Union 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1670);
					recog.base.match_token(Union,&mut recog.err_handler)?;

					recog.base.set_state(1672);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Alignas || _la==LeftBracket {
						{
						/*InvokeRule attributeSpecifierSeq*/
						recog.base.set_state(1671);
						recog.attributeSpecifierSeq()?;

						}
					}

					recog.base.set_state(1678);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Decltype || _la==Doublecolon || _la==Identifier {
						{
						/*InvokeRule classHeadName*/
						recog.base.set_state(1674);
						recog.classHeadName()?;

						recog.base.set_state(1676);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==Final {
							{
							/*InvokeRule classVirtSpecifier*/
							recog.base.set_state(1675);
							recog.classVirtSpecifier()?;

							}
						}

						}
					}

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classHeadName ----------------
pub type ClassHeadNameContextAll<'input> = ClassHeadNameContext<'input>;


pub type ClassHeadNameContext<'input> = BaseParserRuleContext<'input,ClassHeadNameContextExt<'input>>;

#[derive(Clone)]
pub struct ClassHeadNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ClassHeadNameContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ClassHeadNameContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classHeadName(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_classHeadName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassHeadNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classHeadName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classHeadName }
}
antlr_rust::tid!{ClassHeadNameContextExt<'a>}

impl<'input> ClassHeadNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassHeadNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassHeadNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassHeadNameContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ClassHeadNameContextExt<'input>>{

fn className(&self) -> Option<Rc<ClassNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassHeadNameContextAttrs<'input> for ClassHeadNameContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classHeadName(&mut self,)
	-> Result<Rc<ClassHeadNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassHeadNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 284, RULE_classHeadName);
        let mut _localctx: Rc<ClassHeadNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1683);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(229,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule nestedNameSpecifier*/
					recog.base.set_state(1682);
					recog.nestedNameSpecifier_rec(0)?;

					}
				}

				_ => {}
			}
			/*InvokeRule className*/
			recog.base.set_state(1685);
			recog.className()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classVirtSpecifier ----------------
pub type ClassVirtSpecifierContextAll<'input> = ClassVirtSpecifierContext<'input>;


pub type ClassVirtSpecifierContext<'input> = BaseParserRuleContext<'input,ClassVirtSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct ClassVirtSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ClassVirtSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ClassVirtSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classVirtSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_classVirtSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassVirtSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classVirtSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classVirtSpecifier }
}
antlr_rust::tid!{ClassVirtSpecifierContextExt<'a>}

impl<'input> ClassVirtSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassVirtSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassVirtSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassVirtSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ClassVirtSpecifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Final
/// Returns `None` if there is no child corresponding to token Final
fn Final(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Final, 0)
}

}

impl<'input> ClassVirtSpecifierContextAttrs<'input> for ClassVirtSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classVirtSpecifier(&mut self,)
	-> Result<Rc<ClassVirtSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassVirtSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 286, RULE_classVirtSpecifier);
        let mut _localctx: Rc<ClassVirtSpecifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1687);
			recog.base.match_token(Final,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classKey ----------------
pub type ClassKeyContextAll<'input> = ClassKeyContext<'input>;


pub type ClassKeyContext<'input> = BaseParserRuleContext<'input,ClassKeyContextExt<'input>>;

#[derive(Clone)]
pub struct ClassKeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ClassKeyContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ClassKeyContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classKey(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_classKey(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classKey }
}
antlr_rust::tid!{ClassKeyContextExt<'a>}

impl<'input> ClassKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassKeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassKeyContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ClassKeyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Class
/// Returns `None` if there is no child corresponding to token Class
fn Class(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Class, 0)
}
/// Retrieves first TerminalNode corresponding to token Struct
/// Returns `None` if there is no child corresponding to token Struct
fn Struct(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Struct, 0)
}

}

impl<'input> ClassKeyContextAttrs<'input> for ClassKeyContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classKey(&mut self,)
	-> Result<Rc<ClassKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 288, RULE_classKey);
        let mut _localctx: Rc<ClassKeyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1689);
			_la = recog.base.input.la(1);
			if { !(_la==Class || _la==Struct) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memberSpecification ----------------
pub type MemberSpecificationContextAll<'input> = MemberSpecificationContext<'input>;


pub type MemberSpecificationContext<'input> = BaseParserRuleContext<'input,MemberSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct MemberSpecificationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for MemberSpecificationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for MemberSpecificationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_memberSpecification(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_memberSpecification(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MemberSpecificationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memberSpecification }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memberSpecification }
}
antlr_rust::tid!{MemberSpecificationContextExt<'a>}

impl<'input> MemberSpecificationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemberSpecificationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemberSpecificationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemberSpecificationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<MemberSpecificationContextExt<'input>>{

fn memberdeclaration_all(&self) ->  Vec<Rc<MemberdeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn memberdeclaration(&self, i: usize) -> Option<Rc<MemberdeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn accessSpecifier_all(&self) ->  Vec<Rc<AccessSpecifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn accessSpecifier(&self, i: usize) -> Option<Rc<AccessSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Colon in current rule
fn Colon_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Colon, starting from 0.
/// Returns `None` if number of children corresponding to token Colon is less or equal than `i`.
fn Colon(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Colon, i)
}

}

impl<'input> MemberSpecificationContextAttrs<'input> for MemberSpecificationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memberSpecification(&mut self,)
	-> Result<Rc<MemberSpecificationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemberSpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 290, RULE_memberSpecification);
        let mut _localctx: Rc<MemberSpecificationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1695); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				recog.base.set_state(1695);
				recog.err_handler.sync(&mut recog.base)?;
				match recog.base.input.la(1) {
				 Alignas | Auto | Bool | Char | Char16 | Char32 | Class | Const | Constexpr |
				 Decltype | Double | Enum | Explicit | Extern | Float | Friend | Inline |
				 Int | Long | Mutable | Operator | Register | Short | Signed | Static |
				 Static_assert | Struct | Template | Thread_local | Typedef | Typename_ |
				 Union | Unsigned | Using | Virtual | Void | Volatile | Wchar | LeftParen |
				 LeftBracket | Star | And | Tilde | AndAnd | Colon | Doublecolon | Semi |
				 Ellipsis | Identifier 
					=> {
						{
						/*InvokeRule memberdeclaration*/
						recog.base.set_state(1691);
						recog.memberdeclaration()?;

						}
					}

				 Private | Protected | Public 
					=> {
						{
						/*InvokeRule accessSpecifier*/
						recog.base.set_state(1692);
						recog.accessSpecifier()?;

						recog.base.set_state(1693);
						recog.base.match_token(Colon,&mut recog.err_handler)?;

						}
					}

					_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				}
				recog.base.set_state(1697); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !(((((_la - 10)) & !0x3f) == 0 && ((1usize << (_la - 10)) & ((1usize << (Alignas - 10)) | (1usize << (Auto - 10)) | (1usize << (Bool - 10)) | (1usize << (Char - 10)) | (1usize << (Char16 - 10)) | (1usize << (Char32 - 10)) | (1usize << (Class - 10)) | (1usize << (Const - 10)) | (1usize << (Constexpr - 10)) | (1usize << (Decltype - 10)) | (1usize << (Double - 10)) | (1usize << (Enum - 10)) | (1usize << (Explicit - 10)) | (1usize << (Extern - 10)) | (1usize << (Float - 10)) | (1usize << (Friend - 10)))) != 0) || ((((_la - 44)) & !0x3f) == 0 && ((1usize << (_la - 44)) & ((1usize << (Inline - 44)) | (1usize << (Int - 44)) | (1usize << (Long - 44)) | (1usize << (Mutable - 44)) | (1usize << (Operator - 44)) | (1usize << (Private - 44)) | (1usize << (Protected - 44)) | (1usize << (Public - 44)) | (1usize << (Register - 44)) | (1usize << (Short - 44)) | (1usize << (Signed - 44)) | (1usize << (Static - 44)) | (1usize << (Static_assert - 44)) | (1usize << (Struct - 44)) | (1usize << (Template - 44)) | (1usize << (Thread_local - 44)) | (1usize << (Typedef - 44)))) != 0) || ((((_la - 76)) & !0x3f) == 0 && ((1usize << (_la - 76)) & ((1usize << (Typename_ - 76)) | (1usize << (Union - 76)) | (1usize << (Unsigned - 76)) | (1usize << (Using - 76)) | (1usize << (Virtual - 76)) | (1usize << (Void - 76)) | (1usize << (Volatile - 76)) | (1usize << (Wchar - 76)) | (1usize << (LeftParen - 76)) | (1usize << (LeftBracket - 76)) | (1usize << (Star - 76)) | (1usize << (And - 76)) | (1usize << (Tilde - 76)))) != 0) || ((((_la - 118)) & !0x3f) == 0 && ((1usize << (_la - 118)) & ((1usize << (AndAnd - 118)) | (1usize << (Colon - 118)) | (1usize << (Doublecolon - 118)) | (1usize << (Semi - 118)) | (1usize << (Ellipsis - 118)) | (1usize << (Identifier - 118)))) != 0)) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memberdeclaration ----------------
pub type MemberdeclarationContextAll<'input> = MemberdeclarationContext<'input>;


pub type MemberdeclarationContext<'input> = BaseParserRuleContext<'input,MemberdeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct MemberdeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for MemberdeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for MemberdeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_memberdeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_memberdeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MemberdeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memberdeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memberdeclaration }
}
antlr_rust::tid!{MemberdeclarationContextExt<'a>}

impl<'input> MemberdeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemberdeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemberdeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemberdeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<MemberdeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Semi
/// Returns `None` if there is no child corresponding to token Semi
fn Semi(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Semi, 0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn declSpecifierSeq(&self) -> Option<Rc<DeclSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn memberDeclaratorList(&self) -> Option<Rc<MemberDeclaratorListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionDefinition(&self) -> Option<Rc<FunctionDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn usingDeclaration(&self) -> Option<Rc<UsingDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn staticAssertDeclaration(&self) -> Option<Rc<StaticAssertDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn templateDeclaration(&self) -> Option<Rc<TemplateDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aliasDeclaration(&self) -> Option<Rc<AliasDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn emptyDeclaration_(&self) -> Option<Rc<EmptyDeclaration_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MemberdeclarationContextAttrs<'input> for MemberdeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memberdeclaration(&mut self,)
	-> Result<Rc<MemberdeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemberdeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 292, RULE_memberdeclaration);
        let mut _localctx: Rc<MemberdeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1715);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(235,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1700);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(232,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule attributeSpecifierSeq*/
							recog.base.set_state(1699);
							recog.attributeSpecifierSeq()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1703);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(233,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule declSpecifierSeq*/
							recog.base.set_state(1702);
							recog.declSpecifierSeq()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1706);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Alignas || _la==Decltype || _la==Operator || ((((_la - 85)) & !0x3f) == 0 && ((1usize << (_la - 85)) & ((1usize << (LeftParen - 85)) | (1usize << (LeftBracket - 85)) | (1usize << (Star - 85)) | (1usize << (And - 85)) | (1usize << (Tilde - 85)))) != 0) || ((((_la - 118)) & !0x3f) == 0 && ((1usize << (_la - 118)) & ((1usize << (AndAnd - 118)) | (1usize << (Colon - 118)) | (1usize << (Doublecolon - 118)) | (1usize << (Ellipsis - 118)) | (1usize << (Identifier - 118)))) != 0) {
						{
						/*InvokeRule memberDeclaratorList*/
						recog.base.set_state(1705);
						recog.memberDeclaratorList()?;

						}
					}

					recog.base.set_state(1708);
					recog.base.match_token(Semi,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule functionDefinition*/
					recog.base.set_state(1709);
					recog.functionDefinition()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule usingDeclaration*/
					recog.base.set_state(1710);
					recog.usingDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule staticAssertDeclaration*/
					recog.base.set_state(1711);
					recog.staticAssertDeclaration()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule templateDeclaration*/
					recog.base.set_state(1712);
					recog.templateDeclaration()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule aliasDeclaration*/
					recog.base.set_state(1713);
					recog.aliasDeclaration()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule emptyDeclaration_*/
					recog.base.set_state(1714);
					recog.emptyDeclaration_()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memberDeclaratorList ----------------
pub type MemberDeclaratorListContextAll<'input> = MemberDeclaratorListContext<'input>;


pub type MemberDeclaratorListContext<'input> = BaseParserRuleContext<'input,MemberDeclaratorListContextExt<'input>>;

#[derive(Clone)]
pub struct MemberDeclaratorListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for MemberDeclaratorListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for MemberDeclaratorListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_memberDeclaratorList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_memberDeclaratorList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MemberDeclaratorListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memberDeclaratorList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memberDeclaratorList }
}
antlr_rust::tid!{MemberDeclaratorListContextExt<'a>}

impl<'input> MemberDeclaratorListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemberDeclaratorListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemberDeclaratorListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemberDeclaratorListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<MemberDeclaratorListContextExt<'input>>{

fn memberDeclarator_all(&self) ->  Vec<Rc<MemberDeclaratorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn memberDeclarator(&self, i: usize) -> Option<Rc<MemberDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}

}

impl<'input> MemberDeclaratorListContextAttrs<'input> for MemberDeclaratorListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memberDeclaratorList(&mut self,)
	-> Result<Rc<MemberDeclaratorListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemberDeclaratorListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 294, RULE_memberDeclaratorList);
        let mut _localctx: Rc<MemberDeclaratorListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule memberDeclarator*/
			recog.base.set_state(1717);
			recog.memberDeclarator()?;

			recog.base.set_state(1722);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Comma {
				{
				{
				recog.base.set_state(1718);
				recog.base.match_token(Comma,&mut recog.err_handler)?;

				/*InvokeRule memberDeclarator*/
				recog.base.set_state(1719);
				recog.memberDeclarator()?;

				}
				}
				recog.base.set_state(1724);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memberDeclarator ----------------
pub type MemberDeclaratorContextAll<'input> = MemberDeclaratorContext<'input>;


pub type MemberDeclaratorContext<'input> = BaseParserRuleContext<'input,MemberDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct MemberDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for MemberDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for MemberDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_memberDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_memberDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MemberDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memberDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memberDeclarator }
}
antlr_rust::tid!{MemberDeclaratorContextExt<'a>}

impl<'input> MemberDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemberDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemberDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemberDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<MemberDeclaratorContextExt<'input>>{

fn declarator(&self) -> Option<Rc<DeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn virtualSpecifierSeq(&self) -> Option<Rc<VirtualSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pureSpecifier(&self) -> Option<Rc<PureSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn braceOrEqualInitializer(&self) -> Option<Rc<BraceOrEqualInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Colon
/// Returns `None` if there is no child corresponding to token Colon
fn Colon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Colon, 0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MemberDeclaratorContextAttrs<'input> for MemberDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memberDeclarator(&mut self,)
	-> Result<Rc<MemberDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemberDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 296, RULE_memberDeclarator);
        let mut _localctx: Rc<MemberDeclaratorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1745);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(240,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule declarator*/
					recog.base.set_state(1725);
					recog.declarator()?;

					recog.base.set_state(1734);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(237,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule virtualSpecifierSeq*/
							recog.base.set_state(1726);
							recog.virtualSpecifierSeq()?;

							}
						}
					,
						2 =>{
							{
							recog.base.set_state(1727);

							// TODO: confirm here: is_pure_sepcifier_allowed
							// if !({
							// 	match Rc::try_unwrap(_localctx) {
							// 		Ok(ctx) => ctx.is_pure_specifier_allowed(),
							// 		Err(_) => false
							// 	} 
							// }) {
							// 	Err(FailedPredicateError::new(&mut recog.base, Some(" self.IsPureSpecifierAllowed() ".to_owned()), None))?;
							// }
							/*InvokeRule pureSpecifier*/
							recog.base.set_state(1728);
							recog.pureSpecifier()?;

							}
						}
					,
						3 =>{
							{
							recog.base.set_state(1729);
							// TODO: confirm here: is_pure_sepcifier_allowed
							// if !( {
							// 	match Rc::try_unwrap(_localctx) {
							// 		Ok(ctx) => ctx.is_pure_specifier_allowed(),
							// 		Err(_) => false
							// 	} 
							// }) {
							// 	Err(FailedPredicateError::new(&mut recog.base, Some(" self.IsPureSpecifierAllowed() ".to_owned()), None))?;
							// }
							/*InvokeRule virtualSpecifierSeq*/
							recog.base.set_state(1730);
							recog.virtualSpecifierSeq()?;

							/*InvokeRule pureSpecifier*/
							recog.base.set_state(1731);
							recog.pureSpecifier()?;

							}
						}
					,
						4 =>{
							{
							/*InvokeRule braceOrEqualInitializer*/
							recog.base.set_state(1733);
							recog.braceOrEqualInitializer()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule declarator*/
					recog.base.set_state(1736);
					recog.declarator()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1738);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Identifier {
						{
						recog.base.set_state(1737);
						recog.base.match_token(Identifier,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1741);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Alignas || _la==LeftBracket {
						{
						/*InvokeRule attributeSpecifierSeq*/
						recog.base.set_state(1740);
						recog.attributeSpecifierSeq()?;

						}
					}

					recog.base.set_state(1743);
					recog.base.match_token(Colon,&mut recog.err_handler)?;

					/*InvokeRule constantExpression*/
					recog.base.set_state(1744);
					recog.constantExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- virtualSpecifierSeq ----------------
pub type VirtualSpecifierSeqContextAll<'input> = VirtualSpecifierSeqContext<'input>;


pub type VirtualSpecifierSeqContext<'input> = BaseParserRuleContext<'input,VirtualSpecifierSeqContextExt<'input>>;

#[derive(Clone)]
pub struct VirtualSpecifierSeqContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for VirtualSpecifierSeqContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for VirtualSpecifierSeqContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_virtualSpecifierSeq(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_virtualSpecifierSeq(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for VirtualSpecifierSeqContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_virtualSpecifierSeq }
	//fn type_rule_index() -> usize where Self: Sized { RULE_virtualSpecifierSeq }
}
antlr_rust::tid!{VirtualSpecifierSeqContextExt<'a>}

impl<'input> VirtualSpecifierSeqContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VirtualSpecifierSeqContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VirtualSpecifierSeqContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VirtualSpecifierSeqContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<VirtualSpecifierSeqContextExt<'input>>{

fn virtualSpecifier_all(&self) ->  Vec<Rc<VirtualSpecifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn virtualSpecifier(&self, i: usize) -> Option<Rc<VirtualSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> VirtualSpecifierSeqContextAttrs<'input> for VirtualSpecifierSeqContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn virtualSpecifierSeq(&mut self,)
	-> Result<Rc<VirtualSpecifierSeqContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VirtualSpecifierSeqContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 298, RULE_virtualSpecifierSeq);
        let mut _localctx: Rc<VirtualSpecifierSeqContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1748); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule virtualSpecifier*/
				recog.base.set_state(1747);
				recog.virtualSpecifier()?;

				}
				}
				recog.base.set_state(1750); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !(_la==Final || _la==Override) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- virtualSpecifier ----------------
pub type VirtualSpecifierContextAll<'input> = VirtualSpecifierContext<'input>;


pub type VirtualSpecifierContext<'input> = BaseParserRuleContext<'input,VirtualSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct VirtualSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for VirtualSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for VirtualSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_virtualSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_virtualSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for VirtualSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_virtualSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_virtualSpecifier }
}
antlr_rust::tid!{VirtualSpecifierContextExt<'a>}

impl<'input> VirtualSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VirtualSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VirtualSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VirtualSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<VirtualSpecifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Override
/// Returns `None` if there is no child corresponding to token Override
fn Override(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Override, 0)
}
/// Retrieves first TerminalNode corresponding to token Final
/// Returns `None` if there is no child corresponding to token Final
fn Final(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Final, 0)
}

}

impl<'input> VirtualSpecifierContextAttrs<'input> for VirtualSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn virtualSpecifier(&mut self,)
	-> Result<Rc<VirtualSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VirtualSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 300, RULE_virtualSpecifier);
        let mut _localctx: Rc<VirtualSpecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1752);
			_la = recog.base.input.la(1);
			if { !(_la==Final || _la==Override) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pureSpecifier ----------------
pub type PureSpecifierContextAll<'input> = PureSpecifierContext<'input>;


pub type PureSpecifierContext<'input> = BaseParserRuleContext<'input,PureSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct PureSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for PureSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for PureSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pureSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_pureSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PureSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pureSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pureSpecifier }
}
antlr_rust::tid!{PureSpecifierContextExt<'a>}

impl<'input> PureSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PureSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PureSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PureSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<PureSpecifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}
/// Retrieves first TerminalNode corresponding to token IntegerLiteral
/// Returns `None` if there is no child corresponding to token IntegerLiteral
fn IntegerLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(IntegerLiteral, 0)
}

}

impl<'input> PureSpecifierContextAttrs<'input> for PureSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pureSpecifier(&mut self,)
	-> Result<Rc<PureSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PureSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 302, RULE_pureSpecifier);
        let mut _localctx: Rc<PureSpecifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1754);
			recog.base.match_token(Assign,&mut recog.err_handler)?;

			recog.base.set_state(1755);
			recog.base.match_token(IntegerLiteral,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- baseClause ----------------
pub type BaseClauseContextAll<'input> = BaseClauseContext<'input>;


pub type BaseClauseContext<'input> = BaseParserRuleContext<'input,BaseClauseContextExt<'input>>;

#[derive(Clone)]
pub struct BaseClauseContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for BaseClauseContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for BaseClauseContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_baseClause(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_baseClause(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BaseClauseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_baseClause }
	//fn type_rule_index() -> usize where Self: Sized { RULE_baseClause }
}
antlr_rust::tid!{BaseClauseContextExt<'a>}

impl<'input> BaseClauseContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BaseClauseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BaseClauseContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BaseClauseContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<BaseClauseContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Colon
/// Returns `None` if there is no child corresponding to token Colon
fn Colon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Colon, 0)
}
fn baseSpecifierList(&self) -> Option<Rc<BaseSpecifierListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BaseClauseContextAttrs<'input> for BaseClauseContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn baseClause(&mut self,)
	-> Result<Rc<BaseClauseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BaseClauseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 304, RULE_baseClause);
        let mut _localctx: Rc<BaseClauseContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1757);
			recog.base.match_token(Colon,&mut recog.err_handler)?;

			/*InvokeRule baseSpecifierList*/
			recog.base.set_state(1758);
			recog.baseSpecifierList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- baseSpecifierList ----------------
pub type BaseSpecifierListContextAll<'input> = BaseSpecifierListContext<'input>;


pub type BaseSpecifierListContext<'input> = BaseParserRuleContext<'input,BaseSpecifierListContextExt<'input>>;

#[derive(Clone)]
pub struct BaseSpecifierListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for BaseSpecifierListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for BaseSpecifierListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_baseSpecifierList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_baseSpecifierList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BaseSpecifierListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_baseSpecifierList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_baseSpecifierList }
}
antlr_rust::tid!{BaseSpecifierListContextExt<'a>}

impl<'input> BaseSpecifierListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BaseSpecifierListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BaseSpecifierListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BaseSpecifierListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<BaseSpecifierListContextExt<'input>>{

fn baseSpecifier_all(&self) ->  Vec<Rc<BaseSpecifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn baseSpecifier(&self, i: usize) -> Option<Rc<BaseSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Ellipsis in current rule
fn Ellipsis_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Ellipsis, starting from 0.
/// Returns `None` if number of children corresponding to token Ellipsis is less or equal than `i`.
fn Ellipsis(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}

}

impl<'input> BaseSpecifierListContextAttrs<'input> for BaseSpecifierListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn baseSpecifierList(&mut self,)
	-> Result<Rc<BaseSpecifierListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BaseSpecifierListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 306, RULE_baseSpecifierList);
        let mut _localctx: Rc<BaseSpecifierListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule baseSpecifier*/
			recog.base.set_state(1760);
			recog.baseSpecifier()?;

			recog.base.set_state(1762);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Ellipsis {
				{
				recog.base.set_state(1761);
				recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1771);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Comma {
				{
				{
				recog.base.set_state(1764);
				recog.base.match_token(Comma,&mut recog.err_handler)?;

				/*InvokeRule baseSpecifier*/
				recog.base.set_state(1765);
				recog.baseSpecifier()?;

				recog.base.set_state(1767);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==Ellipsis {
					{
					recog.base.set_state(1766);
					recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

					}
				}

				}
				}
				recog.base.set_state(1773);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- baseSpecifier ----------------
pub type BaseSpecifierContextAll<'input> = BaseSpecifierContext<'input>;


pub type BaseSpecifierContext<'input> = BaseParserRuleContext<'input,BaseSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct BaseSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for BaseSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for BaseSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_baseSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_baseSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BaseSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_baseSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_baseSpecifier }
}
antlr_rust::tid!{BaseSpecifierContextExt<'a>}

impl<'input> BaseSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BaseSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BaseSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BaseSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<BaseSpecifierContextExt<'input>>{

fn baseTypeSpecifier(&self) -> Option<Rc<BaseTypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Virtual
/// Returns `None` if there is no child corresponding to token Virtual
fn Virtual(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Virtual, 0)
}
fn accessSpecifier(&self) -> Option<Rc<AccessSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BaseSpecifierContextAttrs<'input> for BaseSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn baseSpecifier(&mut self,)
	-> Result<Rc<BaseSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BaseSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 308, RULE_baseSpecifier);
        let mut _localctx: Rc<BaseSpecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1775);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Alignas || _la==LeftBracket {
				{
				/*InvokeRule attributeSpecifierSeq*/
				recog.base.set_state(1774);
				recog.attributeSpecifierSeq()?;

				}
			}

			recog.base.set_state(1789);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Decltype | Doublecolon | Identifier 
				=> {
					{
					/*InvokeRule baseTypeSpecifier*/
					recog.base.set_state(1777);
					recog.baseTypeSpecifier()?;

					}
				}

			 Virtual 
				=> {
					{
					recog.base.set_state(1778);
					recog.base.match_token(Virtual,&mut recog.err_handler)?;

					recog.base.set_state(1780);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if ((((_la - 54)) & !0x3f) == 0 && ((1usize << (_la - 54)) & ((1usize << (Private - 54)) | (1usize << (Protected - 54)) | (1usize << (Public - 54)))) != 0) {
						{
						/*InvokeRule accessSpecifier*/
						recog.base.set_state(1779);
						recog.accessSpecifier()?;

						}
					}

					/*InvokeRule baseTypeSpecifier*/
					recog.base.set_state(1782);
					recog.baseTypeSpecifier()?;

					}
				}

			 Private | Protected | Public 
				=> {
					{
					/*InvokeRule accessSpecifier*/
					recog.base.set_state(1783);
					recog.accessSpecifier()?;

					recog.base.set_state(1785);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Virtual {
						{
						recog.base.set_state(1784);
						recog.base.match_token(Virtual,&mut recog.err_handler)?;

						}
					}

					/*InvokeRule baseTypeSpecifier*/
					recog.base.set_state(1787);
					recog.baseTypeSpecifier()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classOrDeclType ----------------
pub type ClassOrDeclTypeContextAll<'input> = ClassOrDeclTypeContext<'input>;


pub type ClassOrDeclTypeContext<'input> = BaseParserRuleContext<'input,ClassOrDeclTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ClassOrDeclTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ClassOrDeclTypeContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ClassOrDeclTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classOrDeclType(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_classOrDeclType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassOrDeclTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classOrDeclType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classOrDeclType }
}
antlr_rust::tid!{ClassOrDeclTypeContextExt<'a>}

impl<'input> ClassOrDeclTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassOrDeclTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassOrDeclTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassOrDeclTypeContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ClassOrDeclTypeContextExt<'input>>{

fn className(&self) -> Option<Rc<ClassNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn decltypeSpecifier(&self) -> Option<Rc<DecltypeSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassOrDeclTypeContextAttrs<'input> for ClassOrDeclTypeContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classOrDeclType(&mut self,)
	-> Result<Rc<ClassOrDeclTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassOrDeclTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 310, RULE_classOrDeclType);
        let mut _localctx: Rc<ClassOrDeclTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1796);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(250,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1792);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(249,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule nestedNameSpecifier*/
							recog.base.set_state(1791);
							recog.nestedNameSpecifier_rec(0)?;

							}
						}

						_ => {}
					}
					/*InvokeRule className*/
					recog.base.set_state(1794);
					recog.className()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule decltypeSpecifier*/
					recog.base.set_state(1795);
					recog.decltypeSpecifier()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- baseTypeSpecifier ----------------
pub type BaseTypeSpecifierContextAll<'input> = BaseTypeSpecifierContext<'input>;


pub type BaseTypeSpecifierContext<'input> = BaseParserRuleContext<'input,BaseTypeSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct BaseTypeSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for BaseTypeSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for BaseTypeSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_baseTypeSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_baseTypeSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BaseTypeSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_baseTypeSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_baseTypeSpecifier }
}
antlr_rust::tid!{BaseTypeSpecifierContextExt<'a>}

impl<'input> BaseTypeSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BaseTypeSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BaseTypeSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BaseTypeSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<BaseTypeSpecifierContextExt<'input>>{

fn classOrDeclType(&self) -> Option<Rc<ClassOrDeclTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BaseTypeSpecifierContextAttrs<'input> for BaseTypeSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn baseTypeSpecifier(&mut self,)
	-> Result<Rc<BaseTypeSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BaseTypeSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 312, RULE_baseTypeSpecifier);
        let mut _localctx: Rc<BaseTypeSpecifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule classOrDeclType*/
			recog.base.set_state(1798);
			recog.classOrDeclType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- accessSpecifier ----------------
pub type AccessSpecifierContextAll<'input> = AccessSpecifierContext<'input>;


pub type AccessSpecifierContext<'input> = BaseParserRuleContext<'input,AccessSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct AccessSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for AccessSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for AccessSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_accessSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_accessSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AccessSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_accessSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_accessSpecifier }
}
antlr_rust::tid!{AccessSpecifierContextExt<'a>}

impl<'input> AccessSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AccessSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AccessSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AccessSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<AccessSpecifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Private
/// Returns `None` if there is no child corresponding to token Private
fn Private(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Private, 0)
}
/// Retrieves first TerminalNode corresponding to token Protected
/// Returns `None` if there is no child corresponding to token Protected
fn Protected(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Protected, 0)
}
/// Retrieves first TerminalNode corresponding to token Public
/// Returns `None` if there is no child corresponding to token Public
fn Public(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Public, 0)
}

}

impl<'input> AccessSpecifierContextAttrs<'input> for AccessSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn accessSpecifier(&mut self,)
	-> Result<Rc<AccessSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AccessSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 314, RULE_accessSpecifier);
        let mut _localctx: Rc<AccessSpecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1800);
			_la = recog.base.input.la(1);
			if { !(((((_la - 54)) & !0x3f) == 0 && ((1usize << (_la - 54)) & ((1usize << (Private - 54)) | (1usize << (Protected - 54)) | (1usize << (Public - 54)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- conversionFunctionId ----------------
pub type ConversionFunctionIdContextAll<'input> = ConversionFunctionIdContext<'input>;


pub type ConversionFunctionIdContext<'input> = BaseParserRuleContext<'input,ConversionFunctionIdContextExt<'input>>;

#[derive(Clone)]
pub struct ConversionFunctionIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ConversionFunctionIdContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ConversionFunctionIdContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_conversionFunctionId(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_conversionFunctionId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConversionFunctionIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conversionFunctionId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conversionFunctionId }
}
antlr_rust::tid!{ConversionFunctionIdContextExt<'a>}

impl<'input> ConversionFunctionIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConversionFunctionIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConversionFunctionIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConversionFunctionIdContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ConversionFunctionIdContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Operator
/// Returns `None` if there is no child corresponding to token Operator
fn Operator(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Operator, 0)
}
fn conversionTypeId(&self) -> Option<Rc<ConversionTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConversionFunctionIdContextAttrs<'input> for ConversionFunctionIdContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn conversionFunctionId(&mut self,)
	-> Result<Rc<ConversionFunctionIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConversionFunctionIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 316, RULE_conversionFunctionId);
        let mut _localctx: Rc<ConversionFunctionIdContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1802);
			recog.base.match_token(Operator,&mut recog.err_handler)?;

			/*InvokeRule conversionTypeId*/
			recog.base.set_state(1803);
			recog.conversionTypeId()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- conversionTypeId ----------------
pub type ConversionTypeIdContextAll<'input> = ConversionTypeIdContext<'input>;


pub type ConversionTypeIdContext<'input> = BaseParserRuleContext<'input,ConversionTypeIdContextExt<'input>>;

#[derive(Clone)]
pub struct ConversionTypeIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ConversionTypeIdContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ConversionTypeIdContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_conversionTypeId(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_conversionTypeId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConversionTypeIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conversionTypeId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conversionTypeId }
}
antlr_rust::tid!{ConversionTypeIdContextExt<'a>}

impl<'input> ConversionTypeIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConversionTypeIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConversionTypeIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConversionTypeIdContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ConversionTypeIdContextExt<'input>>{

fn typeSpecifierSeq(&self) -> Option<Rc<TypeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn conversionDeclarator(&self) -> Option<Rc<ConversionDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConversionTypeIdContextAttrs<'input> for ConversionTypeIdContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn conversionTypeId(&mut self,)
	-> Result<Rc<ConversionTypeIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConversionTypeIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 318, RULE_conversionTypeId);
        let mut _localctx: Rc<ConversionTypeIdContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typeSpecifierSeq*/
			recog.base.set_state(1805);
			recog.typeSpecifierSeq()?;

			recog.base.set_state(1807);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(251,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule conversionDeclarator*/
					recog.base.set_state(1806);
					recog.conversionDeclarator()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- conversionDeclarator ----------------
pub type ConversionDeclaratorContextAll<'input> = ConversionDeclaratorContext<'input>;


pub type ConversionDeclaratorContext<'input> = BaseParserRuleContext<'input,ConversionDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct ConversionDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ConversionDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ConversionDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_conversionDeclarator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_conversionDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConversionDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conversionDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conversionDeclarator }
}
antlr_rust::tid!{ConversionDeclaratorContextExt<'a>}

impl<'input> ConversionDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConversionDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConversionDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConversionDeclaratorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ConversionDeclaratorContextExt<'input>>{

fn pointerOperator(&self) -> Option<Rc<PointerOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn conversionDeclarator(&self) -> Option<Rc<ConversionDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConversionDeclaratorContextAttrs<'input> for ConversionDeclaratorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn conversionDeclarator(&mut self,)
	-> Result<Rc<ConversionDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConversionDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 320, RULE_conversionDeclarator);
        let mut _localctx: Rc<ConversionDeclaratorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule pointerOperator*/
			recog.base.set_state(1809);
			recog.pointerOperator()?;

			recog.base.set_state(1811);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(252,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule conversionDeclarator*/
					recog.base.set_state(1810);
					recog.conversionDeclarator()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorInitializer ----------------
pub type ConstructorInitializerContextAll<'input> = ConstructorInitializerContext<'input>;


pub type ConstructorInitializerContext<'input> = BaseParserRuleContext<'input,ConstructorInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ConstructorInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ConstructorInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constructorInitializer(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_constructorInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstructorInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorInitializer }
}
antlr_rust::tid!{ConstructorInitializerContextExt<'a>}

impl<'input> ConstructorInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorInitializerContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ConstructorInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Colon
/// Returns `None` if there is no child corresponding to token Colon
fn Colon(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Colon, 0)
}
fn memInitializerList(&self) -> Option<Rc<MemInitializerListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstructorInitializerContextAttrs<'input> for ConstructorInitializerContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorInitializer(&mut self,)
	-> Result<Rc<ConstructorInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 322, RULE_constructorInitializer);
        let mut _localctx: Rc<ConstructorInitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1813);
			recog.base.match_token(Colon,&mut recog.err_handler)?;

			/*InvokeRule memInitializerList*/
			recog.base.set_state(1814);
			recog.memInitializerList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memInitializerList ----------------
pub type MemInitializerListContextAll<'input> = MemInitializerListContext<'input>;


pub type MemInitializerListContext<'input> = BaseParserRuleContext<'input,MemInitializerListContextExt<'input>>;

#[derive(Clone)]
pub struct MemInitializerListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for MemInitializerListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for MemInitializerListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_memInitializerList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_memInitializerList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MemInitializerListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memInitializerList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memInitializerList }
}
antlr_rust::tid!{MemInitializerListContextExt<'a>}

impl<'input> MemInitializerListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemInitializerListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemInitializerListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemInitializerListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<MemInitializerListContextExt<'input>>{

fn memInitializer_all(&self) ->  Vec<Rc<MemInitializerContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn memInitializer(&self, i: usize) -> Option<Rc<MemInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Ellipsis in current rule
fn Ellipsis_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Ellipsis, starting from 0.
/// Returns `None` if number of children corresponding to token Ellipsis is less or equal than `i`.
fn Ellipsis(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}

}

impl<'input> MemInitializerListContextAttrs<'input> for MemInitializerListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memInitializerList(&mut self,)
	-> Result<Rc<MemInitializerListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemInitializerListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 324, RULE_memInitializerList);
        let mut _localctx: Rc<MemInitializerListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule memInitializer*/
			recog.base.set_state(1816);
			recog.memInitializer()?;

			recog.base.set_state(1818);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Ellipsis {
				{
				recog.base.set_state(1817);
				recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1827);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Comma {
				{
				{
				recog.base.set_state(1820);
				recog.base.match_token(Comma,&mut recog.err_handler)?;

				/*InvokeRule memInitializer*/
				recog.base.set_state(1821);
				recog.memInitializer()?;

				recog.base.set_state(1823);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==Ellipsis {
					{
					recog.base.set_state(1822);
					recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

					}
				}

				}
				}
				recog.base.set_state(1829);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memInitializer ----------------
pub type MemInitializerContextAll<'input> = MemInitializerContext<'input>;


pub type MemInitializerContext<'input> = BaseParserRuleContext<'input,MemInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct MemInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for MemInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for MemInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_memInitializer(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_memInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MemInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memInitializer }
}
antlr_rust::tid!{MemInitializerContextExt<'a>}

impl<'input> MemInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemInitializerContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<MemInitializerContextExt<'input>>{

fn meminitializerid(&self) -> Option<Rc<MeminitializeridContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn bracedInitList(&self) -> Option<Rc<BracedInitListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionList(&self) -> Option<Rc<ExpressionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MemInitializerContextAttrs<'input> for MemInitializerContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memInitializer(&mut self,)
	-> Result<Rc<MemInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 326, RULE_memInitializer);
        let mut _localctx: Rc<MemInitializerContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule meminitializerid*/
			recog.base.set_state(1830);
			recog.meminitializerid()?;

			recog.base.set_state(1837);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LeftParen 
				=> {
					{
					recog.base.set_state(1831);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					recog.base.set_state(1833);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 71)) & !0x3f) == 0 && ((1usize << (_la - 71)) & ((1usize << (Throw - 71)) | (1usize << (Typeid_ - 71)) | (1usize << (Typename_ - 71)) | (1usize << (Unsigned - 71)) | (1usize << (Void - 71)) | (1usize << (Wchar - 71)) | (1usize << (LeftParen - 71)) | (1usize << (LeftBracket - 71)) | (1usize << (LeftBrace - 71)) | (1usize << (Plus - 71)) | (1usize << (Minus - 71)) | (1usize << (Star - 71)) | (1usize << (And - 71)) | (1usize << (Or - 71)) | (1usize << (Tilde - 71)) | (1usize << (Not - 71)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
						{
						/*InvokeRule expressionList*/
						recog.base.set_state(1832);
						recog.expressionList()?;

						}
					}

					recog.base.set_state(1835);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}

			 LeftBrace 
				=> {
					{
					/*InvokeRule bracedInitList*/
					recog.base.set_state(1836);
					recog.bracedInitList()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- meminitializerid ----------------
pub type MeminitializeridContextAll<'input> = MeminitializeridContext<'input>;


pub type MeminitializeridContext<'input> = BaseParserRuleContext<'input,MeminitializeridContextExt<'input>>;

#[derive(Clone)]
pub struct MeminitializeridContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for MeminitializeridContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for MeminitializeridContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_meminitializerid(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_meminitializerid(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MeminitializeridContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_meminitializerid }
	//fn type_rule_index() -> usize where Self: Sized { RULE_meminitializerid }
}
antlr_rust::tid!{MeminitializeridContextExt<'a>}

impl<'input> MeminitializeridContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MeminitializeridContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MeminitializeridContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MeminitializeridContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<MeminitializeridContextExt<'input>>{

fn classOrDeclType(&self) -> Option<Rc<ClassOrDeclTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> MeminitializeridContextAttrs<'input> for MeminitializeridContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn meminitializerid(&mut self,)
	-> Result<Rc<MeminitializeridContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MeminitializeridContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 328, RULE_meminitializerid);
        let mut _localctx: Rc<MeminitializeridContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1841);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(258,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classOrDeclType*/
					recog.base.set_state(1839);
					recog.classOrDeclType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1840);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- operatorFunctionId ----------------
pub type OperatorFunctionIdContextAll<'input> = OperatorFunctionIdContext<'input>;


pub type OperatorFunctionIdContext<'input> = BaseParserRuleContext<'input,OperatorFunctionIdContextExt<'input>>;

#[derive(Clone)]
pub struct OperatorFunctionIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for OperatorFunctionIdContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for OperatorFunctionIdContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_operatorFunctionId(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_operatorFunctionId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for OperatorFunctionIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_operatorFunctionId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_operatorFunctionId }
}
antlr_rust::tid!{OperatorFunctionIdContextExt<'a>}

impl<'input> OperatorFunctionIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OperatorFunctionIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OperatorFunctionIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OperatorFunctionIdContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<OperatorFunctionIdContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Operator
/// Returns `None` if there is no child corresponding to token Operator
fn Operator(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Operator, 0)
}
fn theOperator(&self) -> Option<Rc<TheOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OperatorFunctionIdContextAttrs<'input> for OperatorFunctionIdContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn operatorFunctionId(&mut self,)
	-> Result<Rc<OperatorFunctionIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OperatorFunctionIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 330, RULE_operatorFunctionId);
        let mut _localctx: Rc<OperatorFunctionIdContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1843);
			recog.base.match_token(Operator,&mut recog.err_handler)?;

			/*InvokeRule theOperator*/
			recog.base.set_state(1844);
			recog.theOperator()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- literalOperatorId ----------------
pub type LiteralOperatorIdContextAll<'input> = LiteralOperatorIdContext<'input>;


pub type LiteralOperatorIdContext<'input> = BaseParserRuleContext<'input,LiteralOperatorIdContextExt<'input>>;

#[derive(Clone)]
pub struct LiteralOperatorIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for LiteralOperatorIdContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for LiteralOperatorIdContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_literalOperatorId(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_literalOperatorId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LiteralOperatorIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_literalOperatorId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_literalOperatorId }
}
antlr_rust::tid!{LiteralOperatorIdContextExt<'a>}

impl<'input> LiteralOperatorIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LiteralOperatorIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LiteralOperatorIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LiteralOperatorIdContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<LiteralOperatorIdContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Operator
/// Returns `None` if there is no child corresponding to token Operator
fn Operator(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Operator, 0)
}
/// Retrieves first TerminalNode corresponding to token StringLiteral
/// Returns `None` if there is no child corresponding to token StringLiteral
fn StringLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(StringLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token UserDefinedStringLiteral
/// Returns `None` if there is no child corresponding to token UserDefinedStringLiteral
fn UserDefinedStringLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(UserDefinedStringLiteral, 0)
}

}

impl<'input> LiteralOperatorIdContextAttrs<'input> for LiteralOperatorIdContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn literalOperatorId(&mut self,)
	-> Result<Rc<LiteralOperatorIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LiteralOperatorIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 332, RULE_literalOperatorId);
        let mut _localctx: Rc<LiteralOperatorIdContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1846);
			recog.base.match_token(Operator,&mut recog.err_handler)?;

			recog.base.set_state(1850);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 StringLiteral 
				=> {
					{
					recog.base.set_state(1847);
					recog.base.match_token(StringLiteral,&mut recog.err_handler)?;

					recog.base.set_state(1848);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}

			 UserDefinedStringLiteral 
				=> {
					{
					recog.base.set_state(1849);
					recog.base.match_token(UserDefinedStringLiteral,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- templateDeclaration ----------------
pub type TemplateDeclarationContextAll<'input> = TemplateDeclarationContext<'input>;


pub type TemplateDeclarationContext<'input> = BaseParserRuleContext<'input,TemplateDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct TemplateDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TemplateDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TemplateDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_templateDeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_templateDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TemplateDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_templateDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_templateDeclaration }
}
antlr_rust::tid!{TemplateDeclarationContextExt<'a>}

impl<'input> TemplateDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TemplateDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TemplateDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TemplateDeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TemplateDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Template
/// Returns `None` if there is no child corresponding to token Template
fn Template(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Template, 0)
}
/// Retrieves first TerminalNode corresponding to token Less
/// Returns `None` if there is no child corresponding to token Less
fn Less(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Less, 0)
}
fn templateparameterList(&self) -> Option<Rc<TemplateparameterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Greater
/// Returns `None` if there is no child corresponding to token Greater
fn Greater(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Greater, 0)
}
fn declaration(&self) -> Option<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TemplateDeclarationContextAttrs<'input> for TemplateDeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn templateDeclaration(&mut self,)
	-> Result<Rc<TemplateDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TemplateDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 334, RULE_templateDeclaration);
        let mut _localctx: Rc<TemplateDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1852);
			recog.base.match_token(Template,&mut recog.err_handler)?;

			recog.base.set_state(1853);
			recog.base.match_token(Less,&mut recog.err_handler)?;

			/*InvokeRule templateparameterList*/
			recog.base.set_state(1854);
			recog.templateparameterList()?;

			recog.base.set_state(1855);
			recog.base.match_token(Greater,&mut recog.err_handler)?;

			/*InvokeRule declaration*/
			recog.base.set_state(1856);
			recog.declaration()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- templateparameterList ----------------
pub type TemplateparameterListContextAll<'input> = TemplateparameterListContext<'input>;


pub type TemplateparameterListContext<'input> = BaseParserRuleContext<'input,TemplateparameterListContextExt<'input>>;

#[derive(Clone)]
pub struct TemplateparameterListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TemplateparameterListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TemplateparameterListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_templateparameterList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_templateparameterList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TemplateparameterListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_templateparameterList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_templateparameterList }
}
antlr_rust::tid!{TemplateparameterListContextExt<'a>}

impl<'input> TemplateparameterListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TemplateparameterListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TemplateparameterListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TemplateparameterListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TemplateparameterListContextExt<'input>>{

fn templateParameter_all(&self) ->  Vec<Rc<TemplateParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn templateParameter(&self, i: usize) -> Option<Rc<TemplateParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}

}

impl<'input> TemplateparameterListContextAttrs<'input> for TemplateparameterListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn templateparameterList(&mut self,)
	-> Result<Rc<TemplateparameterListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TemplateparameterListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 336, RULE_templateparameterList);
        let mut _localctx: Rc<TemplateparameterListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule templateParameter*/
			recog.base.set_state(1858);
			recog.templateParameter()?;

			recog.base.set_state(1863);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Comma {
				{
				{
				recog.base.set_state(1859);
				recog.base.match_token(Comma,&mut recog.err_handler)?;

				/*InvokeRule templateParameter*/
				recog.base.set_state(1860);
				recog.templateParameter()?;

				}
				}
				recog.base.set_state(1865);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- templateParameter ----------------
pub type TemplateParameterContextAll<'input> = TemplateParameterContext<'input>;


pub type TemplateParameterContext<'input> = BaseParserRuleContext<'input,TemplateParameterContextExt<'input>>;

#[derive(Clone)]
pub struct TemplateParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TemplateParameterContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TemplateParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_templateParameter(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_templateParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TemplateParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_templateParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_templateParameter }
}
antlr_rust::tid!{TemplateParameterContextExt<'a>}

impl<'input> TemplateParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TemplateParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TemplateParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TemplateParameterContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TemplateParameterContextExt<'input>>{

fn typeParameter(&self) -> Option<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parameterDeclaration(&self) -> Option<Rc<ParameterDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TemplateParameterContextAttrs<'input> for TemplateParameterContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn templateParameter(&mut self,)
	-> Result<Rc<TemplateParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TemplateParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 338, RULE_templateParameter);
        let mut _localctx: Rc<TemplateParameterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1868);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(261,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule typeParameter*/
					recog.base.set_state(1866);
					recog.typeParameter()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule parameterDeclaration*/
					recog.base.set_state(1867);
					recog.parameterDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameter ----------------
pub type TypeParameterContextAll<'input> = TypeParameterContext<'input>;


pub type TypeParameterContext<'input> = BaseParserRuleContext<'input,TypeParameterContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TypeParameterContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TypeParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameter(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_typeParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameter }
}
antlr_rust::tid!{TypeParameterContextExt<'a>}

impl<'input> TypeParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TypeParameterContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Class
/// Returns `None` if there is no child corresponding to token Class
fn Class(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Class, 0)
}
/// Retrieves first TerminalNode corresponding to token Typename_
/// Returns `None` if there is no child corresponding to token Typename_
fn Typename_(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Typename_, 0)
}
/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}
fn theTypeId(&self) -> Option<Rc<TheTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Template
/// Returns `None` if there is no child corresponding to token Template
fn Template(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Template, 0)
}
/// Retrieves first TerminalNode corresponding to token Less
/// Returns `None` if there is no child corresponding to token Less
fn Less(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Less, 0)
}
fn templateparameterList(&self) -> Option<Rc<TemplateparameterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Greater
/// Returns `None` if there is no child corresponding to token Greater
fn Greater(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Greater, 0)
}
/// Retrieves first TerminalNode corresponding to token Ellipsis
/// Returns `None` if there is no child corresponding to token Ellipsis
fn Ellipsis(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, 0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> TypeParameterContextAttrs<'input> for TypeParameterContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameter(&mut self,)
	-> Result<Rc<TypeParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 340, RULE_typeParameter);
        let mut _localctx: Rc<TypeParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1879);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Class | Template 
				=> {
					{
					recog.base.set_state(1875);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Template {
						{
						recog.base.set_state(1870);
						recog.base.match_token(Template,&mut recog.err_handler)?;

						recog.base.set_state(1871);
						recog.base.match_token(Less,&mut recog.err_handler)?;

						/*InvokeRule templateparameterList*/
						recog.base.set_state(1872);
						recog.templateparameterList()?;

						recog.base.set_state(1873);
						recog.base.match_token(Greater,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1877);
					recog.base.match_token(Class,&mut recog.err_handler)?;

					}
				}

			 Typename_ 
				=> {
					{
					recog.base.set_state(1878);
					recog.base.match_token(Typename_,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(1892);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(267,&mut recog.base)? {
				1 =>{
					{
					recog.base.set_state(1882);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Ellipsis {
						{
						recog.base.set_state(1881);
						recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1885);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Identifier {
						{
						recog.base.set_state(1884);
						recog.base.match_token(Identifier,&mut recog.err_handler)?;

						}
					}

					}
				}
			,
				2 =>{
					{
					recog.base.set_state(1888);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Identifier {
						{
						recog.base.set_state(1887);
						recog.base.match_token(Identifier,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1890);
					recog.base.match_token(Assign,&mut recog.err_handler)?;

					/*InvokeRule theTypeId*/
					recog.base.set_state(1891);
					recog.theTypeId()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleTemplateId ----------------
pub type SimpleTemplateIdContextAll<'input> = SimpleTemplateIdContext<'input>;


pub type SimpleTemplateIdContext<'input> = BaseParserRuleContext<'input,SimpleTemplateIdContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleTemplateIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for SimpleTemplateIdContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for SimpleTemplateIdContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_simpleTemplateId(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_simpleTemplateId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SimpleTemplateIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleTemplateId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleTemplateId }
}
antlr_rust::tid!{SimpleTemplateIdContextExt<'a>}

impl<'input> SimpleTemplateIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleTemplateIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleTemplateIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleTemplateIdContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<SimpleTemplateIdContextExt<'input>>{

fn templateName(&self) -> Option<Rc<TemplateNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Less
/// Returns `None` if there is no child corresponding to token Less
fn Less(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Less, 0)
}
/// Retrieves first TerminalNode corresponding to token Greater
/// Returns `None` if there is no child corresponding to token Greater
fn Greater(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Greater, 0)
}
fn templateArgumentList(&self) -> Option<Rc<TemplateArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SimpleTemplateIdContextAttrs<'input> for SimpleTemplateIdContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleTemplateId(&mut self,)
	-> Result<Rc<SimpleTemplateIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleTemplateIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 342, RULE_simpleTemplateId);
        let mut _localctx: Rc<SimpleTemplateIdContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule templateName*/
			recog.base.set_state(1894);
			recog.templateName()?;

			recog.base.set_state(1895);
			recog.base.match_token(Less,&mut recog.err_handler)?;

			recog.base.set_state(1897);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Class) | (1usize << Const) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (Enum - 33)) | (1usize << (Float - 33)) | (1usize << (Int - 33)) | (1usize << (Long - 33)) | (1usize << (New - 33)) | (1usize << (Noexcept - 33)) | (1usize << (Operator - 33)) | (1usize << (Reinterpret_cast - 33)) | (1usize << (Short - 33)) | (1usize << (Signed - 33)) | (1usize << (Sizeof - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (Static_cast - 65)) | (1usize << (Struct - 65)) | (1usize << (This - 65)) | (1usize << (Typeid_ - 65)) | (1usize << (Typename_ - 65)) | (1usize << (Union - 65)) | (1usize << (Unsigned - 65)) | (1usize << (Void - 65)) | (1usize << (Volatile - 65)) | (1usize << (Wchar - 65)) | (1usize << (LeftParen - 65)) | (1usize << (LeftBracket - 65)) | (1usize << (Plus - 65)) | (1usize << (Minus - 65)) | (1usize << (Star - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (And - 97)) | (1usize << (Or - 97)) | (1usize << (Tilde - 97)) | (1usize << (Not - 97)) | (1usize << (PlusPlus - 97)) | (1usize << (MinusMinus - 97)) | (1usize << (Doublecolon - 97)))) != 0) || _la==Identifier {
				{
				/*InvokeRule templateArgumentList*/
				recog.base.set_state(1896);
				recog.templateArgumentList()?;

				}
			}

			recog.base.set_state(1899);
			recog.base.match_token(Greater,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- templateId ----------------
pub type TemplateIdContextAll<'input> = TemplateIdContext<'input>;


pub type TemplateIdContext<'input> = BaseParserRuleContext<'input,TemplateIdContextExt<'input>>;

#[derive(Clone)]
pub struct TemplateIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TemplateIdContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TemplateIdContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_templateId(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_templateId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TemplateIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_templateId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_templateId }
}
antlr_rust::tid!{TemplateIdContextExt<'a>}

impl<'input> TemplateIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TemplateIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TemplateIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TemplateIdContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TemplateIdContextExt<'input>>{

fn simpleTemplateId(&self) -> Option<Rc<SimpleTemplateIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Less
/// Returns `None` if there is no child corresponding to token Less
fn Less(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Less, 0)
}
/// Retrieves first TerminalNode corresponding to token Greater
/// Returns `None` if there is no child corresponding to token Greater
fn Greater(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Greater, 0)
}
fn operatorFunctionId(&self) -> Option<Rc<OperatorFunctionIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn literalOperatorId(&self) -> Option<Rc<LiteralOperatorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn templateArgumentList(&self) -> Option<Rc<TemplateArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TemplateIdContextAttrs<'input> for TemplateIdContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn templateId(&mut self,)
	-> Result<Rc<TemplateIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TemplateIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 344, RULE_templateId);
        let mut _localctx: Rc<TemplateIdContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1912);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule simpleTemplateId*/
					recog.base.set_state(1901);
					recog.simpleTemplateId()?;

					}
				}

			 Operator 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1904);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(269,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule operatorFunctionId*/
							recog.base.set_state(1902);
							recog.operatorFunctionId()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule literalOperatorId*/
							recog.base.set_state(1903);
							recog.literalOperatorId()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1906);
					recog.base.match_token(Less,&mut recog.err_handler)?;

					recog.base.set_state(1908);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Class) | (1usize << Const) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (Enum - 33)) | (1usize << (Float - 33)) | (1usize << (Int - 33)) | (1usize << (Long - 33)) | (1usize << (New - 33)) | (1usize << (Noexcept - 33)) | (1usize << (Operator - 33)) | (1usize << (Reinterpret_cast - 33)) | (1usize << (Short - 33)) | (1usize << (Signed - 33)) | (1usize << (Sizeof - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (Static_cast - 65)) | (1usize << (Struct - 65)) | (1usize << (This - 65)) | (1usize << (Typeid_ - 65)) | (1usize << (Typename_ - 65)) | (1usize << (Union - 65)) | (1usize << (Unsigned - 65)) | (1usize << (Void - 65)) | (1usize << (Volatile - 65)) | (1usize << (Wchar - 65)) | (1usize << (LeftParen - 65)) | (1usize << (LeftBracket - 65)) | (1usize << (Plus - 65)) | (1usize << (Minus - 65)) | (1usize << (Star - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (And - 97)) | (1usize << (Or - 97)) | (1usize << (Tilde - 97)) | (1usize << (Not - 97)) | (1usize << (PlusPlus - 97)) | (1usize << (MinusMinus - 97)) | (1usize << (Doublecolon - 97)))) != 0) || _la==Identifier {
						{
						/*InvokeRule templateArgumentList*/
						recog.base.set_state(1907);
						recog.templateArgumentList()?;

						}
					}

					recog.base.set_state(1910);
					recog.base.match_token(Greater,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- templateName ----------------
pub type TemplateNameContextAll<'input> = TemplateNameContext<'input>;


pub type TemplateNameContext<'input> = BaseParserRuleContext<'input,TemplateNameContextExt<'input>>;

#[derive(Clone)]
pub struct TemplateNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TemplateNameContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TemplateNameContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_templateName(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_templateName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TemplateNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_templateName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_templateName }
}
antlr_rust::tid!{TemplateNameContextExt<'a>}

impl<'input> TemplateNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TemplateNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TemplateNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TemplateNameContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TemplateNameContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}

}

impl<'input> TemplateNameContextAttrs<'input> for TemplateNameContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn templateName(&mut self,)
	-> Result<Rc<TemplateNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TemplateNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 346, RULE_templateName);
        let mut _localctx: Rc<TemplateNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1914);
			recog.base.match_token(Identifier,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- templateArgumentList ----------------
pub type TemplateArgumentListContextAll<'input> = TemplateArgumentListContext<'input>;


pub type TemplateArgumentListContext<'input> = BaseParserRuleContext<'input,TemplateArgumentListContextExt<'input>>;

#[derive(Clone)]
pub struct TemplateArgumentListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TemplateArgumentListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TemplateArgumentListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_templateArgumentList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_templateArgumentList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TemplateArgumentListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_templateArgumentList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_templateArgumentList }
}
antlr_rust::tid!{TemplateArgumentListContextExt<'a>}

impl<'input> TemplateArgumentListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TemplateArgumentListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TemplateArgumentListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TemplateArgumentListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TemplateArgumentListContextExt<'input>>{

fn templateArgument_all(&self) ->  Vec<Rc<TemplateArgumentContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn templateArgument(&self, i: usize) -> Option<Rc<TemplateArgumentContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Ellipsis in current rule
fn Ellipsis_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Ellipsis, starting from 0.
/// Returns `None` if number of children corresponding to token Ellipsis is less or equal than `i`.
fn Ellipsis(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}

}

impl<'input> TemplateArgumentListContextAttrs<'input> for TemplateArgumentListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn templateArgumentList(&mut self,)
	-> Result<Rc<TemplateArgumentListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TemplateArgumentListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 348, RULE_templateArgumentList);
        let mut _localctx: Rc<TemplateArgumentListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule templateArgument*/
			recog.base.set_state(1916);
			recog.templateArgument()?;

			recog.base.set_state(1918);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Ellipsis {
				{
				recog.base.set_state(1917);
				recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1927);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Comma {
				{
				{
				recog.base.set_state(1920);
				recog.base.match_token(Comma,&mut recog.err_handler)?;

				/*InvokeRule templateArgument*/
				recog.base.set_state(1921);
				recog.templateArgument()?;

				recog.base.set_state(1923);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==Ellipsis {
					{
					recog.base.set_state(1922);
					recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

					}
				}

				}
				}
				recog.base.set_state(1929);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- templateArgument ----------------
pub type TemplateArgumentContextAll<'input> = TemplateArgumentContext<'input>;


pub type TemplateArgumentContext<'input> = BaseParserRuleContext<'input,TemplateArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct TemplateArgumentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TemplateArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TemplateArgumentContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_templateArgument(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_templateArgument(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TemplateArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_templateArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_templateArgument }
}
antlr_rust::tid!{TemplateArgumentContextExt<'a>}

impl<'input> TemplateArgumentContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TemplateArgumentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TemplateArgumentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TemplateArgumentContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TemplateArgumentContextExt<'input>>{

fn theTypeId(&self) -> Option<Rc<TheTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn idExpression(&self) -> Option<Rc<IdExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TemplateArgumentContextAttrs<'input> for TemplateArgumentContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn templateArgument(&mut self,)
	-> Result<Rc<TemplateArgumentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TemplateArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 350, RULE_templateArgument);
        let mut _localctx: Rc<TemplateArgumentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1933);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(275,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule theTypeId*/
					recog.base.set_state(1930);
					recog.theTypeId()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule constantExpression*/
					recog.base.set_state(1931);
					recog.constantExpression()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule idExpression*/
					recog.base.set_state(1932);
					recog.idExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeNameSpecifier ----------------
pub type TypeNameSpecifierContextAll<'input> = TypeNameSpecifierContext<'input>;


pub type TypeNameSpecifierContext<'input> = BaseParserRuleContext<'input,TypeNameSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeNameSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TypeNameSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TypeNameSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeNameSpecifier(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_typeNameSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeNameSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeNameSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeNameSpecifier }
}
antlr_rust::tid!{TypeNameSpecifierContextExt<'a>}

impl<'input> TypeNameSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeNameSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeNameSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeNameSpecifierContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TypeNameSpecifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Typename_
/// Returns `None` if there is no child corresponding to token Typename_
fn Typename_(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Typename_, 0)
}
fn nestedNameSpecifier(&self) -> Option<Rc<NestedNameSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
fn simpleTemplateId(&self) -> Option<Rc<SimpleTemplateIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Template
/// Returns `None` if there is no child corresponding to token Template
fn Template(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Template, 0)
}

}

impl<'input> TypeNameSpecifierContextAttrs<'input> for TypeNameSpecifierContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeNameSpecifier(&mut self,)
	-> Result<Rc<TypeNameSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeNameSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 352, RULE_typeNameSpecifier);
        let mut _localctx: Rc<TypeNameSpecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1935);
			recog.base.match_token(Typename_,&mut recog.err_handler)?;

			/*InvokeRule nestedNameSpecifier*/
			recog.base.set_state(1936);
			recog.nestedNameSpecifier_rec(0)?;

			recog.base.set_state(1942);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(277,&mut recog.base)? {
				1 =>{
					{
					recog.base.set_state(1937);
					recog.base.match_token(Identifier,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					{
					recog.base.set_state(1939);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Template {
						{
						recog.base.set_state(1938);
						recog.base.match_token(Template,&mut recog.err_handler)?;

						}
					}

					/*InvokeRule simpleTemplateId*/
					recog.base.set_state(1941);
					recog.simpleTemplateId()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- explicitInstantiation ----------------
pub type ExplicitInstantiationContextAll<'input> = ExplicitInstantiationContext<'input>;


pub type ExplicitInstantiationContext<'input> = BaseParserRuleContext<'input,ExplicitInstantiationContextExt<'input>>;

#[derive(Clone)]
pub struct ExplicitInstantiationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ExplicitInstantiationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ExplicitInstantiationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_explicitInstantiation(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_explicitInstantiation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExplicitInstantiationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_explicitInstantiation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_explicitInstantiation }
}
antlr_rust::tid!{ExplicitInstantiationContextExt<'a>}

impl<'input> ExplicitInstantiationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExplicitInstantiationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExplicitInstantiationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExplicitInstantiationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ExplicitInstantiationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Template
/// Returns `None` if there is no child corresponding to token Template
fn Template(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Template, 0)
}
fn declaration(&self) -> Option<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Extern
/// Returns `None` if there is no child corresponding to token Extern
fn Extern(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Extern, 0)
}

}

impl<'input> ExplicitInstantiationContextAttrs<'input> for ExplicitInstantiationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn explicitInstantiation(&mut self,)
	-> Result<Rc<ExplicitInstantiationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExplicitInstantiationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 354, RULE_explicitInstantiation);
        let mut _localctx: Rc<ExplicitInstantiationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1945);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Extern {
				{
				recog.base.set_state(1944);
				recog.base.match_token(Extern,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1947);
			recog.base.match_token(Template,&mut recog.err_handler)?;

			/*InvokeRule declaration*/
			recog.base.set_state(1948);
			recog.declaration()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- explicitSpecialization ----------------
pub type ExplicitSpecializationContextAll<'input> = ExplicitSpecializationContext<'input>;


pub type ExplicitSpecializationContext<'input> = BaseParserRuleContext<'input,ExplicitSpecializationContextExt<'input>>;

#[derive(Clone)]
pub struct ExplicitSpecializationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ExplicitSpecializationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ExplicitSpecializationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_explicitSpecialization(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_explicitSpecialization(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExplicitSpecializationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_explicitSpecialization }
	//fn type_rule_index() -> usize where Self: Sized { RULE_explicitSpecialization }
}
antlr_rust::tid!{ExplicitSpecializationContextExt<'a>}

impl<'input> ExplicitSpecializationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExplicitSpecializationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExplicitSpecializationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExplicitSpecializationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ExplicitSpecializationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Template
/// Returns `None` if there is no child corresponding to token Template
fn Template(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Template, 0)
}
/// Retrieves first TerminalNode corresponding to token Less
/// Returns `None` if there is no child corresponding to token Less
fn Less(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Less, 0)
}
/// Retrieves first TerminalNode corresponding to token Greater
/// Returns `None` if there is no child corresponding to token Greater
fn Greater(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Greater, 0)
}
fn declaration(&self) -> Option<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExplicitSpecializationContextAttrs<'input> for ExplicitSpecializationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn explicitSpecialization(&mut self,)
	-> Result<Rc<ExplicitSpecializationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExplicitSpecializationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 356, RULE_explicitSpecialization);
        let mut _localctx: Rc<ExplicitSpecializationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1950);
			recog.base.match_token(Template,&mut recog.err_handler)?;

			recog.base.set_state(1951);
			recog.base.match_token(Less,&mut recog.err_handler)?;

			recog.base.set_state(1952);
			recog.base.match_token(Greater,&mut recog.err_handler)?;

			/*InvokeRule declaration*/
			recog.base.set_state(1953);
			recog.declaration()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tryBlock ----------------
pub type TryBlockContextAll<'input> = TryBlockContext<'input>;


pub type TryBlockContext<'input> = BaseParserRuleContext<'input,TryBlockContextExt<'input>>;

#[derive(Clone)]
pub struct TryBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TryBlockContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TryBlockContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tryBlock(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_tryBlock(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TryBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tryBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tryBlock }
}
antlr_rust::tid!{TryBlockContextExt<'a>}

impl<'input> TryBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TryBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TryBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TryBlockContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TryBlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Try
/// Returns `None` if there is no child corresponding to token Try
fn Try(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Try, 0)
}
fn compoundStatement(&self) -> Option<Rc<CompoundStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn handlerSeq(&self) -> Option<Rc<HandlerSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TryBlockContextAttrs<'input> for TryBlockContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tryBlock(&mut self,)
	-> Result<Rc<TryBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TryBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 358, RULE_tryBlock);
        let mut _localctx: Rc<TryBlockContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1955);
			recog.base.match_token(Try,&mut recog.err_handler)?;

			/*InvokeRule compoundStatement*/
			recog.base.set_state(1956);
			recog.compoundStatement()?;

			/*InvokeRule handlerSeq*/
			recog.base.set_state(1957);
			recog.handlerSeq()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionTryBlock ----------------
pub type FunctionTryBlockContextAll<'input> = FunctionTryBlockContext<'input>;


pub type FunctionTryBlockContext<'input> = BaseParserRuleContext<'input,FunctionTryBlockContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionTryBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for FunctionTryBlockContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for FunctionTryBlockContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionTryBlock(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_functionTryBlock(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FunctionTryBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionTryBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionTryBlock }
}
antlr_rust::tid!{FunctionTryBlockContextExt<'a>}

impl<'input> FunctionTryBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionTryBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionTryBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionTryBlockContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<FunctionTryBlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Try
/// Returns `None` if there is no child corresponding to token Try
fn Try(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Try, 0)
}
fn compoundStatement(&self) -> Option<Rc<CompoundStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn handlerSeq(&self) -> Option<Rc<HandlerSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constructorInitializer(&self) -> Option<Rc<ConstructorInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FunctionTryBlockContextAttrs<'input> for FunctionTryBlockContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionTryBlock(&mut self,)
	-> Result<Rc<FunctionTryBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionTryBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 360, RULE_functionTryBlock);
        let mut _localctx: Rc<FunctionTryBlockContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1959);
			recog.base.match_token(Try,&mut recog.err_handler)?;

			recog.base.set_state(1961);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Colon {
				{
				/*InvokeRule constructorInitializer*/
				recog.base.set_state(1960);
				recog.constructorInitializer()?;

				}
			}

			/*InvokeRule compoundStatement*/
			recog.base.set_state(1963);
			recog.compoundStatement()?;

			/*InvokeRule handlerSeq*/
			recog.base.set_state(1964);
			recog.handlerSeq()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- handlerSeq ----------------
pub type HandlerSeqContextAll<'input> = HandlerSeqContext<'input>;


pub type HandlerSeqContext<'input> = BaseParserRuleContext<'input,HandlerSeqContextExt<'input>>;

#[derive(Clone)]
pub struct HandlerSeqContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for HandlerSeqContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for HandlerSeqContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_handlerSeq(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_handlerSeq(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for HandlerSeqContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_handlerSeq }
	//fn type_rule_index() -> usize where Self: Sized { RULE_handlerSeq }
}
antlr_rust::tid!{HandlerSeqContextExt<'a>}

impl<'input> HandlerSeqContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<HandlerSeqContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,HandlerSeqContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait HandlerSeqContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<HandlerSeqContextExt<'input>>{

fn handler_all(&self) ->  Vec<Rc<HandlerContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn handler(&self, i: usize) -> Option<Rc<HandlerContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> HandlerSeqContextAttrs<'input> for HandlerSeqContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn handlerSeq(&mut self,)
	-> Result<Rc<HandlerSeqContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = HandlerSeqContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 362, RULE_handlerSeq);
        let mut _localctx: Rc<HandlerSeqContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1967); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule handler*/
				recog.base.set_state(1966);
				recog.handler()?;

				}
				}
				recog.base.set_state(1969); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !(_la==Catch) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- handler ----------------
pub type HandlerContextAll<'input> = HandlerContext<'input>;


pub type HandlerContext<'input> = BaseParserRuleContext<'input,HandlerContextExt<'input>>;

#[derive(Clone)]
pub struct HandlerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for HandlerContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for HandlerContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_handler(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_handler(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for HandlerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_handler }
	//fn type_rule_index() -> usize where Self: Sized { RULE_handler }
}
antlr_rust::tid!{HandlerContextExt<'a>}

impl<'input> HandlerContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<HandlerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,HandlerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait HandlerContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<HandlerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Catch
/// Returns `None` if there is no child corresponding to token Catch
fn Catch(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Catch, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn exceptionDeclaration(&self) -> Option<Rc<ExceptionDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn compoundStatement(&self) -> Option<Rc<CompoundStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> HandlerContextAttrs<'input> for HandlerContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn handler(&mut self,)
	-> Result<Rc<HandlerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = HandlerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 364, RULE_handler);
        let mut _localctx: Rc<HandlerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1971);
			recog.base.match_token(Catch,&mut recog.err_handler)?;

			recog.base.set_state(1972);
			recog.base.match_token(LeftParen,&mut recog.err_handler)?;

			/*InvokeRule exceptionDeclaration*/
			recog.base.set_state(1973);
			recog.exceptionDeclaration()?;

			recog.base.set_state(1974);
			recog.base.match_token(RightParen,&mut recog.err_handler)?;

			/*InvokeRule compoundStatement*/
			recog.base.set_state(1975);
			recog.compoundStatement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- exceptionDeclaration ----------------
pub type ExceptionDeclarationContextAll<'input> = ExceptionDeclarationContext<'input>;


pub type ExceptionDeclarationContext<'input> = BaseParserRuleContext<'input,ExceptionDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ExceptionDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ExceptionDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ExceptionDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_exceptionDeclaration(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_exceptionDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExceptionDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exceptionDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exceptionDeclaration }
}
antlr_rust::tid!{ExceptionDeclarationContextExt<'a>}

impl<'input> ExceptionDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExceptionDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExceptionDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExceptionDeclarationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ExceptionDeclarationContextExt<'input>>{

fn typeSpecifierSeq(&self) -> Option<Rc<TypeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn attributeSpecifierSeq(&self) -> Option<Rc<AttributeSpecifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn declarator(&self) -> Option<Rc<DeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn abstractDeclarator(&self) -> Option<Rc<AbstractDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token Ellipsis
/// Returns `None` if there is no child corresponding to token Ellipsis
fn Ellipsis(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, 0)
}

}

impl<'input> ExceptionDeclarationContextAttrs<'input> for ExceptionDeclarationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn exceptionDeclaration(&mut self,)
	-> Result<Rc<ExceptionDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExceptionDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 366, RULE_exceptionDeclaration);
        let mut _localctx: Rc<ExceptionDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1986);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Alignas | Auto | Bool | Char | Char16 | Char32 | Class | Const | Decltype |
			 Double | Enum | Float | Int | Long | Short | Signed | Struct | Typename_ |
			 Union | Unsigned | Void | Volatile | Wchar | LeftBracket | Doublecolon |
			 Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1978);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==Alignas || _la==LeftBracket {
						{
						/*InvokeRule attributeSpecifierSeq*/
						recog.base.set_state(1977);
						recog.attributeSpecifierSeq()?;

						}
					}

					/*InvokeRule typeSpecifierSeq*/
					recog.base.set_state(1980);
					recog.typeSpecifierSeq()?;

					recog.base.set_state(1983);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(282,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule declarator*/
							recog.base.set_state(1981);
							recog.declarator()?;

							}
						}

						x if x == 2=>{
							{
							/*InvokeRule abstractDeclarator*/
							recog.base.set_state(1982);
							recog.abstractDeclarator()?;

							}
						}

						_ => {}
					}
					}
				}

			 Ellipsis 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1985);
					recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- throwExpression ----------------
pub type ThrowExpressionContextAll<'input> = ThrowExpressionContext<'input>;


pub type ThrowExpressionContext<'input> = BaseParserRuleContext<'input,ThrowExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ThrowExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ThrowExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ThrowExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_throwExpression(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_throwExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ThrowExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_throwExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_throwExpression }
}
antlr_rust::tid!{ThrowExpressionContextExt<'a>}

impl<'input> ThrowExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ThrowExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ThrowExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ThrowExpressionContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ThrowExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Throw
/// Returns `None` if there is no child corresponding to token Throw
fn Throw(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Throw, 0)
}
fn assignmentExpression(&self) -> Option<Rc<AssignmentExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ThrowExpressionContextAttrs<'input> for ThrowExpressionContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn throwExpression(&mut self,)
	-> Result<Rc<ThrowExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ThrowExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 368, RULE_throwExpression);
        let mut _localctx: Rc<ThrowExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1988);
			recog.base.match_token(Throw,&mut recog.err_handler)?;

			recog.base.set_state(1990);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral) | (1usize << Alignof) | (1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Const_cast) | (1usize << Decltype) | (1usize << Delete) | (1usize << Double) | (1usize << Dynamic_cast))) != 0) || ((((_la - 39)) & !0x3f) == 0 && ((1usize << (_la - 39)) & ((1usize << (Float - 39)) | (1usize << (Int - 39)) | (1usize << (Long - 39)) | (1usize << (New - 39)) | (1usize << (Noexcept - 39)) | (1usize << (Operator - 39)) | (1usize << (Reinterpret_cast - 39)) | (1usize << (Short - 39)) | (1usize << (Signed - 39)) | (1usize << (Sizeof - 39)) | (1usize << (Static_cast - 39)) | (1usize << (This - 39)))) != 0) || ((((_la - 71)) & !0x3f) == 0 && ((1usize << (_la - 71)) & ((1usize << (Throw - 71)) | (1usize << (Typeid_ - 71)) | (1usize << (Typename_ - 71)) | (1usize << (Unsigned - 71)) | (1usize << (Void - 71)) | (1usize << (Wchar - 71)) | (1usize << (LeftParen - 71)) | (1usize << (LeftBracket - 71)) | (1usize << (Plus - 71)) | (1usize << (Minus - 71)) | (1usize << (Star - 71)) | (1usize << (And - 71)) | (1usize << (Or - 71)) | (1usize << (Tilde - 71)) | (1usize << (Not - 71)))) != 0) || ((((_la - 120)) & !0x3f) == 0 && ((1usize << (_la - 120)) & ((1usize << (PlusPlus - 120)) | (1usize << (MinusMinus - 120)) | (1usize << (Doublecolon - 120)) | (1usize << (Identifier - 120)))) != 0) {
				{
				/*InvokeRule assignmentExpression*/
				recog.base.set_state(1989);
				recog.assignmentExpression()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- exceptionSpecification ----------------
pub type ExceptionSpecificationContextAll<'input> = ExceptionSpecificationContext<'input>;


pub type ExceptionSpecificationContext<'input> = BaseParserRuleContext<'input,ExceptionSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct ExceptionSpecificationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for ExceptionSpecificationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for ExceptionSpecificationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_exceptionSpecification(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_exceptionSpecification(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExceptionSpecificationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exceptionSpecification }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exceptionSpecification }
}
antlr_rust::tid!{ExceptionSpecificationContextExt<'a>}

impl<'input> ExceptionSpecificationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExceptionSpecificationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExceptionSpecificationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExceptionSpecificationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<ExceptionSpecificationContextExt<'input>>{

fn dynamicExceptionSpecification(&self) -> Option<Rc<DynamicExceptionSpecificationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn noeExceptSpecification(&self) -> Option<Rc<NoeExceptSpecificationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExceptionSpecificationContextAttrs<'input> for ExceptionSpecificationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn exceptionSpecification(&mut self,)
	-> Result<Rc<ExceptionSpecificationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExceptionSpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 370, RULE_exceptionSpecification);
        let mut _localctx: Rc<ExceptionSpecificationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1994);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 Throw 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule dynamicExceptionSpecification*/
					recog.base.set_state(1992);
					recog.dynamicExceptionSpecification()?;

					}
				}

			 Noexcept 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule noeExceptSpecification*/
					recog.base.set_state(1993);
					recog.noeExceptSpecification()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dynamicExceptionSpecification ----------------
pub type DynamicExceptionSpecificationContextAll<'input> = DynamicExceptionSpecificationContext<'input>;


pub type DynamicExceptionSpecificationContext<'input> = BaseParserRuleContext<'input,DynamicExceptionSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct DynamicExceptionSpecificationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for DynamicExceptionSpecificationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for DynamicExceptionSpecificationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_dynamicExceptionSpecification(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_dynamicExceptionSpecification(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DynamicExceptionSpecificationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dynamicExceptionSpecification }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dynamicExceptionSpecification }
}
antlr_rust::tid!{DynamicExceptionSpecificationContextExt<'a>}

impl<'input> DynamicExceptionSpecificationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DynamicExceptionSpecificationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DynamicExceptionSpecificationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DynamicExceptionSpecificationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<DynamicExceptionSpecificationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Throw
/// Returns `None` if there is no child corresponding to token Throw
fn Throw(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Throw, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}
fn typeIdList(&self) -> Option<Rc<TypeIdListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DynamicExceptionSpecificationContextAttrs<'input> for DynamicExceptionSpecificationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dynamicExceptionSpecification(&mut self,)
	-> Result<Rc<DynamicExceptionSpecificationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DynamicExceptionSpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 372, RULE_dynamicExceptionSpecification);
        let mut _localctx: Rc<DynamicExceptionSpecificationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1996);
			recog.base.match_token(Throw,&mut recog.err_handler)?;

			recog.base.set_state(1997);
			recog.base.match_token(LeftParen,&mut recog.err_handler)?;

			recog.base.set_state(1999);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << Auto) | (1usize << Bool) | (1usize << Char) | (1usize << Char16) | (1usize << Char32) | (1usize << Class) | (1usize << Const) | (1usize << Decltype) | (1usize << Double))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (Enum - 33)) | (1usize << (Float - 33)) | (1usize << (Int - 33)) | (1usize << (Long - 33)) | (1usize << (Short - 33)) | (1usize << (Signed - 33)))) != 0) || ((((_la - 66)) & !0x3f) == 0 && ((1usize << (_la - 66)) & ((1usize << (Struct - 66)) | (1usize << (Typename_ - 66)) | (1usize << (Union - 66)) | (1usize << (Unsigned - 66)) | (1usize << (Void - 66)) | (1usize << (Volatile - 66)) | (1usize << (Wchar - 66)))) != 0) || _la==Doublecolon || _la==Identifier {
				{
				/*InvokeRule typeIdList*/
				recog.base.set_state(1998);
				recog.typeIdList()?;

				}
			}

			recog.base.set_state(2001);
			recog.base.match_token(RightParen,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeIdList ----------------
pub type TypeIdListContextAll<'input> = TypeIdListContext<'input>;


pub type TypeIdListContext<'input> = BaseParserRuleContext<'input,TypeIdListContextExt<'input>>;

#[derive(Clone)]
pub struct TypeIdListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TypeIdListContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TypeIdListContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeIdList(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_typeIdList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeIdListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeIdList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeIdList }
}
antlr_rust::tid!{TypeIdListContextExt<'a>}

impl<'input> TypeIdListContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeIdListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeIdListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeIdListContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TypeIdListContextExt<'input>>{

fn theTypeId_all(&self) ->  Vec<Rc<TheTypeIdContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn theTypeId(&self, i: usize) -> Option<Rc<TheTypeIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token Ellipsis in current rule
fn Ellipsis_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Ellipsis, starting from 0.
/// Returns `None` if number of children corresponding to token Ellipsis is less or equal than `i`.
fn Ellipsis(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Ellipsis, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Comma in current rule
fn Comma_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Comma, starting from 0.
/// Returns `None` if number of children corresponding to token Comma is less or equal than `i`.
fn Comma(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, i)
}

}

impl<'input> TypeIdListContextAttrs<'input> for TypeIdListContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeIdList(&mut self,)
	-> Result<Rc<TypeIdListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeIdListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 374, RULE_typeIdList);
        let mut _localctx: Rc<TypeIdListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule theTypeId*/
			recog.base.set_state(2003);
			recog.theTypeId()?;

			recog.base.set_state(2005);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==Ellipsis {
				{
				recog.base.set_state(2004);
				recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2014);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==Comma {
				{
				{
				recog.base.set_state(2007);
				recog.base.match_token(Comma,&mut recog.err_handler)?;

				/*InvokeRule theTypeId*/
				recog.base.set_state(2008);
				recog.theTypeId()?;

				recog.base.set_state(2010);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==Ellipsis {
					{
					recog.base.set_state(2009);
					recog.base.match_token(Ellipsis,&mut recog.err_handler)?;

					}
				}

				}
				}
				recog.base.set_state(2016);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- noeExceptSpecification ----------------
pub type NoeExceptSpecificationContextAll<'input> = NoeExceptSpecificationContext<'input>;


pub type NoeExceptSpecificationContext<'input> = BaseParserRuleContext<'input,NoeExceptSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct NoeExceptSpecificationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for NoeExceptSpecificationContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for NoeExceptSpecificationContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_noeExceptSpecification(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_noeExceptSpecification(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NoeExceptSpecificationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_noeExceptSpecification }
	//fn type_rule_index() -> usize where Self: Sized { RULE_noeExceptSpecification }
}
antlr_rust::tid!{NoeExceptSpecificationContextExt<'a>}

impl<'input> NoeExceptSpecificationContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NoeExceptSpecificationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NoeExceptSpecificationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NoeExceptSpecificationContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<NoeExceptSpecificationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Noexcept
/// Returns `None` if there is no child corresponding to token Noexcept
fn Noexcept(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Noexcept, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}

}

impl<'input> NoeExceptSpecificationContextAttrs<'input> for NoeExceptSpecificationContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn noeExceptSpecification(&mut self,)
	-> Result<Rc<NoeExceptSpecificationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NoeExceptSpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 376, RULE_noeExceptSpecification);
        let mut _localctx: Rc<NoeExceptSpecificationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2023);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(290,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2017);
					recog.base.match_token(Noexcept,&mut recog.err_handler)?;

					recog.base.set_state(2018);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					/*InvokeRule constantExpression*/
					recog.base.set_state(2019);
					recog.constantExpression()?;

					recog.base.set_state(2020);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2022);
					recog.base.match_token(Noexcept,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- theOperator ----------------
pub type TheOperatorContextAll<'input> = TheOperatorContext<'input>;


pub type TheOperatorContext<'input> = BaseParserRuleContext<'input,TheOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct TheOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for TheOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for TheOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_theOperator(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_theOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TheOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_theOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_theOperator }
}
antlr_rust::tid!{TheOperatorContextExt<'a>}

impl<'input> TheOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TheOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TheOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TheOperatorContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<TheOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token New
/// Returns `None` if there is no child corresponding to token New
fn New(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(New, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftBracket
/// Returns `None` if there is no child corresponding to token LeftBracket
fn LeftBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftBracket, 0)
}
/// Retrieves first TerminalNode corresponding to token RightBracket
/// Returns `None` if there is no child corresponding to token RightBracket
fn RightBracket(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightBracket, 0)
}
/// Retrieves first TerminalNode corresponding to token Delete
/// Returns `None` if there is no child corresponding to token Delete
fn Delete(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Delete, 0)
}
/// Retrieves first TerminalNode corresponding to token Plus
/// Returns `None` if there is no child corresponding to token Plus
fn Plus(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Plus, 0)
}
/// Retrieves first TerminalNode corresponding to token Minus
/// Returns `None` if there is no child corresponding to token Minus
fn Minus(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Minus, 0)
}
/// Retrieves first TerminalNode corresponding to token Star
/// Returns `None` if there is no child corresponding to token Star
fn Star(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Star, 0)
}
/// Retrieves first TerminalNode corresponding to token Div
/// Returns `None` if there is no child corresponding to token Div
fn Div(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Div, 0)
}
/// Retrieves first TerminalNode corresponding to token Mod
/// Returns `None` if there is no child corresponding to token Mod
fn Mod(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Mod, 0)
}
/// Retrieves first TerminalNode corresponding to token Caret
/// Returns `None` if there is no child corresponding to token Caret
fn Caret(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Caret, 0)
}
/// Retrieves first TerminalNode corresponding to token And
/// Returns `None` if there is no child corresponding to token And
fn And(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(And, 0)
}
/// Retrieves first TerminalNode corresponding to token Or
/// Returns `None` if there is no child corresponding to token Or
fn Or(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Or, 0)
}
/// Retrieves first TerminalNode corresponding to token Tilde
/// Returns `None` if there is no child corresponding to token Tilde
fn Tilde(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Tilde, 0)
}
/// Retrieves first TerminalNode corresponding to token Not
/// Returns `None` if there is no child corresponding to token Not
fn Not(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Not, 0)
}
/// Retrieves first TerminalNode corresponding to token Assign
/// Returns `None` if there is no child corresponding to token Assign
fn Assign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Assign, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token Greater in current rule
fn Greater_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Greater, starting from 0.
/// Returns `None` if number of children corresponding to token Greater is less or equal than `i`.
fn Greater(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Greater, i)
}
/// Retrieves all `TerminalNode`s corresponding to token Less in current rule
fn Less_all(&self) -> Vec<Rc<TerminalNode<'input,CPP14ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token Less, starting from 0.
/// Returns `None` if number of children corresponding to token Less is less or equal than `i`.
fn Less(&self, i: usize) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Less, i)
}
/// Retrieves first TerminalNode corresponding to token GreaterEqual
/// Returns `None` if there is no child corresponding to token GreaterEqual
fn GreaterEqual(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(GreaterEqual, 0)
}
/// Retrieves first TerminalNode corresponding to token PlusAssign
/// Returns `None` if there is no child corresponding to token PlusAssign
fn PlusAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(PlusAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token MinusAssign
/// Returns `None` if there is no child corresponding to token MinusAssign
fn MinusAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(MinusAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token StarAssign
/// Returns `None` if there is no child corresponding to token StarAssign
fn StarAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(StarAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token ModAssign
/// Returns `None` if there is no child corresponding to token ModAssign
fn ModAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(ModAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token XorAssign
/// Returns `None` if there is no child corresponding to token XorAssign
fn XorAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(XorAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token AndAssign
/// Returns `None` if there is no child corresponding to token AndAssign
fn AndAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(AndAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token OrAssign
/// Returns `None` if there is no child corresponding to token OrAssign
fn OrAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(OrAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token RightShiftAssign
/// Returns `None` if there is no child corresponding to token RightShiftAssign
fn RightShiftAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightShiftAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftShiftAssign
/// Returns `None` if there is no child corresponding to token LeftShiftAssign
fn LeftShiftAssign(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftShiftAssign, 0)
}
/// Retrieves first TerminalNode corresponding to token Equal
/// Returns `None` if there is no child corresponding to token Equal
fn Equal(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Equal, 0)
}
/// Retrieves first TerminalNode corresponding to token NotEqual
/// Returns `None` if there is no child corresponding to token NotEqual
fn NotEqual(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(NotEqual, 0)
}
/// Retrieves first TerminalNode corresponding to token LessEqual
/// Returns `None` if there is no child corresponding to token LessEqual
fn LessEqual(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LessEqual, 0)
}
/// Retrieves first TerminalNode corresponding to token AndAnd
/// Returns `None` if there is no child corresponding to token AndAnd
fn AndAnd(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(AndAnd, 0)
}
/// Retrieves first TerminalNode corresponding to token OrOr
/// Returns `None` if there is no child corresponding to token OrOr
fn OrOr(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(OrOr, 0)
}
/// Retrieves first TerminalNode corresponding to token PlusPlus
/// Returns `None` if there is no child corresponding to token PlusPlus
fn PlusPlus(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(PlusPlus, 0)
}
/// Retrieves first TerminalNode corresponding to token MinusMinus
/// Returns `None` if there is no child corresponding to token MinusMinus
fn MinusMinus(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(MinusMinus, 0)
}
/// Retrieves first TerminalNode corresponding to token Comma
/// Returns `None` if there is no child corresponding to token Comma
fn Comma(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Comma, 0)
}
/// Retrieves first TerminalNode corresponding to token ArrowStar
/// Returns `None` if there is no child corresponding to token ArrowStar
fn ArrowStar(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(ArrowStar, 0)
}
/// Retrieves first TerminalNode corresponding to token Arrow
/// Returns `None` if there is no child corresponding to token Arrow
fn Arrow(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(Arrow, 0)
}
/// Retrieves first TerminalNode corresponding to token LeftParen
/// Returns `None` if there is no child corresponding to token LeftParen
fn LeftParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(LeftParen, 0)
}
/// Retrieves first TerminalNode corresponding to token RightParen
/// Returns `None` if there is no child corresponding to token RightParen
fn RightParen(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(RightParen, 0)
}

}

impl<'input> TheOperatorContextAttrs<'input> for TheOperatorContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn theOperator(&mut self,)
	-> Result<Rc<TheOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TheOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 378, RULE_theOperator);
        let mut _localctx: Rc<TheOperatorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2076);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(293,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2025);
					recog.base.match_token(New,&mut recog.err_handler)?;

					recog.base.set_state(2028);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(291,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2026);
							recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

							recog.base.set_state(2027);
							recog.base.match_token(RightBracket,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2030);
					recog.base.match_token(Delete,&mut recog.err_handler)?;

					recog.base.set_state(2033);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(292,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2031);
							recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

							recog.base.set_state(2032);
							recog.base.match_token(RightBracket,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2035);
					recog.base.match_token(Plus,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2036);
					recog.base.match_token(Minus,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(2037);
					recog.base.match_token(Star,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(2038);
					recog.base.match_token(Div,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(2039);
					recog.base.match_token(Mod,&mut recog.err_handler)?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(2040);
					recog.base.match_token(Caret,&mut recog.err_handler)?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					recog.base.set_state(2041);
					recog.base.match_token(And,&mut recog.err_handler)?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					recog.base.set_state(2042);
					recog.base.match_token(Or,&mut recog.err_handler)?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					recog.base.set_state(2043);
					recog.base.match_token(Tilde,&mut recog.err_handler)?;

					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					recog.base.set_state(2044);
					recog.base.match_token(Not,&mut recog.err_handler)?;

					}
				}
			,
				13 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					recog.base.set_state(2045);
					recog.base.match_token(Assign,&mut recog.err_handler)?;

					}
				}
			,
				14 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					recog.base.set_state(2046);
					recog.base.match_token(Greater,&mut recog.err_handler)?;

					}
				}
			,
				15 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					recog.base.set_state(2047);
					recog.base.match_token(Less,&mut recog.err_handler)?;

					}
				}
			,
				16 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 16);
					recog.base.enter_outer_alt(None, 16);
					{
					recog.base.set_state(2048);
					recog.base.match_token(GreaterEqual,&mut recog.err_handler)?;

					}
				}
			,
				17 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 17);
					recog.base.enter_outer_alt(None, 17);
					{
					recog.base.set_state(2049);
					recog.base.match_token(PlusAssign,&mut recog.err_handler)?;

					}
				}
			,
				18 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 18);
					recog.base.enter_outer_alt(None, 18);
					{
					recog.base.set_state(2050);
					recog.base.match_token(MinusAssign,&mut recog.err_handler)?;

					}
				}
			,
				19 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 19);
					recog.base.enter_outer_alt(None, 19);
					{
					recog.base.set_state(2051);
					recog.base.match_token(StarAssign,&mut recog.err_handler)?;

					}
				}
			,
				20 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 20);
					recog.base.enter_outer_alt(None, 20);
					{
					recog.base.set_state(2052);
					recog.base.match_token(ModAssign,&mut recog.err_handler)?;

					}
				}
			,
				21 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 21);
					recog.base.enter_outer_alt(None, 21);
					{
					recog.base.set_state(2053);
					recog.base.match_token(XorAssign,&mut recog.err_handler)?;

					}
				}
			,
				22 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 22);
					recog.base.enter_outer_alt(None, 22);
					{
					recog.base.set_state(2054);
					recog.base.match_token(AndAssign,&mut recog.err_handler)?;

					}
				}
			,
				23 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 23);
					recog.base.enter_outer_alt(None, 23);
					{
					recog.base.set_state(2055);
					recog.base.match_token(OrAssign,&mut recog.err_handler)?;

					}
				}
			,
				24 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 24);
					recog.base.enter_outer_alt(None, 24);
					{
					recog.base.set_state(2056);
					recog.base.match_token(Less,&mut recog.err_handler)?;

					recog.base.set_state(2057);
					recog.base.match_token(Less,&mut recog.err_handler)?;

					}
				}
			,
				25 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 25);
					recog.base.enter_outer_alt(None, 25);
					{
					recog.base.set_state(2058);
					recog.base.match_token(Greater,&mut recog.err_handler)?;

					recog.base.set_state(2059);
					recog.base.match_token(Greater,&mut recog.err_handler)?;

					}
				}
			,
				26 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 26);
					recog.base.enter_outer_alt(None, 26);
					{
					recog.base.set_state(2060);
					recog.base.match_token(RightShiftAssign,&mut recog.err_handler)?;

					}
				}
			,
				27 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 27);
					recog.base.enter_outer_alt(None, 27);
					{
					recog.base.set_state(2061);
					recog.base.match_token(LeftShiftAssign,&mut recog.err_handler)?;

					}
				}
			,
				28 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 28);
					recog.base.enter_outer_alt(None, 28);
					{
					recog.base.set_state(2062);
					recog.base.match_token(Equal,&mut recog.err_handler)?;

					}
				}
			,
				29 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 29);
					recog.base.enter_outer_alt(None, 29);
					{
					recog.base.set_state(2063);
					recog.base.match_token(NotEqual,&mut recog.err_handler)?;

					}
				}
			,
				30 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 30);
					recog.base.enter_outer_alt(None, 30);
					{
					recog.base.set_state(2064);
					recog.base.match_token(LessEqual,&mut recog.err_handler)?;

					}
				}
			,
				31 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 31);
					recog.base.enter_outer_alt(None, 31);
					{
					recog.base.set_state(2065);
					recog.base.match_token(AndAnd,&mut recog.err_handler)?;

					}
				}
			,
				32 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 32);
					recog.base.enter_outer_alt(None, 32);
					{
					recog.base.set_state(2066);
					recog.base.match_token(OrOr,&mut recog.err_handler)?;

					}
				}
			,
				33 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 33);
					recog.base.enter_outer_alt(None, 33);
					{
					recog.base.set_state(2067);
					recog.base.match_token(PlusPlus,&mut recog.err_handler)?;

					}
				}
			,
				34 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 34);
					recog.base.enter_outer_alt(None, 34);
					{
					recog.base.set_state(2068);
					recog.base.match_token(MinusMinus,&mut recog.err_handler)?;

					}
				}
			,
				35 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 35);
					recog.base.enter_outer_alt(None, 35);
					{
					recog.base.set_state(2069);
					recog.base.match_token(Comma,&mut recog.err_handler)?;

					}
				}
			,
				36 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 36);
					recog.base.enter_outer_alt(None, 36);
					{
					recog.base.set_state(2070);
					recog.base.match_token(ArrowStar,&mut recog.err_handler)?;

					}
				}
			,
				37 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 37);
					recog.base.enter_outer_alt(None, 37);
					{
					recog.base.set_state(2071);
					recog.base.match_token(Arrow,&mut recog.err_handler)?;

					}
				}
			,
				38 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 38);
					recog.base.enter_outer_alt(None, 38);
					{
					recog.base.set_state(2072);
					recog.base.match_token(LeftParen,&mut recog.err_handler)?;

					recog.base.set_state(2073);
					recog.base.match_token(RightParen,&mut recog.err_handler)?;

					}
				}
			,
				39 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 39);
					recog.base.enter_outer_alt(None, 39);
					{
					recog.base.set_state(2074);
					recog.base.match_token(LeftBracket,&mut recog.err_handler)?;

					recog.base.set_state(2075);
					recog.base.match_token(RightBracket,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- literal ----------------
pub type LiteralContextAll<'input> = LiteralContext<'input>;


pub type LiteralContext<'input> = BaseParserRuleContext<'input,LiteralContextExt<'input>>;

#[derive(Clone)]
pub struct LiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> CPP14ParserContext<'input> for LiteralContext<'input>{}

impl<'input,'a> Listenable<dyn CPP14ParserListener<'input> + 'a> for LiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_literal(self);
		}fn exit(&self,listener: &mut (dyn CPP14ParserListener<'input> + 'a)) {
			listener.exit_literal(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = CPP14ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_literal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_literal }
}
antlr_rust::tid!{LiteralContextExt<'a>}

impl<'input> LiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn CPP14ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LiteralContextAttrs<'input>: CPP14ParserContext<'input> + BorrowMut<LiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IntegerLiteral
/// Returns `None` if there is no child corresponding to token IntegerLiteral
fn IntegerLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(IntegerLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token CharacterLiteral
/// Returns `None` if there is no child corresponding to token CharacterLiteral
fn CharacterLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(CharacterLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token FloatingLiteral
/// Returns `None` if there is no child corresponding to token FloatingLiteral
fn FloatingLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(FloatingLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token StringLiteral
/// Returns `None` if there is no child corresponding to token StringLiteral
fn StringLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(StringLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token BooleanLiteral
/// Returns `None` if there is no child corresponding to token BooleanLiteral
fn BooleanLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(BooleanLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token PointerLiteral
/// Returns `None` if there is no child corresponding to token PointerLiteral
fn PointerLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(PointerLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token UserDefinedLiteral
/// Returns `None` if there is no child corresponding to token UserDefinedLiteral
fn UserDefinedLiteral(&self) -> Option<Rc<TerminalNode<'input,CPP14ParserContextType>>> where Self:Sized{
	self.get_token(UserDefinedLiteral, 0)
}

}

impl<'input> LiteralContextAttrs<'input> for LiteralContext<'input>{}

impl<'input, I, H> CPP14Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn literal(&mut self,)
	-> Result<Rc<LiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 380, RULE_literal);
        let mut _localctx: Rc<LiteralContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2078);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << IntegerLiteral) | (1usize << CharacterLiteral) | (1usize << FloatingLiteral) | (1usize << StringLiteral) | (1usize << BooleanLiteral) | (1usize << PointerLiteral) | (1usize << UserDefinedLiteral))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}

lazy_static! {
    static ref _ATN: Arc<ATN> =
        Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(
                _ATN.clone(),
                _ATN.get_decision_state(i),
                i as isize,
            ).into())
        }
        Arc::new(dfa)
    };
}



const _serializedATN:&'static str =
	"\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{93}\u{823}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x04\x7a\x09\
	\x7a\x04\x7b\x09\x7b\x04\x7c\x09\x7c\x04\x7d\x09\x7d\x04\x7e\x09\x7e\x04\
	\x7f\x09\x7f\x04\u{80}\x09\u{80}\x04\u{81}\x09\u{81}\x04\u{82}\x09\u{82}\
	\x04\u{83}\x09\u{83}\x04\u{84}\x09\u{84}\x04\u{85}\x09\u{85}\x04\u{86}\x09\
	\u{86}\x04\u{87}\x09\u{87}\x04\u{88}\x09\u{88}\x04\u{89}\x09\u{89}\x04\u{8a}\
	\x09\u{8a}\x04\u{8b}\x09\u{8b}\x04\u{8c}\x09\u{8c}\x04\u{8d}\x09\u{8d}\x04\
	\u{8e}\x09\u{8e}\x04\u{8f}\x09\u{8f}\x04\u{90}\x09\u{90}\x04\u{91}\x09\u{91}\
	\x04\u{92}\x09\u{92}\x04\u{93}\x09\u{93}\x04\u{94}\x09\u{94}\x04\u{95}\x09\
	\u{95}\x04\u{96}\x09\u{96}\x04\u{97}\x09\u{97}\x04\u{98}\x09\u{98}\x04\u{99}\
	\x09\u{99}\x04\u{9a}\x09\u{9a}\x04\u{9b}\x09\u{9b}\x04\u{9c}\x09\u{9c}\x04\
	\u{9d}\x09\u{9d}\x04\u{9e}\x09\u{9e}\x04\u{9f}\x09\u{9f}\x04\u{a0}\x09\u{a0}\
	\x04\u{a1}\x09\u{a1}\x04\u{a2}\x09\u{a2}\x04\u{a3}\x09\u{a3}\x04\u{a4}\x09\
	\u{a4}\x04\u{a5}\x09\u{a5}\x04\u{a6}\x09\u{a6}\x04\u{a7}\x09\u{a7}\x04\u{a8}\
	\x09\u{a8}\x04\u{a9}\x09\u{a9}\x04\u{aa}\x09\u{aa}\x04\u{ab}\x09\u{ab}\x04\
	\u{ac}\x09\u{ac}\x04\u{ad}\x09\u{ad}\x04\u{ae}\x09\u{ae}\x04\u{af}\x09\u{af}\
	\x04\u{b0}\x09\u{b0}\x04\u{b1}\x09\u{b1}\x04\u{b2}\x09\u{b2}\x04\u{b3}\x09\
	\u{b3}\x04\u{b4}\x09\u{b4}\x04\u{b5}\x09\u{b5}\x04\u{b6}\x09\u{b6}\x04\u{b7}\
	\x09\u{b7}\x04\u{b8}\x09\u{b8}\x04\u{b9}\x09\u{b9}\x04\u{ba}\x09\u{ba}\x04\
	\u{bb}\x09\u{bb}\x04\u{bc}\x09\u{bc}\x04\u{bd}\x09\u{bd}\x04\u{be}\x09\u{be}\
	\x04\u{bf}\x09\u{bf}\x04\u{c0}\x09\u{c0}\x03\x02\x05\x02\u{182}\x0a\x02\
	\x03\x02\x03\x02\x03\x03\x06\x03\u{187}\x0a\x03\x0d\x03\x0e\x03\u{188}\x03\
	\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x05\x03\u{192}\x0a\
	\x03\x03\x04\x03\x04\x05\x04\u{196}\x0a\x04\x03\x05\x03\x05\x03\x05\x03\
	\x05\x03\x05\x03\x05\x03\x05\x05\x05\u{19f}\x0a\x05\x03\x05\x05\x05\u{1a2}\
	\x0a\x05\x03\x06\x03\x06\x05\x06\u{1a6}\x0a\x06\x03\x06\x03\x06\x03\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{1ae}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x05\x07\u{1b5}\x0a\x07\x03\x07\x05\x07\u{1b8}\x0a\x07\x03\
	\x07\x07\x07\u{1bb}\x0a\x07\x0c\x07\x0e\x07\u{1be}\x0b\x07\x03\x08\x03\x08\
	\x05\x08\u{1c2}\x0a\x08\x03\x08\x03\x08\x03\x09\x03\x09\x05\x09\u{1c8}\x0a\
	\x09\x03\x09\x03\x09\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x05\x0a\u{1d0}\x0a\
	\x0a\x05\x0a\u{1d2}\x0a\x0a\x03\x0b\x03\x0b\x03\x0c\x03\x0c\x03\x0c\x07\
	\x0c\u{1d9}\x0a\x0c\x0c\x0c\x0e\x0c\u{1dc}\x0b\x0c\x03\x0c\x05\x0c\u{1df}\
	\x0a\x0c\x03\x0d\x03\x0d\x05\x0d\u{1e3}\x0a\x0d\x03\x0e\x05\x0e\u{1e6}\x0a\
	\x0e\x03\x0e\x03\x0e\x05\x0e\u{1ea}\x0a\x0e\x03\x0f\x05\x0f\u{1ed}\x0a\x0f\
	\x03\x0f\x03\x0f\x03\x0f\x03\x10\x03\x10\x05\x10\u{1f4}\x0a\x10\x03\x10\
	\x03\x10\x05\x10\u{1f8}\x0a\x10\x03\x10\x05\x10\u{1fb}\x0a\x10\x03\x10\x05\
	\x10\u{1fe}\x0a\x10\x03\x10\x05\x10\u{201}\x0a\x10\x03\x11\x03\x11\x03\x11\
	\x03\x11\x05\x11\u{207}\x0a\x11\x03\x11\x03\x11\x05\x11\u{20b}\x0a\x11\x03\
	\x11\x03\x11\x05\x11\u{20f}\x0a\x11\x03\x11\x03\x11\x03\x11\x03\x11\x03\
	\x11\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\x05\x11\u{21d}\
	\x0a\x11\x03\x11\x03\x11\x05\x11\u{221}\x0a\x11\x03\x11\x03\x11\x03\x11\
	\x03\x11\x05\x11\u{227}\x0a\x11\x03\x11\x03\x11\x03\x11\x03\x11\x03\x11\
	\x05\x11\u{22e}\x0a\x11\x03\x11\x03\x11\x03\x11\x03\x11\x05\x11\u{234}\x0a\
	\x11\x03\x11\x03\x11\x05\x11\u{238}\x0a\x11\x03\x11\x03\x11\x07\x11\u{23c}\
	\x0a\x11\x0c\x11\x0e\x11\u{23f}\x0b\x11\x03\x12\x03\x12\x03\x13\x03\x13\
	\x03\x14\x05\x14\u{246}\x0a\x14\x03\x14\x03\x14\x03\x14\x05\x14\u{24b}\x0a\
	\x14\x03\x14\x03\x14\x03\x14\x03\x14\x03\x14\x03\x14\x03\x14\x03\x14\x03\
	\x14\x03\x14\x03\x14\x05\x14\u{258}\x0a\x14\x03\x15\x03\x15\x03\x15\x03\
	\x15\x03\x15\x05\x15\u{25f}\x0a\x15\x03\x15\x03\x15\x03\x15\x03\x15\x03\
	\x15\x03\x15\x03\x15\x03\x15\x03\x15\x03\x15\x05\x15\u{26b}\x0a\x15\x03\
	\x15\x03\x15\x03\x15\x03\x15\x03\x15\x03\x15\x03\x15\x03\x15\x05\x15\u{275}\
	\x0a\x15\x03\x16\x03\x16\x03\x17\x05\x17\u{27a}\x0a\x17\x03\x17\x03\x17\
	\x05\x17\u{27e}\x0a\x17\x03\x17\x03\x17\x03\x17\x03\x17\x03\x17\x05\x17\
	\u{285}\x0a\x17\x03\x17\x05\x17\u{288}\x0a\x17\x03\x18\x03\x18\x03\x18\x03\
	\x18\x03\x19\x03\x19\x05\x19\u{290}\x0a\x19\x03\x1a\x03\x1a\x05\x1a\u{294}\
	\x0a\x1a\x03\x1a\x05\x1a\u{297}\x0a\x1a\x03\x1b\x03\x1b\x03\x1b\x03\x1b\
	\x03\x1b\x05\x1b\u{29e}\x0a\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\
	\x05\x1b\u{2a5}\x0a\x1b\x07\x1b\u{2a7}\x0a\x1b\x0c\x1b\x0e\x1b\u{2aa}\x0b\
	\x1b\x03\x1c\x03\x1c\x05\x1c\u{2ae}\x0a\x1c\x03\x1c\x03\x1c\x05\x1c\u{2b2}\
	\x0a\x1c\x03\x1d\x05\x1d\u{2b5}\x0a\x1d\x03\x1d\x03\x1d\x03\x1d\x05\x1d\
	\u{2ba}\x0a\x1d\x03\x1d\x03\x1d\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x03\x1e\
	\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x05\x1f\u{2c9}\x0a\x1f\
	\x03\x20\x03\x20\x03\x20\x07\x20\u{2ce}\x0a\x20\x0c\x20\x0e\x20\u{2d1}\x0b\
	\x20\x03\x21\x03\x21\x03\x21\x07\x21\u{2d6}\x0a\x21\x0c\x21\x0e\x21\u{2d9}\
	\x0b\x21\x03\x22\x03\x22\x03\x22\x07\x22\u{2de}\x0a\x22\x0c\x22\x0e\x22\
	\u{2e1}\x0b\x22\x03\x23\x03\x23\x03\x23\x03\x23\x07\x23\u{2e7}\x0a\x23\x0c\
	\x23\x0e\x23\u{2ea}\x0b\x23\x03\x24\x03\x24\x03\x24\x03\x24\x05\x24\u{2f0}\
	\x0a\x24\x03\x25\x03\x25\x03\x25\x07\x25\u{2f5}\x0a\x25\x0c\x25\x0e\x25\
	\u{2f8}\x0b\x25\x03\x26\x03\x26\x03\x26\x07\x26\u{2fd}\x0a\x26\x0c\x26\x0e\
	\x26\u{300}\x0b\x26\x03\x27\x03\x27\x03\x27\x07\x27\u{305}\x0a\x27\x0c\x27\
	\x0e\x27\u{308}\x0b\x27\x03\x28\x03\x28\x03\x28\x07\x28\u{30d}\x0a\x28\x0c\
	\x28\x0e\x28\u{310}\x0b\x28\x03\x29\x03\x29\x03\x29\x07\x29\u{315}\x0a\x29\
	\x0c\x29\x0e\x29\u{318}\x0b\x29\x03\x2a\x03\x2a\x03\x2a\x07\x2a\u{31d}\x0a\
	\x2a\x0c\x2a\x0e\x2a\u{320}\x0b\x2a\x03\x2b\x03\x2b\x03\x2b\x07\x2b\u{325}\
	\x0a\x2b\x0c\x2b\x0e\x2b\u{328}\x0b\x2b\x03\x2c\x03\x2c\x03\x2c\x03\x2c\
	\x03\x2c\x03\x2c\x05\x2c\u{330}\x0a\x2c\x03\x2d\x03\x2d\x03\x2d\x03\x2d\
	\x03\x2d\x03\x2d\x05\x2d\u{338}\x0a\x2d\x03\x2e\x03\x2e\x03\x2f\x03\x2f\
	\x03\x2f\x07\x2f\u{33f}\x0a\x2f\x0c\x2f\x0e\x2f\u{342}\x0b\x2f\x03\x30\x03\
	\x30\x03\x31\x03\x31\x03\x31\x05\x31\u{349}\x0a\x31\x03\x31\x03\x31\x03\
	\x31\x03\x31\x03\x31\x03\x31\x05\x31\u{351}\x0a\x31\x05\x31\u{353}\x0a\x31\
	\x03\x32\x05\x32\u{356}\x0a\x32\x03\x32\x03\x32\x03\x32\x03\x32\x05\x32\
	\u{35c}\x0a\x32\x03\x32\x03\x32\x03\x32\x03\x33\x05\x33\u{362}\x0a\x33\x03\
	\x33\x03\x33\x03\x34\x03\x34\x05\x34\u{368}\x0a\x34\x03\x34\x03\x34\x03\
	\x35\x06\x35\u{36d}\x0a\x35\x0d\x35\x0e\x35\u{36e}\x03\x36\x03\x36\x03\x36\
	\x03\x36\x03\x36\x03\x36\x03\x36\x05\x36\u{378}\x0a\x36\x03\x36\x03\x36\
	\x03\x36\x03\x36\x03\x36\x03\x36\x05\x36\u{380}\x0a\x36\x03\x37\x03\x37\
	\x05\x37\u{384}\x0a\x37\x03\x37\x03\x37\x03\x37\x03\x37\x03\x37\x05\x37\
	\u{38b}\x0a\x37\x05\x37\u{38d}\x0a\x37\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\x38\x03\
	\x38\x03\x38\x03\x38\x03\x38\x03\x38\x05\x38\u{3a1}\x0a\x38\x03\x38\x03\
	\x38\x05\x38\u{3a5}\x0a\x38\x03\x38\x03\x38\x03\x38\x03\x38\x05\x38\u{3ab}\
	\x0a\x38\x03\x38\x03\x38\x03\x38\x05\x38\u{3b0}\x0a\x38\x03\x39\x03\x39\
	\x05\x39\u{3b4}\x0a\x39\x03\x3a\x05\x3a\u{3b7}\x0a\x3a\x03\x3a\x03\x3a\x03\
	\x3a\x03\x3b\x03\x3b\x05\x3b\u{3be}\x0a\x3b\x03\x3c\x03\x3c\x03\x3c\x03\
	\x3c\x03\x3c\x05\x3c\u{3c5}\x0a\x3c\x03\x3c\x03\x3c\x05\x3c\u{3c9}\x0a\x3c\
	\x03\x3c\x03\x3c\x03\x3d\x03\x3d\x03\x3e\x06\x3e\u{3d0}\x0a\x3e\x0d\x3e\
	\x0e\x3e\u{3d1}\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\
	\x03\x3f\x03\x3f\x05\x3f\u{3dd}\x0a\x3f\x03\x40\x03\x40\x03\x40\x03\x40\
	\x03\x40\x03\x40\x03\x40\x03\x40\x05\x40\u{3e7}\x0a\x40\x03\x41\x03\x41\
	\x03\x41\x05\x41\u{3ec}\x0a\x41\x03\x41\x03\x41\x03\x41\x03\x41\x03\x42\
	\x05\x42\u{3f3}\x0a\x42\x03\x42\x05\x42\u{3f6}\x0a\x42\x03\x42\x03\x42\x03\
	\x42\x05\x42\u{3fb}\x0a\x42\x03\x42\x03\x42\x03\x42\x05\x42\u{400}\x0a\x42\
	\x03\x43\x03\x43\x03\x43\x03\x43\x03\x43\x03\x43\x03\x43\x03\x43\x03\x44\
	\x03\x44\x03\x45\x03\x45\x03\x45\x03\x46\x03\x46\x03\x46\x03\x46\x03\x46\
	\x03\x46\x05\x46\u{415}\x0a\x46\x03\x47\x06\x47\u{418}\x0a\x47\x0d\x47\x0e\
	\x47\u{419}\x03\x47\x05\x47\u{41d}\x0a\x47\x03\x48\x03\x48\x03\x49\x03\x49\
	\x03\x4a\x03\x4a\x03\x4b\x03\x4b\x03\x4b\x05\x4b\u{428}\x0a\x4b\x03\x4c\
	\x03\x4c\x03\x4c\x03\x4c\x05\x4c\u{42e}\x0a\x4c\x03\x4d\x06\x4d\u{431}\x0a\
	\x4d\x0d\x4d\x0e\x4d\u{432}\x03\x4d\x05\x4d\u{436}\x0a\x4d\x03\x4e\x06\x4e\
	\u{439}\x0a\x4e\x0d\x4e\x0e\x4e\u{43a}\x03\x4e\x05\x4e\u{43e}\x0a\x4e\x03\
	\x4f\x03\x4f\x03\x50\x03\x50\x03\x51\x05\x51\u{445}\x0a\x51\x03\x51\x03\
	\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\
	\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\x51\x03\
	\x51\x03\x51\x05\x51\u{45c}\x0a\x51\x03\x52\x03\x52\x03\x52\x03\x52\x05\
	\x52\u{462}\x0a\x52\x03\x53\x03\x53\x03\x53\x03\x53\x05\x53\u{468}\x0a\x53\
	\x03\x53\x03\x53\x03\x54\x03\x54\x05\x54\u{46e}\x0a\x54\x03\x54\x05\x54\
	\u{471}\x0a\x54\x03\x54\x03\x54\x03\x54\x03\x54\x05\x54\u{477}\x0a\x54\x03\
	\x54\x03\x54\x05\x54\u{47b}\x0a\x54\x03\x54\x03\x54\x05\x54\u{47f}\x0a\x54\
	\x03\x54\x05\x54\u{482}\x0a\x54\x03\x55\x03\x55\x03\x56\x03\x56\x03\x56\
	\x03\x56\x05\x56\u{48a}\x0a\x56\x05\x56\u{48c}\x0a\x56\x03\x56\x03\x56\x03\
	\x57\x03\x57\x05\x57\u{492}\x0a\x57\x03\x57\x05\x57\u{495}\x0a\x57\x03\x57\
	\x05\x57\u{498}\x0a\x57\x03\x57\x05\x57\u{49b}\x0a\x57\x03\x58\x03\x58\x05\
	\x58\u{49f}\x0a\x58\x03\x58\x03\x58\x05\x58\u{4a3}\x0a\x58\x03\x58\x03\x58\
	\x03\x59\x03\x59\x05\x59\u{4a9}\x0a\x59\x03\x5a\x03\x5a\x03\x5a\x03\x5b\
	\x03\x5b\x03\x5b\x07\x5b\u{4b1}\x0a\x5b\x0c\x5b\x0e\x5b\u{4b4}\x0b\x5b\x03\
	\x5c\x03\x5c\x03\x5c\x05\x5c\u{4b9}\x0a\x5c\x03\x5d\x03\x5d\x03\x5e\x03\
	\x5e\x05\x5e\u{4bf}\x0a\x5e\x03\x5f\x03\x5f\x03\x60\x05\x60\u{4c4}\x0a\x60\
	\x03\x60\x03\x60\x03\x60\x05\x60\u{4c9}\x0a\x60\x03\x60\x03\x60\x05\x60\
	\u{4cd}\x0a\x60\x03\x60\x03\x60\x03\x61\x03\x61\x03\x62\x03\x62\x03\x62\
	\x03\x62\x03\x62\x03\x62\x03\x63\x05\x63\u{4da}\x0a\x63\x03\x63\x03\x63\
	\x03\x64\x03\x64\x05\x64\u{4e0}\x0a\x64\x03\x64\x03\x64\x05\x64\u{4e4}\x0a\
	\x64\x03\x64\x03\x64\x03\x64\x03\x65\x05\x65\u{4ea}\x0a\x65\x03\x65\x03\
	\x65\x03\x65\x05\x65\u{4ef}\x0a\x65\x03\x65\x03\x65\x03\x65\x03\x66\x03\
	\x66\x03\x66\x03\x66\x03\x66\x03\x66\x03\x67\x03\x67\x03\x67\x03\x67\x05\
	\x67\u{4fe}\x0a\x67\x03\x67\x03\x67\x05\x67\u{502}\x0a\x67\x03\x68\x06\x68\
	\u{505}\x0a\x68\x0d\x68\x0e\x68\u{506}\x03\x69\x03\x69\x03\x69\x05\x69\u{50c}\
	\x0a\x69\x03\x69\x03\x69\x03\x69\x05\x69\u{511}\x0a\x69\x03\x6a\x03\x6a\
	\x03\x6a\x03\x6a\x05\x6a\u{517}\x0a\x6a\x03\x6a\x05\x6a\u{51a}\x0a\x6a\x03\
	\x6a\x03\x6a\x03\x6b\x03\x6b\x03\x6b\x07\x6b\u{521}\x0a\x6b\x0c\x6b\x0e\
	\x6b\u{524}\x0b\x6b\x03\x6b\x05\x6b\u{527}\x0a\x6b\x03\x6c\x03\x6c\x03\x6c\
	\x05\x6c\u{52c}\x0a\x6c\x03\x6c\x03\x6c\x05\x6c\u{530}\x0a\x6c\x03\x6d\x03\
	\x6d\x03\x6e\x03\x6e\x05\x6e\u{536}\x0a\x6e\x03\x6e\x03\x6e\x03\x6f\x06\
	\x6f\u{53b}\x0a\x6f\x0d\x6f\x0e\x6f\u{53c}\x03\x70\x03\x70\x03\x70\x03\x70\
	\x03\x70\x03\x70\x03\x70\x03\x70\x03\x70\x03\x70\x03\x70\x03\x70\x03\x70\
	\x06\x70\u{54c}\x0a\x70\x0d\x70\x0e\x70\u{54d}\x05\x70\u{550}\x0a\x70\x03\
	\x71\x03\x71\x03\x71\x07\x71\u{555}\x0a\x71\x0c\x71\x0e\x71\u{558}\x0b\x71\
	\x03\x72\x03\x72\x05\x72\u{55c}\x0a\x72\x03\x73\x03\x73\x03\x73\x03\x73\
	\x03\x73\x05\x73\u{563}\x0a\x73\x03\x74\x03\x74\x05\x74\u{567}\x0a\x74\x07\
	\x74\u{569}\x0a\x74\x0c\x74\x0e\x74\u{56c}\x0b\x74\x03\x74\x03\x74\x03\x75\
	\x03\x75\x03\x75\x05\x75\u{573}\x0a\x75\x03\x75\x03\x75\x03\x75\x03\x75\
	\x05\x75\u{579}\x0a\x75\x03\x75\x03\x75\x03\x75\x03\x75\x05\x75\u{57f}\x0a\
	\x75\x03\x75\x03\x75\x05\x75\u{583}\x0a\x75\x05\x75\u{585}\x0a\x75\x07\x75\
	\u{587}\x0a\x75\x0c\x75\x0e\x75\u{58a}\x0b\x75\x03\x76\x03\x76\x05\x76\u{58e}\
	\x0a\x76\x03\x76\x03\x76\x05\x76\u{592}\x0a\x76\x03\x76\x05\x76\u{595}\x0a\
	\x76\x03\x76\x05\x76\u{598}\x0a\x76\x03\x76\x05\x76\u{59b}\x0a\x76\x03\x77\
	\x03\x77\x03\x77\x05\x77\u{5a0}\x0a\x77\x03\x78\x03\x78\x05\x78\u{5a4}\x0a\
	\x78\x03\x78\x05\x78\u{5a7}\x0a\x78\x03\x78\x03\x78\x05\x78\u{5ab}\x0a\x78\
	\x03\x78\x05\x78\u{5ae}\x0a\x78\x05\x78\u{5b0}\x0a\x78\x03\x79\x06\x79\u{5b3}\
	\x0a\x79\x0d\x79\x0e\x79\u{5b4}\x03\x7a\x03\x7a\x03\x7b\x03\x7b\x03\x7c\
	\x05\x7c\u{5bc}\x0a\x7c\x03\x7c\x03\x7c\x03\x7d\x03\x7d\x05\x7d\u{5c2}\x0a\
	\x7d\x03\x7e\x03\x7e\x05\x7e\u{5c6}\x0a\x7e\x03\x7e\x03\x7e\x03\x7e\x03\
	\x7e\x05\x7e\u{5cc}\x0a\x7e\x03\x7f\x03\x7f\x06\x7f\u{5d0}\x0a\x7f\x0d\x7f\
	\x0e\x7f\u{5d1}\x03\x7f\x05\x7f\u{5d5}\x0a\x7f\x05\x7f\u{5d7}\x0a\x7f\x03\
	\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x05\u{80}\u{5dd}\x0a\u{80}\x03\u{80}\
	\x03\u{80}\x05\u{80}\u{5e1}\x0a\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x03\
	\u{80}\x05\u{80}\u{5e7}\x0a\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\
	\x03\u{80}\x05\u{80}\u{5ee}\x0a\u{80}\x03\u{80}\x03\u{80}\x05\u{80}\u{5f2}\
	\x0a\u{80}\x05\u{80}\u{5f4}\x0a\u{80}\x07\u{80}\u{5f6}\x0a\u{80}\x0c\u{80}\
	\x0e\u{80}\u{5f9}\x0b\u{80}\x03\u{81}\x07\u{81}\u{5fc}\x0a\u{81}\x0c\u{81}\
	\x0e\u{81}\u{5ff}\x0b\u{81}\x03\u{81}\x03\u{81}\x03\u{82}\x03\u{82}\x03\
	\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x05\u{82}\u{60a}\x0a\u{82}\
	\x03\u{82}\x03\u{82}\x05\u{82}\u{60e}\x0a\u{82}\x05\u{82}\u{610}\x0a\u{82}\
	\x07\u{82}\u{612}\x0a\u{82}\x0c\u{82}\x0e\u{82}\u{615}\x0b\u{82}\x03\u{83}\
	\x03\u{83}\x05\u{83}\u{619}\x0a\u{83}\x03\u{83}\x05\u{83}\u{61c}\x0a\u{83}\
	\x03\u{84}\x03\u{84}\x03\u{84}\x07\u{84}\u{621}\x0a\u{84}\x0c\u{84}\x0e\
	\u{84}\u{624}\x0b\u{84}\x03\u{85}\x05\u{85}\u{627}\x0a\u{85}\x03\u{85}\x03\
	\u{85}\x03\u{85}\x05\u{85}\u{62c}\x0a\u{85}\x05\u{85}\u{62e}\x0a\u{85}\x03\
	\u{85}\x03\u{85}\x05\u{85}\u{632}\x0a\u{85}\x03\u{86}\x05\u{86}\u{635}\x0a\
	\u{86}\x03\u{86}\x05\u{86}\u{638}\x0a\u{86}\x03\u{86}\x03\u{86}\x05\u{86}\
	\u{63c}\x0a\u{86}\x03\u{86}\x03\u{86}\x03\u{87}\x05\u{87}\u{641}\x0a\u{87}\
	\x03\u{87}\x03\u{87}\x03\u{87}\x03\u{87}\x03\u{87}\x05\u{87}\u{648}\x0a\
	\u{87}\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x05\u{88}\u{64f}\
	\x0a\u{88}\x03\u{89}\x03\u{89}\x03\u{89}\x05\u{89}\u{654}\x0a\u{89}\x03\
	\u{8a}\x03\u{8a}\x05\u{8a}\u{658}\x0a\u{8a}\x03\u{8b}\x03\u{8b}\x05\u{8b}\
	\u{65c}\x0a\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x05\u{8b}\u{661}\x0a\u{8b}\
	\x07\u{8b}\u{663}\x0a\u{8b}\x0c\u{8b}\x0e\u{8b}\u{666}\x0b\u{8b}\x03\u{8c}\
	\x03\u{8c}\x03\u{8c}\x05\u{8c}\u{66b}\x0a\u{8c}\x05\u{8c}\u{66d}\x0a\u{8c}\
	\x03\u{8c}\x03\u{8c}\x03\u{8d}\x03\u{8d}\x05\u{8d}\u{673}\x0a\u{8d}\x03\
	\u{8e}\x03\u{8e}\x03\u{8e}\x05\u{8e}\u{678}\x0a\u{8e}\x03\u{8e}\x03\u{8e}\
	\x03\u{8f}\x03\u{8f}\x05\u{8f}\u{67e}\x0a\u{8f}\x03\u{8f}\x03\u{8f}\x05\
	\u{8f}\u{682}\x0a\u{8f}\x05\u{8f}\u{684}\x0a\u{8f}\x03\u{8f}\x05\u{8f}\u{687}\
	\x0a\u{8f}\x03\u{8f}\x03\u{8f}\x05\u{8f}\u{68b}\x0a\u{8f}\x03\u{8f}\x03\
	\u{8f}\x05\u{8f}\u{68f}\x0a\u{8f}\x05\u{8f}\u{691}\x0a\u{8f}\x05\u{8f}\u{693}\
	\x0a\u{8f}\x03\u{90}\x05\u{90}\u{696}\x0a\u{90}\x03\u{90}\x03\u{90}\x03\
	\u{91}\x03\u{91}\x03\u{92}\x03\u{92}\x03\u{93}\x03\u{93}\x03\u{93}\x03\u{93}\
	\x06\u{93}\u{6a2}\x0a\u{93}\x0d\u{93}\x0e\u{93}\u{6a3}\x03\u{94}\x05\u{94}\
	\u{6a7}\x0a\u{94}\x03\u{94}\x05\u{94}\u{6aa}\x0a\u{94}\x03\u{94}\x05\u{94}\
	\u{6ad}\x0a\u{94}\x03\u{94}\x03\u{94}\x03\u{94}\x03\u{94}\x03\u{94}\x03\
	\u{94}\x03\u{94}\x05\u{94}\u{6b6}\x0a\u{94}\x03\u{95}\x03\u{95}\x03\u{95}\
	\x07\u{95}\u{6bb}\x0a\u{95}\x0c\u{95}\x0e\u{95}\u{6be}\x0b\u{95}\x03\u{96}\
	\x03\u{96}\x03\u{96}\x03\u{96}\x03\u{96}\x03\u{96}\x03\u{96}\x03\u{96}\x03\
	\u{96}\x05\u{96}\u{6c9}\x0a\u{96}\x03\u{96}\x03\u{96}\x05\u{96}\u{6cd}\x0a\
	\u{96}\x03\u{96}\x05\u{96}\u{6d0}\x0a\u{96}\x03\u{96}\x03\u{96}\x05\u{96}\
	\u{6d4}\x0a\u{96}\x03\u{97}\x06\u{97}\u{6d7}\x0a\u{97}\x0d\u{97}\x0e\u{97}\
	\u{6d8}\x03\u{98}\x03\u{98}\x03\u{99}\x03\u{99}\x03\u{99}\x03\u{9a}\x03\
	\u{9a}\x03\u{9a}\x03\u{9b}\x03\u{9b}\x05\u{9b}\u{6e5}\x0a\u{9b}\x03\u{9b}\
	\x03\u{9b}\x03\u{9b}\x05\u{9b}\u{6ea}\x0a\u{9b}\x07\u{9b}\u{6ec}\x0a\u{9b}\
	\x0c\u{9b}\x0e\u{9b}\u{6ef}\x0b\u{9b}\x03\u{9c}\x05\u{9c}\u{6f2}\x0a\u{9c}\
	\x03\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\u{6f7}\x0a\u{9c}\x03\u{9c}\x03\
	\u{9c}\x03\u{9c}\x05\u{9c}\u{6fc}\x0a\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\
	\u{700}\x0a\u{9c}\x03\u{9d}\x05\u{9d}\u{703}\x0a\u{9d}\x03\u{9d}\x03\u{9d}\
	\x05\u{9d}\u{707}\x0a\u{9d}\x03\u{9e}\x03\u{9e}\x03\u{9f}\x03\u{9f}\x03\
	\u{a0}\x03\u{a0}\x03\u{a0}\x03\u{a1}\x03\u{a1}\x05\u{a1}\u{712}\x0a\u{a1}\
	\x03\u{a2}\x03\u{a2}\x05\u{a2}\u{716}\x0a\u{a2}\x03\u{a3}\x03\u{a3}\x03\
	\u{a3}\x03\u{a4}\x03\u{a4}\x05\u{a4}\u{71d}\x0a\u{a4}\x03\u{a4}\x03\u{a4}\
	\x03\u{a4}\x05\u{a4}\u{722}\x0a\u{a4}\x07\u{a4}\u{724}\x0a\u{a4}\x0c\u{a4}\
	\x0e\u{a4}\u{727}\x0b\u{a4}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x05\u{a5}\u{72c}\
	\x0a\u{a5}\x03\u{a5}\x03\u{a5}\x05\u{a5}\u{730}\x0a\u{a5}\x03\u{a6}\x03\
	\u{a6}\x05\u{a6}\u{734}\x0a\u{a6}\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a8}\
	\x03\u{a8}\x03\u{a8}\x03\u{a8}\x05\u{a8}\u{73d}\x0a\u{a8}\x03\u{a9}\x03\
	\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{aa}\x03\u{aa}\x03\u{aa}\
	\x07\u{aa}\u{748}\x0a\u{aa}\x0c\u{aa}\x0e\u{aa}\u{74b}\x0b\u{aa}\x03\u{ab}\
	\x03\u{ab}\x05\u{ab}\u{74f}\x0a\u{ab}\x03\u{ac}\x03\u{ac}\x03\u{ac}\x03\
	\u{ac}\x03\u{ac}\x05\u{ac}\u{756}\x0a\u{ac}\x03\u{ac}\x03\u{ac}\x05\u{ac}\
	\u{75a}\x0a\u{ac}\x03\u{ac}\x05\u{ac}\u{75d}\x0a\u{ac}\x03\u{ac}\x05\u{ac}\
	\u{760}\x0a\u{ac}\x03\u{ac}\x05\u{ac}\u{763}\x0a\u{ac}\x03\u{ac}\x03\u{ac}\
	\x05\u{ac}\u{767}\x0a\u{ac}\x03\u{ad}\x03\u{ad}\x03\u{ad}\x05\u{ad}\u{76c}\
	\x0a\u{ad}\x03\u{ad}\x03\u{ad}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x05\u{ae}\u{773}\
	\x0a\u{ae}\x03\u{ae}\x03\u{ae}\x05\u{ae}\u{777}\x0a\u{ae}\x03\u{ae}\x03\
	\u{ae}\x05\u{ae}\u{77b}\x0a\u{ae}\x03\u{af}\x03\u{af}\x03\u{b0}\x03\u{b0}\
	\x05\u{b0}\u{781}\x0a\u{b0}\x03\u{b0}\x03\u{b0}\x03\u{b0}\x05\u{b0}\u{786}\
	\x0a\u{b0}\x07\u{b0}\u{788}\x0a\u{b0}\x0c\u{b0}\x0e\u{b0}\u{78b}\x0b\u{b0}\
	\x03\u{b1}\x03\u{b1}\x03\u{b1}\x05\u{b1}\u{790}\x0a\u{b1}\x03\u{b2}\x03\
	\u{b2}\x03\u{b2}\x03\u{b2}\x05\u{b2}\u{796}\x0a\u{b2}\x03\u{b2}\x05\u{b2}\
	\u{799}\x0a\u{b2}\x03\u{b3}\x05\u{b3}\u{79c}\x0a\u{b3}\x03\u{b3}\x03\u{b3}\
	\x03\u{b3}\x03\u{b4}\x03\u{b4}\x03\u{b4}\x03\u{b4}\x03\u{b4}\x03\u{b5}\x03\
	\u{b5}\x03\u{b5}\x03\u{b5}\x03\u{b6}\x03\u{b6}\x05\u{b6}\u{7ac}\x0a\u{b6}\
	\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b7}\x06\u{b7}\u{7b2}\x0a\u{b7}\x0d\
	\u{b7}\x0e\u{b7}\u{7b3}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b8}\
	\x03\u{b8}\x03\u{b9}\x05\u{b9}\u{7bd}\x0a\u{b9}\x03\u{b9}\x03\u{b9}\x03\
	\u{b9}\x05\u{b9}\u{7c2}\x0a\u{b9}\x03\u{b9}\x05\u{b9}\u{7c5}\x0a\u{b9}\x03\
	\u{ba}\x03\u{ba}\x05\u{ba}\u{7c9}\x0a\u{ba}\x03\u{bb}\x03\u{bb}\x05\u{bb}\
	\u{7cd}\x0a\u{bb}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x05\u{bc}\u{7d2}\x0a\u{bc}\
	\x03\u{bc}\x03\u{bc}\x03\u{bd}\x03\u{bd}\x05\u{bd}\u{7d8}\x0a\u{bd}\x03\
	\u{bd}\x03\u{bd}\x03\u{bd}\x05\u{bd}\u{7dd}\x0a\u{bd}\x07\u{bd}\u{7df}\x0a\
	\u{bd}\x0c\u{bd}\x0e\u{bd}\u{7e2}\x0b\u{bd}\x03\u{be}\x03\u{be}\x03\u{be}\
	\x03\u{be}\x03\u{be}\x03\u{be}\x05\u{be}\u{7ea}\x0a\u{be}\x03\u{bf}\x03\
	\u{bf}\x03\u{bf}\x05\u{bf}\u{7ef}\x0a\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\
	\x05\u{bf}\u{7f4}\x0a\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\
	\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\
	\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\
	\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\
	\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\
	\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x05\u{bf}\
	\u{81f}\x0a\u{bf}\x03\u{c0}\x03\u{c0}\x03\u{c0}\x03\u{419}\x08\x0c\x20\x34\
	\u{e8}\u{fe}\u{102}\u{c1}\x02\x04\x06\x08\x0a\x0c\x0e\x10\x12\x14\x16\x18\
	\x1a\x1c\x1e\x20\x22\x24\x26\x28\x2a\x2c\x2e\x30\x32\x34\x36\x38\x3a\x3c\
	\x3e\x40\x42\x44\x46\x48\x4a\x4c\x4e\x50\x52\x54\x56\x58\x5a\x5c\x5e\x60\
	\x62\x64\x66\x68\x6a\x6c\x6e\x70\x72\x74\x76\x78\x7a\x7c\x7e\u{80}\u{82}\
	\u{84}\u{86}\u{88}\u{8a}\u{8c}\u{8e}\u{90}\u{92}\u{94}\u{96}\u{98}\u{9a}\
	\u{9c}\u{9e}\u{a0}\u{a2}\u{a4}\u{a6}\u{a8}\u{aa}\u{ac}\u{ae}\u{b0}\u{b2}\
	\u{b4}\u{b6}\u{b8}\u{ba}\u{bc}\u{be}\u{c0}\u{c2}\u{c4}\u{c6}\u{c8}\u{ca}\
	\u{cc}\u{ce}\u{d0}\u{d2}\u{d4}\u{d6}\u{d8}\u{da}\u{dc}\u{de}\u{e0}\u{e2}\
	\u{e4}\u{e6}\u{e8}\u{ea}\u{ec}\u{ee}\u{f0}\u{f2}\u{f4}\u{f6}\u{f8}\u{fa}\
	\u{fc}\u{fe}\u{100}\u{102}\u{104}\u{106}\u{108}\u{10a}\u{10c}\u{10e}\u{110}\
	\u{112}\u{114}\u{116}\u{118}\u{11a}\u{11c}\u{11e}\u{120}\u{122}\u{124}\u{126}\
	\u{128}\u{12a}\u{12c}\u{12e}\u{130}\u{132}\u{134}\u{136}\u{138}\u{13a}\u{13c}\
	\u{13e}\u{140}\u{142}\u{144}\u{146}\u{148}\u{14a}\u{14c}\u{14e}\u{150}\u{152}\
	\u{154}\u{156}\u{158}\u{15a}\u{15c}\u{15e}\u{160}\u{162}\u{164}\u{166}\u{168}\
	\u{16a}\u{16c}\u{16e}\u{170}\u{172}\u{174}\u{176}\u{178}\u{17a}\u{17c}\u{17e}\
	\x02\x19\x04\x02\x63\x63\x67\x67\x06\x02\x1a\x1a\x21\x21\x3c\x3c\x43\x43\
	\x04\x02\x7e\x7e\u{83}\u{83}\x03\x02\x7a\x7b\x04\x02\x5d\x5f\x63\x66\x04\
	\x02\x7d\x7d\u{84}\u{84}\x03\x02\x5f\x61\x03\x02\x5d\x5e\x04\x02\x68\x69\
	\x76\x77\x03\x02\x74\x75\x04\x02\x67\x67\x6a\x73\x07\x02\x26\x26\x31\x31\
	\x3b\x3b\x41\x41\x48\x48\x05\x02\x24\x24\x2e\x2e\x52\x52\x04\x02\x30\x30\
	\x3e\x3e\x04\x02\x3f\x3f\x50\x50\x04\x02\x17\x17\x44\x44\x03\x02\x57\x5c\
	\x04\x02\x63\x63\x78\x78\x04\x02\x18\x18\x54\x54\x03\x02\x1d\x1e\x04\x02\
	\x28\x28\x37\x37\x03\x02\x38\x3a\x03\x02\x03\x09\x02\u{906}\x02\u{181}\x03\
	\x02\x02\x02\x04\u{191}\x03\x02\x02\x02\x06\u{195}\x03\x02\x02\x02\x08\u{1a1}\
	\x03\x02\x02\x02\x0a\u{1a3}\x03\x02\x02\x02\x0c\u{1a9}\x03\x02\x02\x02\x0e\
	\u{1bf}\x03\x02\x02\x02\x10\u{1c5}\x03\x02\x02\x02\x12\u{1d1}\x03\x02\x02\
	\x02\x14\u{1d3}\x03\x02\x02\x02\x16\u{1d5}\x03\x02\x02\x02\x18\u{1e2}\x03\
	\x02\x02\x02\x1a\u{1e9}\x03\x02\x02\x02\x1c\u{1ec}\x03\x02\x02\x02\x1e\u{1f1}\
	\x03\x02\x02\x02\x20\u{220}\x03\x02\x02\x02\x22\u{240}\x03\x02\x02\x02\x24\
	\u{242}\x03\x02\x02\x02\x26\u{257}\x03\x02\x02\x02\x28\u{274}\x03\x02\x02\
	\x02\x2a\u{276}\x03\x02\x02\x02\x2c\u{279}\x03\x02\x02\x02\x2e\u{289}\x03\
	\x02\x02\x02\x30\u{28d}\x03\x02\x02\x02\x32\u{296}\x03\x02\x02\x02\x34\u{298}\
	\x03\x02\x02\x02\x36\u{2b1}\x03\x02\x02\x02\x38\u{2b4}\x03\x02\x02\x02\x3a\
	\u{2bd}\x03\x02\x02\x02\x3c\u{2c8}\x03\x02\x02\x02\x3e\u{2ca}\x03\x02\x02\
	\x02\x40\u{2d2}\x03\x02\x02\x02\x42\u{2da}\x03\x02\x02\x02\x44\u{2e2}\x03\
	\x02\x02\x02\x46\u{2ef}\x03\x02\x02\x02\x48\u{2f1}\x03\x02\x02\x02\x4a\u{2f9}\
	\x03\x02\x02\x02\x4c\u{301}\x03\x02\x02\x02\x4e\u{309}\x03\x02\x02\x02\x50\
	\u{311}\x03\x02\x02\x02\x52\u{319}\x03\x02\x02\x02\x54\u{321}\x03\x02\x02\
	\x02\x56\u{329}\x03\x02\x02\x02\x58\u{337}\x03\x02\x02\x02\x5a\u{339}\x03\
	\x02\x02\x02\x5c\u{33b}\x03\x02\x02\x02\x5e\u{343}\x03\x02\x02\x02\x60\u{352}\
	\x03\x02\x02\x02\x62\u{355}\x03\x02\x02\x02\x64\u{361}\x03\x02\x02\x02\x66\
	\u{365}\x03\x02\x02\x02\x68\u{36c}\x03\x02\x02\x02\x6a\u{37f}\x03\x02\x02\
	\x02\x6c\u{38c}\x03\x02\x02\x02\x6e\u{3af}\x03\x02\x02\x02\x70\u{3b3}\x03\
	\x02\x02\x02\x72\u{3b6}\x03\x02\x02\x02\x74\u{3bd}\x03\x02\x02\x02\x76\u{3c8}\
	\x03\x02\x02\x02\x78\u{3cc}\x03\x02\x02\x02\x7a\u{3cf}\x03\x02\x02\x02\x7c\
	\u{3dc}\x03\x02\x02\x02\x7e\u{3e6}\x03\x02\x02\x02\u{80}\u{3e8}\x03\x02\
	\x02\x02\u{82}\u{3ff}\x03\x02\x02\x02\u{84}\u{401}\x03\x02\x02\x02\u{86}\
	\u{409}\x03\x02\x02\x02\u{88}\u{40b}\x03\x02\x02\x02\u{8a}\u{414}\x03\x02\
	\x02\x02\u{8c}\u{417}\x03\x02\x02\x02\u{8e}\u{41e}\x03\x02\x02\x02\u{90}\
	\u{420}\x03\x02\x02\x02\u{92}\u{422}\x03\x02\x02\x02\u{94}\u{427}\x03\x02\
	\x02\x02\u{96}\u{42d}\x03\x02\x02\x02\u{98}\u{430}\x03\x02\x02\x02\u{9a}\
	\u{438}\x03\x02\x02\x02\u{9c}\u{43f}\x03\x02\x02\x02\u{9e}\u{441}\x03\x02\
	\x02\x02\u{a0}\u{45b}\x03\x02\x02\x02\u{a2}\u{461}\x03\x02\x02\x02\u{a4}\
	\u{463}\x03\x02\x02\x02\u{a6}\u{481}\x03\x02\x02\x02\u{a8}\u{483}\x03\x02\
	\x02\x02\u{aa}\u{485}\x03\x02\x02\x02\u{ac}\u{48f}\x03\x02\x02\x02\u{ae}\
	\u{49c}\x03\x02\x02\x02\u{b0}\u{4a6}\x03\x02\x02\x02\u{b2}\u{4aa}\x03\x02\
	\x02\x02\u{b4}\u{4ad}\x03\x02\x02\x02\u{b6}\u{4b5}\x03\x02\x02\x02\u{b8}\
	\u{4ba}\x03\x02\x02\x02\u{ba}\u{4be}\x03\x02\x02\x02\u{bc}\u{4c0}\x03\x02\
	\x02\x02\u{be}\u{4c3}\x03\x02\x02\x02\u{c0}\u{4d0}\x03\x02\x02\x02\u{c2}\
	\u{4d2}\x03\x02\x02\x02\u{c4}\u{4d9}\x03\x02\x02\x02\u{c6}\u{4dd}\x03\x02\
	\x02\x02\u{c8}\u{4e9}\x03\x02\x02\x02\u{ca}\u{4f3}\x03\x02\x02\x02\u{cc}\
	\u{4f9}\x03\x02\x02\x02\u{ce}\u{504}\x03\x02\x02\x02\u{d0}\u{510}\x03\x02\
	\x02\x02\u{d2}\u{512}\x03\x02\x02\x02\u{d4}\u{51d}\x03\x02\x02\x02\u{d6}\
	\u{52b}\x03\x02\x02\x02\u{d8}\u{531}\x03\x02\x02\x02\u{da}\u{533}\x03\x02\
	\x02\x02\u{dc}\u{53a}\x03\x02\x02\x02\u{de}\u{54f}\x03\x02\x02\x02\u{e0}\
	\u{551}\x03\x02\x02\x02\u{e2}\u{559}\x03\x02\x02\x02\u{e4}\u{562}\x03\x02\
	\x02\x02\u{e6}\u{56a}\x03\x02\x02\x02\u{e8}\u{578}\x03\x02\x02\x02\u{ea}\
	\u{58b}\x03\x02\x02\x02\u{ec}\u{59c}\x03\x02\x02\x02\u{ee}\u{5af}\x03\x02\
	\x02\x02\u{f0}\u{5b2}\x03\x02\x02\x02\u{f2}\u{5b6}\x03\x02\x02\x02\u{f4}\
	\u{5b8}\x03\x02\x02\x02\u{f6}\u{5bb}\x03\x02\x02\x02\u{f8}\u{5bf}\x03\x02\
	\x02\x02\u{fa}\u{5cb}\x03\x02\x02\x02\u{fc}\u{5d6}\x03\x02\x02\x02\u{fe}\
	\u{5e6}\x03\x02\x02\x02\u{100}\u{5fd}\x03\x02\x02\x02\u{102}\u{602}\x03\
	\x02\x02\x02\u{104}\u{616}\x03\x02\x02\x02\u{106}\u{61d}\x03\x02\x02\x02\
	\u{108}\u{626}\x03\x02\x02\x02\u{10a}\u{634}\x03\x02\x02\x02\u{10c}\u{647}\
	\x03\x02\x02\x02\u{10e}\u{64e}\x03\x02\x02\x02\u{110}\u{653}\x03\x02\x02\
	\x02\u{112}\u{657}\x03\x02\x02\x02\u{114}\u{659}\x03\x02\x02\x02\u{116}\
	\u{667}\x03\x02\x02\x02\u{118}\u{672}\x03\x02\x02\x02\u{11a}\u{674}\x03\
	\x02\x02\x02\u{11c}\u{692}\x03\x02\x02\x02\u{11e}\u{695}\x03\x02\x02\x02\
	\u{120}\u{699}\x03\x02\x02\x02\u{122}\u{69b}\x03\x02\x02\x02\u{124}\u{6a1}\
	\x03\x02\x02\x02\u{126}\u{6b5}\x03\x02\x02\x02\u{128}\u{6b7}\x03\x02\x02\
	\x02\u{12a}\u{6d3}\x03\x02\x02\x02\u{12c}\u{6d6}\x03\x02\x02\x02\u{12e}\
	\u{6da}\x03\x02\x02\x02\u{130}\u{6dc}\x03\x02\x02\x02\u{132}\u{6df}\x03\
	\x02\x02\x02\u{134}\u{6e2}\x03\x02\x02\x02\u{136}\u{6f1}\x03\x02\x02\x02\
	\u{138}\u{706}\x03\x02\x02\x02\u{13a}\u{708}\x03\x02\x02\x02\u{13c}\u{70a}\
	\x03\x02\x02\x02\u{13e}\u{70c}\x03\x02\x02\x02\u{140}\u{70f}\x03\x02\x02\
	\x02\u{142}\u{713}\x03\x02\x02\x02\u{144}\u{717}\x03\x02\x02\x02\u{146}\
	\u{71a}\x03\x02\x02\x02\u{148}\u{728}\x03\x02\x02\x02\u{14a}\u{733}\x03\
	\x02\x02\x02\u{14c}\u{735}\x03\x02\x02\x02\u{14e}\u{738}\x03\x02\x02\x02\
	\u{150}\u{73e}\x03\x02\x02\x02\u{152}\u{744}\x03\x02\x02\x02\u{154}\u{74e}\
	\x03\x02\x02\x02\u{156}\u{759}\x03\x02\x02\x02\u{158}\u{768}\x03\x02\x02\
	\x02\u{15a}\u{77a}\x03\x02\x02\x02\u{15c}\u{77c}\x03\x02\x02\x02\u{15e}\
	\u{77e}\x03\x02\x02\x02\u{160}\u{78f}\x03\x02\x02\x02\u{162}\u{791}\x03\
	\x02\x02\x02\u{164}\u{79b}\x03\x02\x02\x02\u{166}\u{7a0}\x03\x02\x02\x02\
	\u{168}\u{7a5}\x03\x02\x02\x02\u{16a}\u{7a9}\x03\x02\x02\x02\u{16c}\u{7b1}\
	\x03\x02\x02\x02\u{16e}\u{7b5}\x03\x02\x02\x02\u{170}\u{7c4}\x03\x02\x02\
	\x02\u{172}\u{7c6}\x03\x02\x02\x02\u{174}\u{7cc}\x03\x02\x02\x02\u{176}\
	\u{7ce}\x03\x02\x02\x02\u{178}\u{7d5}\x03\x02\x02\x02\u{17a}\u{7e9}\x03\
	\x02\x02\x02\u{17c}\u{81e}\x03\x02\x02\x02\u{17e}\u{820}\x03\x02\x02\x02\
	\u{180}\u{182}\x05\x7a\x3e\x02\u{181}\u{180}\x03\x02\x02\x02\u{181}\u{182}\
	\x03\x02\x02\x02\u{182}\u{183}\x03\x02\x02\x02\u{183}\u{184}\x07\x02\x02\
	\x03\u{184}\x03\x03\x02\x02\x02\u{185}\u{187}\x05\u{17e}\u{c0}\x02\u{186}\
	\u{185}\x03\x02\x02\x02\u{187}\u{188}\x03\x02\x02\x02\u{188}\u{186}\x03\
	\x02\x02\x02\u{188}\u{189}\x03\x02\x02\x02\u{189}\u{192}\x03\x02\x02\x02\
	\u{18a}\u{192}\x07\x47\x02\x02\u{18b}\u{18c}\x07\x57\x02\x02\u{18c}\u{18d}\
	\x05\x5c\x2f\x02\u{18d}\u{18e}\x07\x58\x02\x02\u{18e}\u{192}\x03\x02\x02\
	\x02\u{18f}\u{192}\x05\x06\x04\x02\u{190}\u{192}\x05\x0e\x08\x02\u{191}\
	\u{186}\x03\x02\x02\x02\u{191}\u{18a}\x03\x02\x02\x02\u{191}\u{18b}\x03\
	\x02\x02\x02\u{191}\u{18f}\x03\x02\x02\x02\u{191}\u{190}\x03\x02\x02\x02\
	\u{192}\x05\x03\x02\x02\x02\u{193}\u{196}\x05\x08\x05\x02\u{194}\u{196}\
	\x05\x0a\x06\x02\u{195}\u{193}\x03\x02\x02\x02\u{195}\u{194}\x03\x02\x02\
	\x02\u{196}\x07\x03\x02\x02\x02\u{197}\u{1a2}\x07\u{86}\x02\x02\u{198}\u{1a2}\
	\x05\u{14c}\u{a7}\x02\u{199}\u{1a2}\x05\u{13e}\u{a0}\x02\u{19a}\u{1a2}\x05\
	\u{14e}\u{a8}\x02\u{19b}\u{19e}\x07\x65\x02\x02\u{19c}\u{19f}\x05\u{118}\
	\u{8d}\x02\u{19d}\u{19f}\x05\u{a4}\x53\x02\u{19e}\u{19c}\x03\x02\x02\x02\
	\u{19e}\u{19d}\x03\x02\x02\x02\u{19f}\u{1a2}\x03\x02\x02\x02\u{1a0}\u{1a2}\
	\x05\u{15a}\u{ae}\x02\u{1a1}\u{197}\x03\x02\x02\x02\u{1a1}\u{198}\x03\x02\
	\x02\x02\u{1a1}\u{199}\x03\x02\x02\x02\u{1a1}\u{19a}\x03\x02\x02\x02\u{1a1}\
	\u{19b}\x03\x02\x02\x02\u{1a1}\u{1a0}\x03\x02\x02\x02\u{1a2}\x09\x03\x02\
	\x02\x02\u{1a3}\u{1a5}\x05\x0c\x07\x02\u{1a4}\u{1a6}\x07\x46\x02\x02\u{1a5}\
	\u{1a4}\x03\x02\x02\x02\u{1a5}\u{1a6}\x03\x02\x02\x02\u{1a6}\u{1a7}\x03\
	\x02\x02\x02\u{1a7}\u{1a8}\x05\x08\x05\x02\u{1a8}\x0b\x03\x02\x02\x02\u{1a9}\
	\u{1ad}\x08\x07\x01\x02\u{1aa}\u{1ae}\x05\u{a2}\x52\x02\u{1ab}\u{1ae}\x05\
	\u{ba}\x5e\x02\u{1ac}\u{1ae}\x05\u{a4}\x53\x02\u{1ad}\u{1aa}\x03\x02\x02\
	\x02\u{1ad}\u{1ab}\x03\x02\x02\x02\u{1ad}\u{1ac}\x03\x02\x02\x02\u{1ad}\
	\u{1ae}\x03\x02\x02\x02\u{1ae}\u{1af}\x03\x02\x02\x02\u{1af}\u{1b0}\x07\
	\u{81}\x02\x02\u{1b0}\u{1bc}\x03\x02\x02\x02\u{1b1}\u{1b7}\x0c\x03\x02\x02\
	\u{1b2}\u{1b8}\x07\u{86}\x02\x02\u{1b3}\u{1b5}\x07\x46\x02\x02\u{1b4}\u{1b3}\
	\x03\x02\x02\x02\u{1b4}\u{1b5}\x03\x02\x02\x02\u{1b5}\u{1b6}\x03\x02\x02\
	\x02\u{1b6}\u{1b8}\x05\u{158}\u{ad}\x02\u{1b7}\u{1b2}\x03\x02\x02\x02\u{1b7}\
	\u{1b4}\x03\x02\x02\x02\u{1b8}\u{1b9}\x03\x02\x02\x02\u{1b9}\u{1bb}\x07\
	\u{81}\x02\x02\u{1ba}\u{1b1}\x03\x02\x02\x02\u{1bb}\u{1be}\x03\x02\x02\x02\
	\u{1bc}\u{1ba}\x03\x02\x02\x02\u{1bc}\u{1bd}\x03\x02\x02\x02\u{1bd}\x0d\
	\x03\x02\x02\x02\u{1be}\u{1bc}\x03\x02\x02\x02\u{1bf}\u{1c1}\x05\x10\x09\
	\x02\u{1c0}\u{1c2}\x05\x1e\x10\x02\u{1c1}\u{1c0}\x03\x02\x02\x02\u{1c1}\
	\u{1c2}\x03\x02\x02\x02\u{1c2}\u{1c3}\x03\x02\x02\x02\u{1c3}\u{1c4}\x05\
	\x66\x34\x02\u{1c4}\x0f\x03\x02\x02\x02\u{1c5}\u{1c7}\x07\x59\x02\x02\u{1c6}\
	\u{1c8}\x05\x12\x0a\x02\u{1c7}\u{1c6}\x03\x02\x02\x02\u{1c7}\u{1c8}\x03\
	\x02\x02\x02\u{1c8}\u{1c9}\x03\x02\x02\x02\u{1c9}\u{1ca}\x07\x5a\x02\x02\
	\u{1ca}\x11\x03\x02\x02\x02\u{1cb}\u{1d2}\x05\x16\x0c\x02\u{1cc}\u{1cf}\
	\x05\x14\x0b\x02\u{1cd}\u{1ce}\x07\x7c\x02\x02\u{1ce}\u{1d0}\x05\x16\x0c\
	\x02\u{1cf}\u{1cd}\x03\x02\x02\x02\u{1cf}\u{1d0}\x03\x02\x02\x02\u{1d0}\
	\u{1d2}\x03\x02\x02\x02\u{1d1}\u{1cb}\x03\x02\x02\x02\u{1d1}\u{1cc}\x03\
	\x02\x02\x02\u{1d2}\x13\x03\x02\x02\x02\u{1d3}\u{1d4}\x09\x02\x02\x02\u{1d4}\
	\x15\x03\x02\x02\x02\u{1d5}\u{1da}\x05\x18\x0d\x02\u{1d6}\u{1d7}\x07\x7c\
	\x02\x02\u{1d7}\u{1d9}\x05\x18\x0d\x02\u{1d8}\u{1d6}\x03\x02\x02\x02\u{1d9}\
	\u{1dc}\x03\x02\x02\x02\u{1da}\u{1d8}\x03\x02\x02\x02\u{1da}\u{1db}\x03\
	\x02\x02\x02\u{1db}\u{1de}\x03\x02\x02\x02\u{1dc}\u{1da}\x03\x02\x02\x02\
	\u{1dd}\u{1df}\x07\u{85}\x02\x02\u{1de}\u{1dd}\x03\x02\x02\x02\u{1de}\u{1df}\
	\x03\x02\x02\x02\u{1df}\x17\x03\x02\x02\x02\u{1e0}\u{1e3}\x05\x1a\x0e\x02\
	\u{1e1}\u{1e3}\x05\x1c\x0f\x02\u{1e2}\u{1e0}\x03\x02\x02\x02\u{1e2}\u{1e1}\
	\x03\x02\x02\x02\u{1e3}\x19\x03\x02\x02\x02\u{1e4}\u{1e6}\x07\x63\x02\x02\
	\u{1e5}\u{1e4}\x03\x02\x02\x02\u{1e5}\u{1e6}\x03\x02\x02\x02\u{1e6}\u{1e7}\
	\x03\x02\x02\x02\u{1e7}\u{1ea}\x07\u{86}\x02\x02\u{1e8}\u{1ea}\x07\x47\x02\
	\x02\u{1e9}\u{1e5}\x03\x02\x02\x02\u{1e9}\u{1e8}\x03\x02\x02\x02\u{1ea}\
	\x1b\x03\x02\x02\x02\u{1eb}\u{1ed}\x07\x63\x02\x02\u{1ec}\u{1eb}\x03\x02\
	\x02\x02\u{1ec}\u{1ed}\x03\x02\x02\x02\u{1ed}\u{1ee}\x03\x02\x02\x02\u{1ee}\
	\u{1ef}\x07\u{86}\x02\x02\u{1ef}\u{1f0}\x05\u{10e}\u{88}\x02\u{1f0}\x1d\
	\x03\x02\x02\x02\u{1f1}\u{1f3}\x07\x57\x02\x02\u{1f2}\u{1f4}\x05\u{104}\
	\u{83}\x02\u{1f3}\u{1f2}\x03\x02\x02\x02\u{1f3}\u{1f4}\x03\x02\x02\x02\u{1f4}\
	\u{1f5}\x03\x02\x02\x02\u{1f5}\u{1f7}\x07\x58\x02\x02\u{1f6}\u{1f8}\x07\
	\x31\x02\x02\u{1f7}\u{1f6}\x03\x02\x02\x02\u{1f7}\u{1f8}\x03\x02\x02\x02\
	\u{1f8}\u{1fa}\x03\x02\x02\x02\u{1f9}\u{1fb}\x05\u{174}\u{bb}\x02\u{1fa}\
	\u{1f9}\x03\x02\x02\x02\u{1fa}\u{1fb}\x03\x02\x02\x02\u{1fb}\u{1fd}\x03\
	\x02\x02\x02\u{1fc}\u{1fe}\x05\u{ce}\x68\x02\u{1fd}\u{1fc}\x03\x02\x02\x02\
	\u{1fd}\u{1fe}\x03\x02\x02\x02\u{1fe}\u{200}\x03\x02\x02\x02\u{1ff}\u{201}\
	\x05\u{ec}\x77\x02\u{200}\u{1ff}\x03\x02\x02\x02\u{200}\u{201}\x03\x02\x02\
	\x02\u{201}\x1f\x03\x02\x02\x02\u{202}\u{203}\x08\x11\x01\x02\u{203}\u{221}\
	\x05\x04\x03\x02\u{204}\u{207}\x05\u{a0}\x51\x02\u{205}\u{207}\x05\u{162}\
	\u{b2}\x02\u{206}\u{204}\x03\x02\x02\x02\u{206}\u{205}\x03\x02\x02\x02\u{207}\
	\u{20e}\x03\x02\x02\x02\u{208}\u{20a}\x07\x57\x02\x02\u{209}\u{20b}\x05\
	\x24\x13\x02\u{20a}\u{209}\x03\x02\x02\x02\u{20a}\u{20b}\x03\x02\x02\x02\
	\u{20b}\u{20c}\x03\x02\x02\x02\u{20c}\u{20f}\x07\x58\x02\x02\u{20d}\u{20f}\
	\x05\u{116}\u{8c}\x02\u{20e}\u{208}\x03\x02\x02\x02\u{20e}\u{20d}\x03\x02\
	\x02\x02\u{20f}\u{221}\x03\x02\x02\x02\u{210}\u{211}\x09\x03\x02\x02\u{211}\
	\u{212}\x07\x68\x02\x02\u{212}\u{213}\x05\u{f8}\x7d\x02\u{213}\u{214}\x07\
	\x69\x02\x02\u{214}\u{215}\x07\x57\x02\x02\u{215}\u{216}\x05\x5c\x2f\x02\
	\u{216}\u{217}\x07\x58\x02\x02\u{217}\u{221}\x03\x02\x02\x02\u{218}\u{219}\
	\x05\x22\x12\x02\u{219}\u{21c}\x07\x57\x02\x02\u{21a}\u{21d}\x05\x5c\x2f\
	\x02\u{21b}\u{21d}\x05\u{f8}\x7d\x02\u{21c}\u{21a}\x03\x02\x02\x02\u{21c}\
	\u{21b}\x03\x02\x02\x02\u{21d}\u{21e}\x03\x02\x02\x02\u{21e}\u{21f}\x07\
	\x58\x02\x02\u{21f}\u{221}\x03\x02\x02\x02\u{220}\u{202}\x03\x02\x02\x02\
	\u{220}\u{206}\x03\x02\x02\x02\u{220}\u{210}\x03\x02\x02\x02\u{220}\u{218}\
	\x03\x02\x02\x02\u{221}\u{23d}\x03\x02\x02\x02\u{222}\u{223}\x0c\x09\x02\
	\x02\u{223}\u{226}\x07\x59\x02\x02\u{224}\u{227}\x05\x5c\x2f\x02\u{225}\
	\u{227}\x05\u{116}\u{8c}\x02\u{226}\u{224}\x03\x02\x02\x02\u{226}\u{225}\
	\x03\x02\x02\x02\u{227}\u{228}\x03\x02\x02\x02\u{228}\u{229}\x07\x5a\x02\
	\x02\u{229}\u{23c}\x03\x02\x02\x02\u{22a}\u{22b}\x0c\x08\x02\x02\u{22b}\
	\u{22d}\x07\x57\x02\x02\u{22c}\u{22e}\x05\x24\x13\x02\u{22d}\u{22c}\x03\
	\x02\x02\x02\u{22d}\u{22e}\x03\x02\x02\x02\u{22e}\u{22f}\x03\x02\x02\x02\
	\u{22f}\u{23c}\x07\x58\x02\x02\u{230}\u{231}\x0c\x06\x02\x02\u{231}\u{237}\
	\x09\x04\x02\x02\u{232}\u{234}\x07\x46\x02\x02\u{233}\u{232}\x03\x02\x02\
	\x02\u{233}\u{234}\x03\x02\x02\x02\u{234}\u{235}\x03\x02\x02\x02\u{235}\
	\u{238}\x05\x06\x04\x02\u{236}\u{238}\x05\x26\x14\x02\u{237}\u{233}\x03\
	\x02\x02\x02\u{237}\u{236}\x03\x02\x02\x02\u{238}\u{23c}\x03\x02\x02\x02\
	\u{239}\u{23a}\x0c\x05\x02\x02\u{23a}\u{23c}\x09\x05\x02\x02\u{23b}\u{222}\
	\x03\x02\x02\x02\u{23b}\u{22a}\x03\x02\x02\x02\u{23b}\u{230}\x03\x02\x02\
	\x02\u{23b}\u{239}\x03\x02\x02\x02\u{23c}\u{23f}\x03\x02\x02\x02\u{23d}\
	\u{23b}\x03\x02\x02\x02\u{23d}\u{23e}\x03\x02\x02\x02\u{23e}\x21\x03\x02\
	\x02\x02\u{23f}\u{23d}\x03\x02\x02\x02\u{240}\u{241}\x07\x4d\x02\x02\u{241}\
	\x23\x03\x02\x02\x02\u{242}\u{243}\x05\u{114}\u{8b}\x02\u{243}\x25\x03\x02\
	\x02\x02\u{244}\u{246}\x05\x0c\x07\x02\u{245}\u{244}\x03\x02\x02\x02\u{245}\
	\u{246}\x03\x02\x02\x02\u{246}\u{24a}\x03\x02\x02\x02\u{247}\u{248}\x05\
	\u{a2}\x52\x02\u{248}\u{249}\x07\u{81}\x02\x02\u{249}\u{24b}\x03\x02\x02\
	\x02\u{24a}\u{247}\x03\x02\x02\x02\u{24a}\u{24b}\x03\x02\x02\x02\u{24b}\
	\u{24c}\x03\x02\x02\x02\u{24c}\u{24d}\x07\x65\x02\x02\u{24d}\u{258}\x05\
	\u{a2}\x52\x02\u{24e}\u{24f}\x05\x0c\x07\x02\u{24f}\u{250}\x07\x46\x02\x02\
	\u{250}\u{251}\x05\u{158}\u{ad}\x02\u{251}\u{252}\x07\u{81}\x02\x02\u{252}\
	\u{253}\x07\x65\x02\x02\u{253}\u{254}\x05\u{a2}\x52\x02\u{254}\u{258}\x03\
	\x02\x02\x02\u{255}\u{256}\x07\x65\x02\x02\u{256}\u{258}\x05\u{a4}\x53\x02\
	\u{257}\u{245}\x03\x02\x02\x02\u{257}\u{24e}\x03\x02\x02\x02\u{257}\u{255}\
	\x03\x02\x02\x02\u{258}\x27\x03\x02\x02\x02\u{259}\u{275}\x05\x20\x11\x02\
	\u{25a}\u{25f}\x07\x7a\x02\x02\u{25b}\u{25f}\x07\x7b\x02\x02\u{25c}\u{25f}\
	\x05\x2a\x16\x02\u{25d}\u{25f}\x07\x40\x02\x02\u{25e}\u{25a}\x03\x02\x02\
	\x02\u{25e}\u{25b}\x03\x02\x02\x02\u{25e}\u{25c}\x03\x02\x02\x02\u{25e}\
	\u{25d}\x03\x02\x02\x02\u{25f}\u{260}\x03\x02\x02\x02\u{260}\u{275}\x05\
	\x28\x15\x02\u{261}\u{26a}\x07\x40\x02\x02\u{262}\u{263}\x07\x57\x02\x02\
	\u{263}\u{264}\x05\u{f8}\x7d\x02\u{264}\u{265}\x07\x58\x02\x02\u{265}\u{26b}\
	\x03\x02\x02\x02\u{266}\u{267}\x07\u{85}\x02\x02\u{267}\u{268}\x07\x57\x02\
	\x02\u{268}\u{269}\x07\u{86}\x02\x02\u{269}\u{26b}\x07\x58\x02\x02\u{26a}\
	\u{262}\x03\x02\x02\x02\u{26a}\u{266}\x03\x02\x02\x02\u{26b}\u{275}\x03\
	\x02\x02\x02\u{26c}\u{26d}\x07\x0d\x02\x02\u{26d}\u{26e}\x07\x57\x02\x02\
	\u{26e}\u{26f}\x05\u{f8}\x7d\x02\u{26f}\u{270}\x07\x58\x02\x02\u{270}\u{275}\
	\x03\x02\x02\x02\u{271}\u{275}\x05\x3a\x1e\x02\u{272}\u{275}\x05\x2c\x17\
	\x02\u{273}\u{275}\x05\x38\x1d\x02\u{274}\u{259}\x03\x02\x02\x02\u{274}\
	\u{25e}\x03\x02\x02\x02\u{274}\u{261}\x03\x02\x02\x02\u{274}\u{26c}\x03\
	\x02\x02\x02\u{274}\u{271}\x03\x02\x02\x02\u{274}\u{272}\x03\x02\x02\x02\
	\u{274}\u{273}\x03\x02\x02\x02\u{275}\x29\x03\x02\x02\x02\u{276}\u{277}\
	\x09\x06\x02\x02\u{277}\x2b\x03\x02\x02\x02\u{278}\u{27a}\x07\u{81}\x02\
	\x02\u{279}\u{278}\x03\x02\x02\x02\u{279}\u{27a}\x03\x02\x02\x02\u{27a}\
	\u{27b}\x03\x02\x02\x02\u{27b}\u{27d}\x07\x33\x02\x02\u{27c}\u{27e}\x05\
	\x2e\x18\x02\u{27d}\u{27c}\x03\x02\x02\x02\u{27d}\u{27e}\x03\x02\x02\x02\
	\u{27e}\u{284}\x03\x02\x02\x02\u{27f}\u{285}\x05\x30\x19\x02\u{280}\u{281}\
	\x07\x57\x02\x02\u{281}\u{282}\x05\u{f8}\x7d\x02\u{282}\u{283}\x07\x58\x02\
	\x02\u{283}\u{285}\x03\x02\x02\x02\u{284}\u{27f}\x03\x02\x02\x02\u{284}\
	\u{280}\x03\x02\x02\x02\u{285}\u{287}\x03\x02\x02\x02\u{286}\u{288}\x05\
	\x36\x1c\x02\u{287}\u{286}\x03\x02\x02\x02\u{287}\u{288}\x03\x02\x02\x02\
	\u{288}\x2d\x03\x02\x02\x02\u{289}\u{28a}\x07\x57\x02\x02\u{28a}\u{28b}\
	\x05\x24\x13\x02\u{28b}\u{28c}\x07\x58\x02\x02\u{28c}\x2f\x03\x02\x02\x02\
	\u{28d}\u{28f}\x05\u{98}\x4d\x02\u{28e}\u{290}\x05\x32\x1a\x02\u{28f}\u{28e}\
	\x03\x02\x02\x02\u{28f}\u{290}\x03\x02\x02\x02\u{290}\x31\x03\x02\x02\x02\
	\u{291}\u{293}\x05\u{ee}\x78\x02\u{292}\u{294}\x05\x32\x1a\x02\u{293}\u{292}\
	\x03\x02\x02\x02\u{293}\u{294}\x03\x02\x02\x02\u{294}\u{297}\x03\x02\x02\
	\x02\u{295}\u{297}\x05\x34\x1b\x02\u{296}\u{291}\x03\x02\x02\x02\u{296}\
	\u{295}\x03\x02\x02\x02\u{297}\x33\x03\x02\x02\x02\u{298}\u{299}\x08\x1b\
	\x01\x02\u{299}\u{29a}\x07\x59\x02\x02\u{29a}\u{29b}\x05\x5c\x2f\x02\u{29b}\
	\u{29d}\x07\x5a\x02\x02\u{29c}\u{29e}\x05\u{ce}\x68\x02\u{29d}\u{29c}\x03\
	\x02\x02\x02\u{29d}\u{29e}\x03\x02\x02\x02\u{29e}\u{2a8}\x03\x02\x02\x02\
	\u{29f}\u{2a0}\x0c\x03\x02\x02\u{2a0}\u{2a1}\x07\x59\x02\x02\u{2a1}\u{2a2}\
	\x05\x5e\x30\x02\u{2a2}\u{2a4}\x07\x5a\x02\x02\u{2a3}\u{2a5}\x05\u{ce}\x68\
	\x02\u{2a4}\u{2a3}\x03\x02\x02\x02\u{2a4}\u{2a5}\x03\x02\x02\x02\u{2a5}\
	\u{2a7}\x03\x02\x02\x02\u{2a6}\u{29f}\x03\x02\x02\x02\u{2a7}\u{2aa}\x03\
	\x02\x02\x02\u{2a8}\u{2a6}\x03\x02\x02\x02\u{2a8}\u{2a9}\x03\x02\x02\x02\
	\u{2a9}\x35\x03\x02\x02\x02\u{2aa}\u{2a8}\x03\x02\x02\x02\u{2ab}\u{2ad}\
	\x07\x57\x02\x02\u{2ac}\u{2ae}\x05\x24\x13\x02\u{2ad}\u{2ac}\x03\x02\x02\
	\x02\u{2ad}\u{2ae}\x03\x02\x02\x02\u{2ae}\u{2af}\x03\x02\x02\x02\u{2af}\
	\u{2b2}\x07\x58\x02\x02\u{2b0}\u{2b2}\x05\u{116}\u{8c}\x02\u{2b1}\u{2ab}\
	\x03\x02\x02\x02\u{2b1}\u{2b0}\x03\x02\x02\x02\u{2b2}\x37\x03\x02\x02\x02\
	\u{2b3}\u{2b5}\x07\u{81}\x02\x02\u{2b4}\u{2b3}\x03\x02\x02\x02\u{2b4}\u{2b5}\
	\x03\x02\x02\x02\u{2b5}\u{2b6}\x03\x02\x02\x02\u{2b6}\u{2b9}\x07\x1e\x02\
	\x02\u{2b7}\u{2b8}\x07\x59\x02\x02\u{2b8}\u{2ba}\x07\x5a\x02\x02\u{2b9}\
	\u{2b7}\x03\x02\x02\x02\u{2b9}\u{2ba}\x03\x02\x02\x02\u{2ba}\u{2bb}\x03\
	\x02\x02\x02\u{2bb}\u{2bc}\x05\x3c\x1f\x02\u{2bc}\x39\x03\x02\x02\x02\u{2bd}\
	\u{2be}\x07\x34\x02\x02\u{2be}\u{2bf}\x07\x57\x02\x02\u{2bf}\u{2c0}\x05\
	\x5c\x2f\x02\u{2c0}\u{2c1}\x07\x58\x02\x02\u{2c1}\x3b\x03\x02\x02\x02\u{2c2}\
	\u{2c9}\x05\x28\x15\x02\u{2c3}\u{2c4}\x07\x57\x02\x02\u{2c4}\u{2c5}\x05\
	\u{f8}\x7d\x02\u{2c5}\u{2c6}\x07\x58\x02\x02\u{2c6}\u{2c7}\x05\x3c\x1f\x02\
	\u{2c7}\u{2c9}\x03\x02\x02\x02\u{2c8}\u{2c2}\x03\x02\x02\x02\u{2c8}\u{2c3}\
	\x03\x02\x02\x02\u{2c9}\x3d\x03\x02\x02\x02\u{2ca}\u{2cf}\x05\x3c\x1f\x02\
	\u{2cb}\u{2cc}\x09\x07\x02\x02\u{2cc}\u{2ce}\x05\x3c\x1f\x02\u{2cd}\u{2cb}\
	\x03\x02\x02\x02\u{2ce}\u{2d1}\x03\x02\x02\x02\u{2cf}\u{2cd}\x03\x02\x02\
	\x02\u{2cf}\u{2d0}\x03\x02\x02\x02\u{2d0}\x3f\x03\x02\x02\x02\u{2d1}\u{2cf}\
	\x03\x02\x02\x02\u{2d2}\u{2d7}\x05\x3e\x20\x02\u{2d3}\u{2d4}\x09\x08\x02\
	\x02\u{2d4}\u{2d6}\x05\x3e\x20\x02\u{2d5}\u{2d3}\x03\x02\x02\x02\u{2d6}\
	\u{2d9}\x03\x02\x02\x02\u{2d7}\u{2d5}\x03\x02\x02\x02\u{2d7}\u{2d8}\x03\
	\x02\x02\x02\u{2d8}\x41\x03\x02\x02\x02\u{2d9}\u{2d7}\x03\x02\x02\x02\u{2da}\
	\u{2df}\x05\x40\x21\x02\u{2db}\u{2dc}\x09\x09\x02\x02\u{2dc}\u{2de}\x05\
	\x40\x21\x02\u{2dd}\u{2db}\x03\x02\x02\x02\u{2de}\u{2e1}\x03\x02\x02\x02\
	\u{2df}\u{2dd}\x03\x02\x02\x02\u{2df}\u{2e0}\x03\x02\x02\x02\u{2e0}\x43\
	\x03\x02\x02\x02\u{2e1}\u{2df}\x03\x02\x02\x02\u{2e2}\u{2e8}\x05\x42\x22\
	\x02\u{2e3}\u{2e4}\x05\x46\x24\x02\u{2e4}\u{2e5}\x05\x42\x22\x02\u{2e5}\
	\u{2e7}\x03\x02\x02\x02\u{2e6}\u{2e3}\x03\x02\x02\x02\u{2e7}\u{2ea}\x03\
	\x02\x02\x02\u{2e8}\u{2e6}\x03\x02\x02\x02\u{2e8}\u{2e9}\x03\x02\x02\x02\
	\u{2e9}\x45\x03\x02\x02\x02\u{2ea}\u{2e8}\x03\x02\x02\x02\u{2eb}\u{2ec}\
	\x07\x69\x02\x02\u{2ec}\u{2f0}\x07\x69\x02\x02\u{2ed}\u{2ee}\x07\x68\x02\
	\x02\u{2ee}\u{2f0}\x07\x68\x02\x02\u{2ef}\u{2eb}\x03\x02\x02\x02\u{2ef}\
	\u{2ed}\x03\x02\x02\x02\u{2f0}\x47\x03\x02\x02\x02\u{2f1}\u{2f6}\x05\x44\
	\x23\x02\u{2f2}\u{2f3}\x09\x0a\x02\x02\u{2f3}\u{2f5}\x05\x44\x23\x02\u{2f4}\
	\u{2f2}\x03\x02\x02\x02\u{2f5}\u{2f8}\x03\x02\x02\x02\u{2f6}\u{2f4}\x03\
	\x02\x02\x02\u{2f6}\u{2f7}\x03\x02\x02\x02\u{2f7}\x49\x03\x02\x02\x02\u{2f8}\
	\u{2f6}\x03\x02\x02\x02\u{2f9}\u{2fe}\x05\x48\x25\x02\u{2fa}\u{2fb}\x09\
	\x0b\x02\x02\u{2fb}\u{2fd}\x05\x48\x25\x02\u{2fc}\u{2fa}\x03\x02\x02\x02\
	\u{2fd}\u{300}\x03\x02\x02\x02\u{2fe}\u{2fc}\x03\x02\x02\x02\u{2fe}\u{2ff}\
	\x03\x02\x02\x02\u{2ff}\x4b\x03\x02\x02\x02\u{300}\u{2fe}\x03\x02\x02\x02\
	\u{301}\u{306}\x05\x4a\x26\x02\u{302}\u{303}\x07\x63\x02\x02\u{303}\u{305}\
	\x05\x4a\x26\x02\u{304}\u{302}\x03\x02\x02\x02\u{305}\u{308}\x03\x02\x02\
	\x02\u{306}\u{304}\x03\x02\x02\x02\u{306}\u{307}\x03\x02\x02\x02\u{307}\
	\x4d\x03\x02\x02\x02\u{308}\u{306}\x03\x02\x02\x02\u{309}\u{30e}\x05\x4c\
	\x27\x02\u{30a}\u{30b}\x07\x62\x02\x02\u{30b}\u{30d}\x05\x4c\x27\x02\u{30c}\
	\u{30a}\x03\x02\x02\x02\u{30d}\u{310}\x03\x02\x02\x02\u{30e}\u{30c}\x03\
	\x02\x02\x02\u{30e}\u{30f}\x03\x02\x02\x02\u{30f}\x4f\x03\x02\x02\x02\u{310}\
	\u{30e}\x03\x02\x02\x02\u{311}\u{316}\x05\x4e\x28\x02\u{312}\u{313}\x07\
	\x64\x02\x02\u{313}\u{315}\x05\x4e\x28\x02\u{314}\u{312}\x03\x02\x02\x02\
	\u{315}\u{318}\x03\x02\x02\x02\u{316}\u{314}\x03\x02\x02\x02\u{316}\u{317}\
	\x03\x02\x02\x02\u{317}\x51\x03\x02\x02\x02\u{318}\u{316}\x03\x02\x02\x02\
	\u{319}\u{31e}\x05\x50\x29\x02\u{31a}\u{31b}\x07\x78\x02\x02\u{31b}\u{31d}\
	\x05\x50\x29\x02\u{31c}\u{31a}\x03\x02\x02\x02\u{31d}\u{320}\x03\x02\x02\
	\x02\u{31e}\u{31c}\x03\x02\x02\x02\u{31e}\u{31f}\x03\x02\x02\x02\u{31f}\
	\x53\x03\x02\x02\x02\u{320}\u{31e}\x03\x02\x02\x02\u{321}\u{326}\x05\x52\
	\x2a\x02\u{322}\u{323}\x07\x79\x02\x02\u{323}\u{325}\x05\x52\x2a\x02\u{324}\
	\u{322}\x03\x02\x02\x02\u{325}\u{328}\x03\x02\x02\x02\u{326}\u{324}\x03\
	\x02\x02\x02\u{326}\u{327}\x03\x02\x02\x02\u{327}\x55\x03\x02\x02\x02\u{328}\
	\u{326}\x03\x02\x02\x02\u{329}\u{32f}\x05\x54\x2b\x02\u{32a}\u{32b}\x07\
	\x7f\x02\x02\u{32b}\u{32c}\x05\x5c\x2f\x02\u{32c}\u{32d}\x07\u{80}\x02\x02\
	\u{32d}\u{32e}\x05\x58\x2d\x02\u{32e}\u{330}\x03\x02\x02\x02\u{32f}\u{32a}\
	\x03\x02\x02\x02\u{32f}\u{330}\x03\x02\x02\x02\u{330}\x57\x03\x02\x02\x02\
	\u{331}\u{338}\x05\x56\x2c\x02\u{332}\u{333}\x05\x54\x2b\x02\u{333}\u{334}\
	\x05\x5a\x2e\x02\u{334}\u{335}\x05\u{112}\u{8a}\x02\u{335}\u{338}\x03\x02\
	\x02\x02\u{336}\u{338}\x05\u{172}\u{ba}\x02\u{337}\u{331}\x03\x02\x02\x02\
	\u{337}\u{332}\x03\x02\x02\x02\u{337}\u{336}\x03\x02\x02\x02\u{338}\x59\
	\x03\x02\x02\x02\u{339}\u{33a}\x09\x0c\x02\x02\u{33a}\x5b\x03\x02\x02\x02\
	\u{33b}\u{340}\x05\x58\x2d\x02\u{33c}\u{33d}\x07\x7c\x02\x02\u{33d}\u{33f}\
	\x05\x58\x2d\x02\u{33e}\u{33c}\x03\x02\x02\x02\u{33f}\u{342}\x03\x02\x02\
	\x02\u{340}\u{33e}\x03\x02\x02\x02\u{340}\u{341}\x03\x02\x02\x02\u{341}\
	\x5d\x03\x02\x02\x02\u{342}\u{340}\x03\x02\x02\x02\u{343}\u{344}\x05\x56\
	\x2c\x02\u{344}\x5f\x03\x02\x02\x02\u{345}\u{353}\x05\x62\x32\x02\u{346}\
	\u{353}\x05\x78\x3d\x02\u{347}\u{349}\x05\u{ce}\x68\x02\u{348}\u{347}\x03\
	\x02\x02\x02\u{348}\u{349}\x03\x02\x02\x02\u{349}\u{350}\x03\x02\x02\x02\
	\u{34a}\u{351}\x05\x64\x33\x02\u{34b}\u{351}\x05\x66\x34\x02\u{34c}\u{351}\
	\x05\x6a\x36\x02\u{34d}\u{351}\x05\x6e\x38\x02\u{34e}\u{351}\x05\x76\x3c\
	\x02\u{34f}\u{351}\x05\u{168}\u{b5}\x02\u{350}\u{34a}\x03\x02\x02\x02\u{350}\
	\u{34b}\x03\x02\x02\x02\u{350}\u{34c}\x03\x02\x02\x02\u{350}\u{34d}\x03\
	\x02\x02\x02\u{350}\u{34e}\x03\x02\x02\x02\u{350}\u{34f}\x03\x02\x02\x02\
	\u{351}\u{353}\x03\x02\x02\x02\u{352}\u{345}\x03\x02\x02\x02\u{352}\u{346}\
	\x03\x02\x02\x02\u{352}\u{348}\x03\x02\x02\x02\u{353}\x61\x03\x02\x02\x02\
	\u{354}\u{356}\x05\u{ce}\x68\x02\u{355}\u{354}\x03\x02\x02\x02\u{355}\u{356}\
	\x03\x02\x02\x02\u{356}\u{35b}\x03\x02\x02\x02\u{357}\u{35c}\x07\u{86}\x02\
	\x02\u{358}\u{359}\x07\x12\x02\x02\u{359}\u{35c}\x05\x5e\x30\x02\u{35a}\
	\u{35c}\x07\x1d\x02\x02\u{35b}\u{357}\x03\x02\x02\x02\u{35b}\u{358}\x03\
	\x02\x02\x02\u{35b}\u{35a}\x03\x02\x02\x02\u{35c}\u{35d}\x03\x02\x02\x02\
	\u{35d}\u{35e}\x07\u{80}\x02\x02\u{35e}\u{35f}\x05\x60\x31\x02\u{35f}\x63\
	\x03\x02\x02\x02\u{360}\u{362}\x05\x5c\x2f\x02\u{361}\u{360}\x03\x02\x02\
	\x02\u{361}\u{362}\x03\x02\x02\x02\u{362}\u{363}\x03\x02\x02\x02\u{363}\
	\u{364}\x07\u{82}\x02\x02\u{364}\x65\x03\x02\x02\x02\u{365}\u{367}\x07\x5b\
	\x02\x02\u{366}\u{368}\x05\x68\x35\x02\u{367}\u{366}\x03\x02\x02\x02\u{367}\
	\u{368}\x03\x02\x02\x02\u{368}\u{369}\x03\x02\x02\x02\u{369}\u{36a}\x07\
	\x5c\x02\x02\u{36a}\x67\x03\x02\x02\x02\u{36b}\u{36d}\x05\x60\x31\x02\u{36c}\
	\u{36b}\x03\x02\x02\x02\u{36d}\u{36e}\x03\x02\x02\x02\u{36e}\u{36c}\x03\
	\x02\x02\x02\u{36e}\u{36f}\x03\x02\x02\x02\u{36f}\x69\x03\x02\x02\x02\u{370}\
	\u{371}\x07\x2d\x02\x02\u{371}\u{372}\x07\x57\x02\x02\u{372}\u{373}\x05\
	\x6c\x37\x02\u{373}\u{374}\x07\x58\x02\x02\u{374}\u{377}\x05\x60\x31\x02\
	\u{375}\u{376}\x07\x22\x02\x02\u{376}\u{378}\x05\x60\x31\x02\u{377}\u{375}\
	\x03\x02\x02\x02\u{377}\u{378}\x03\x02\x02\x02\u{378}\u{380}\x03\x02\x02\
	\x02\u{379}\u{37a}\x07\x45\x02\x02\u{37a}\u{37b}\x07\x57\x02\x02\u{37b}\
	\u{37c}\x05\x6c\x37\x02\u{37c}\u{37d}\x07\x58\x02\x02\u{37d}\u{37e}\x05\
	\x60\x31\x02\u{37e}\u{380}\x03\x02\x02\x02\u{37f}\u{370}\x03\x02\x02\x02\
	\u{37f}\u{379}\x03\x02\x02\x02\u{380}\x6b\x03\x02\x02\x02\u{381}\u{38d}\
	\x05\x5c\x2f\x02\u{382}\u{384}\x05\u{ce}\x68\x02\u{383}\u{382}\x03\x02\x02\
	\x02\u{383}\u{384}\x03\x02\x02\x02\u{384}\u{385}\x03\x02\x02\x02\u{385}\
	\u{386}\x05\u{8c}\x47\x02\u{386}\u{38a}\x05\u{e4}\x73\x02\u{387}\u{388}\
	\x07\x67\x02\x02\u{388}\u{38b}\x05\u{112}\u{8a}\x02\u{389}\u{38b}\x05\u{116}\
	\u{8c}\x02\u{38a}\u{387}\x03\x02\x02\x02\u{38a}\u{389}\x03\x02\x02\x02\u{38b}\
	\u{38d}\x03\x02\x02\x02\u{38c}\u{381}\x03\x02\x02\x02\u{38c}\u{383}\x03\
	\x02\x02\x02\u{38d}\x6d\x03\x02\x02\x02\u{38e}\u{38f}\x07\x56\x02\x02\u{38f}\
	\u{390}\x07\x57\x02\x02\u{390}\u{391}\x05\x6c\x37\x02\u{391}\u{392}\x07\
	\x58\x02\x02\u{392}\u{393}\x05\x60\x31\x02\u{393}\u{3b0}\x03\x02\x02\x02\
	\u{394}\u{395}\x07\x1f\x02\x02\u{395}\u{396}\x05\x60\x31\x02\u{396}\u{397}\
	\x07\x56\x02\x02\u{397}\u{398}\x07\x57\x02\x02\u{398}\u{399}\x05\x5c\x2f\
	\x02\u{399}\u{39a}\x07\x58\x02\x02\u{39a}\u{39b}\x07\u{82}\x02\x02\u{39b}\
	\u{3b0}\x03\x02\x02\x02\u{39c}\u{39d}\x07\x2a\x02\x02\u{39d}\u{3aa}\x07\
	\x57\x02\x02\u{39e}\u{3a0}\x05\x70\x39\x02\u{39f}\u{3a1}\x05\x6c\x37\x02\
	\u{3a0}\u{39f}\x03\x02\x02\x02\u{3a0}\u{3a1}\x03\x02\x02\x02\u{3a1}\u{3a2}\
	\x03\x02\x02\x02\u{3a2}\u{3a4}\x07\u{82}\x02\x02\u{3a3}\u{3a5}\x05\x5c\x2f\
	\x02\u{3a4}\u{3a3}\x03\x02\x02\x02\u{3a4}\u{3a5}\x03\x02\x02\x02\u{3a5}\
	\u{3ab}\x03\x02\x02\x02\u{3a6}\u{3a7}\x05\x72\x3a\x02\u{3a7}\u{3a8}\x07\
	\u{80}\x02\x02\u{3a8}\u{3a9}\x05\x74\x3b\x02\u{3a9}\u{3ab}\x03\x02\x02\x02\
	\u{3aa}\u{39e}\x03\x02\x02\x02\u{3aa}\u{3a6}\x03\x02\x02\x02\u{3ab}\u{3ac}\
	\x03\x02\x02\x02\u{3ac}\u{3ad}\x07\x58\x02\x02\u{3ad}\u{3ae}\x05\x60\x31\
	\x02\u{3ae}\u{3b0}\x03\x02\x02\x02\u{3af}\u{38e}\x03\x02\x02\x02\u{3af}\
	\u{394}\x03\x02\x02\x02\u{3af}\u{39c}\x03\x02\x02\x02\u{3b0}\x6f\x03\x02\
	\x02\x02\u{3b1}\u{3b4}\x05\x64\x33\x02\u{3b2}\u{3b4}\x05\u{82}\x42\x02\u{3b3}\
	\u{3b1}\x03\x02\x02\x02\u{3b3}\u{3b2}\x03\x02\x02\x02\u{3b4}\x71\x03\x02\
	\x02\x02\u{3b5}\u{3b7}\x05\u{ce}\x68\x02\u{3b6}\u{3b5}\x03\x02\x02\x02\u{3b6}\
	\u{3b7}\x03\x02\x02\x02\u{3b7}\u{3b8}\x03\x02\x02\x02\u{3b8}\u{3b9}\x05\
	\u{8c}\x47\x02\u{3b9}\u{3ba}\x05\u{e4}\x73\x02\u{3ba}\x73\x03\x02\x02\x02\
	\u{3bb}\u{3be}\x05\x5c\x2f\x02\u{3bc}\u{3be}\x05\u{116}\u{8c}\x02\u{3bd}\
	\u{3bb}\x03\x02\x02\x02\u{3bd}\u{3bc}\x03\x02\x02\x02\u{3be}\x75\x03\x02\
	\x02\x02\u{3bf}\u{3c9}\x07\x11\x02\x02\u{3c0}\u{3c9}\x07\x1b\x02\x02\u{3c1}\
	\u{3c4}\x07\x3d\x02\x02\u{3c2}\u{3c5}\x05\x5c\x2f\x02\u{3c3}\u{3c5}\x05\
	\u{116}\u{8c}\x02\u{3c4}\u{3c2}\x03\x02\x02\x02\u{3c4}\u{3c3}\x03\x02\x02\
	\x02\u{3c4}\u{3c5}\x03\x02\x02\x02\u{3c5}\u{3c9}\x03\x02\x02\x02\u{3c6}\
	\u{3c7}\x07\x2c\x02\x02\u{3c7}\u{3c9}\x07\u{86}\x02\x02\u{3c8}\u{3bf}\x03\
	\x02\x02\x02\u{3c8}\u{3c0}\x03\x02\x02\x02\u{3c8}\u{3c1}\x03\x02\x02\x02\
	\u{3c8}\u{3c6}\x03\x02\x02\x02\u{3c9}\u{3ca}\x03\x02\x02\x02\u{3ca}\u{3cb}\
	\x07\u{82}\x02\x02\u{3cb}\x77\x03\x02\x02\x02\u{3cc}\u{3cd}\x05\x7e\x40\
	\x02\u{3cd}\x79\x03\x02\x02\x02\u{3ce}\u{3d0}\x05\x7c\x3f\x02\u{3cf}\u{3ce}\
	\x03\x02\x02\x02\u{3d0}\u{3d1}\x03\x02\x02\x02\u{3d1}\u{3cf}\x03\x02\x02\
	\x02\u{3d1}\u{3d2}\x03\x02\x02\x02\u{3d2}\x7b\x03\x02\x02\x02\u{3d3}\u{3dd}\
	\x05\x7e\x40\x02\u{3d4}\u{3dd}\x05\u{10a}\u{86}\x02\u{3d5}\u{3dd}\x05\u{150}\
	\u{a9}\x02\u{3d6}\u{3dd}\x05\u{164}\u{b3}\x02\u{3d7}\u{3dd}\x05\u{166}\u{b4}\
	\x02\u{3d8}\u{3dd}\x05\u{cc}\x67\x02\u{3d9}\u{3dd}\x05\u{be}\x60\x02\u{3da}\
	\u{3dd}\x05\u{86}\x44\x02\u{3db}\u{3dd}\x05\u{88}\x45\x02\u{3dc}\u{3d3}\
	\x03\x02\x02\x02\u{3dc}\u{3d4}\x03\x02\x02\x02\u{3dc}\u{3d5}\x03\x02\x02\
	\x02\u{3dc}\u{3d6}\x03\x02\x02\x02\u{3dc}\u{3d7}\x03\x02\x02\x02\u{3dc}\
	\u{3d8}\x03\x02\x02\x02\u{3dc}\u{3d9}\x03\x02\x02\x02\u{3dc}\u{3da}\x03\
	\x02\x02\x02\u{3dc}\u{3db}\x03\x02\x02\x02\u{3dd}\x7d\x03\x02\x02\x02\u{3de}\
	\u{3e7}\x05\u{82}\x42\x02\u{3df}\u{3e7}\x05\u{ca}\x66\x02\u{3e0}\u{3e7}\
	\x05\u{c2}\x62\x02\u{3e1}\u{3e7}\x05\u{c6}\x64\x02\u{3e2}\u{3e7}\x05\u{c8}\
	\x65\x02\u{3e3}\u{3e7}\x05\u{84}\x43\x02\u{3e4}\u{3e7}\x05\u{80}\x41\x02\
	\u{3e5}\u{3e7}\x05\u{ae}\x58\x02\u{3e6}\u{3de}\x03\x02\x02\x02\u{3e6}\u{3df}\
	\x03\x02\x02\x02\u{3e6}\u{3e0}\x03\x02\x02\x02\u{3e6}\u{3e1}\x03\x02\x02\
	\x02\u{3e6}\u{3e2}\x03\x02\x02\x02\u{3e6}\u{3e3}\x03\x02\x02\x02\u{3e6}\
	\u{3e4}\x03\x02\x02\x02\u{3e6}\u{3e5}\x03\x02\x02\x02\u{3e7}\x7f\x03\x02\
	\x02\x02\u{3e8}\u{3e9}\x07\x51\x02\x02\u{3e9}\u{3eb}\x07\u{86}\x02\x02\u{3ea}\
	\u{3ec}\x05\u{ce}\x68\x02\u{3eb}\u{3ea}\x03\x02\x02\x02\u{3eb}\u{3ec}\x03\
	\x02\x02\x02\u{3ec}\u{3ed}\x03\x02\x02\x02\u{3ed}\u{3ee}\x07\x67\x02\x02\
	\u{3ee}\u{3ef}\x05\u{f8}\x7d\x02\u{3ef}\u{3f0}\x07\u{82}\x02\x02\u{3f0}\
	\u{81}\x03\x02\x02\x02\u{3f1}\u{3f3}\x05\u{8c}\x47\x02\u{3f2}\u{3f1}\x03\
	\x02\x02\x02\u{3f2}\u{3f3}\x03\x02\x02\x02\u{3f3}\u{3f5}\x03\x02\x02\x02\
	\u{3f4}\u{3f6}\x05\u{e0}\x71\x02\u{3f5}\u{3f4}\x03\x02\x02\x02\u{3f5}\u{3f6}\
	\x03\x02\x02\x02\u{3f6}\u{3f7}\x03\x02\x02\x02\u{3f7}\u{400}\x07\u{82}\x02\
	\x02\u{3f8}\u{3fa}\x05\u{ce}\x68\x02\u{3f9}\u{3fb}\x05\u{8c}\x47\x02\u{3fa}\
	\u{3f9}\x03\x02\x02\x02\u{3fa}\u{3fb}\x03\x02\x02\x02\u{3fb}\u{3fc}\x03\
	\x02\x02\x02\u{3fc}\u{3fd}\x05\u{e0}\x71\x02\u{3fd}\u{3fe}\x07\u{82}\x02\
	\x02\u{3fe}\u{400}\x03\x02\x02\x02\u{3ff}\u{3f2}\x03\x02\x02\x02\u{3ff}\
	\u{3f8}\x03\x02\x02\x02\u{400}\u{83}\x03\x02\x02\x02\u{401}\u{402}\x07\x42\
	\x02\x02\u{402}\u{403}\x07\x57\x02\x02\u{403}\u{404}\x05\x5e\x30\x02\u{404}\
	\u{405}\x07\x7c\x02\x02\u{405}\u{406}\x07\x06\x02\x02\u{406}\u{407}\x07\
	\x58\x02\x02\u{407}\u{408}\x07\u{82}\x02\x02\u{408}\u{85}\x03\x02\x02\x02\
	\u{409}\u{40a}\x07\u{82}\x02\x02\u{40a}\u{87}\x03\x02\x02\x02\u{40b}\u{40c}\
	\x05\u{ce}\x68\x02\u{40c}\u{40d}\x07\u{82}\x02\x02\u{40d}\u{89}\x03\x02\
	\x02\x02\u{40e}\u{415}\x05\u{8e}\x48\x02\u{40f}\u{415}\x05\u{94}\x4b\x02\
	\u{410}\u{415}\x05\u{90}\x49\x02\u{411}\u{415}\x07\x2b\x02\x02\u{412}\u{415}\
	\x07\x4c\x02\x02\u{413}\u{415}\x07\x19\x02\x02\u{414}\u{40e}\x03\x02\x02\
	\x02\u{414}\u{40f}\x03\x02\x02\x02\u{414}\u{410}\x03\x02\x02\x02\u{414}\
	\u{411}\x03\x02\x02\x02\u{414}\u{412}\x03\x02\x02\x02\u{414}\u{413}\x03\
	\x02\x02\x02\u{415}\u{8b}\x03\x02\x02\x02\u{416}\u{418}\x05\u{8a}\x46\x02\
	\u{417}\u{416}\x03\x02\x02\x02\u{418}\u{419}\x03\x02\x02\x02\u{419}\u{41a}\
	\x03\x02\x02\x02\u{419}\u{417}\x03\x02\x02\x02\u{41a}\u{41c}\x03\x02\x02\
	\x02\u{41b}\u{41d}\x05\u{ce}\x68\x02\u{41c}\u{41b}\x03\x02\x02\x02\u{41c}\
	\u{41d}\x03\x02\x02\x02\u{41d}\u{8d}\x03\x02\x02\x02\u{41e}\u{41f}\x09\x0d\
	\x02\x02\u{41f}\u{8f}\x03\x02\x02\x02\u{420}\u{421}\x09\x0e\x02\x02\u{421}\
	\u{91}\x03\x02\x02\x02\u{422}\u{423}\x07\u{86}\x02\x02\u{423}\u{93}\x03\
	\x02\x02\x02\u{424}\u{428}\x05\u{96}\x4c\x02\u{425}\u{428}\x05\u{11a}\u{8e}\
	\x02\u{426}\u{428}\x05\u{aa}\x56\x02\u{427}\u{424}\x03\x02\x02\x02\u{427}\
	\u{425}\x03\x02\x02\x02\u{427}\u{426}\x03\x02\x02\x02\u{428}\u{95}\x03\x02\
	\x02\x02\u{429}\u{42e}\x05\u{a0}\x51\x02\u{42a}\u{42e}\x05\u{a6}\x54\x02\
	\u{42b}\u{42e}\x05\u{162}\u{b2}\x02\u{42c}\u{42e}\x05\u{f2}\x7a\x02\u{42d}\
	\u{429}\x03\x02\x02\x02\u{42d}\u{42a}\x03\x02\x02\x02\u{42d}\u{42b}\x03\
	\x02\x02\x02\u{42d}\u{42c}\x03\x02\x02\x02\u{42e}\u{97}\x03\x02\x02\x02\
	\u{42f}\u{431}\x05\u{94}\x4b\x02\u{430}\u{42f}\x03\x02\x02\x02\u{431}\u{432}\
	\x03\x02\x02\x02\u{432}\u{430}\x03\x02\x02\x02\u{432}\u{433}\x03\x02\x02\
	\x02\u{433}\u{435}\x03\x02\x02\x02\u{434}\u{436}\x05\u{ce}\x68\x02\u{435}\
	\u{434}\x03\x02\x02\x02\u{435}\u{436}\x03\x02\x02\x02\u{436}\u{99}\x03\x02\
	\x02\x02\u{437}\u{439}\x05\u{96}\x4c\x02\u{438}\u{437}\x03\x02\x02\x02\u{439}\
	\u{43a}\x03\x02\x02\x02\u{43a}\u{438}\x03\x02\x02\x02\u{43a}\u{43b}\x03\
	\x02\x02\x02\u{43b}\u{43d}\x03\x02\x02\x02\u{43c}\u{43e}\x05\u{ce}\x68\x02\
	\u{43d}\u{43c}\x03\x02\x02\x02\u{43d}\u{43e}\x03\x02\x02\x02\u{43e}\u{9b}\
	\x03\x02\x02\x02\u{43f}\u{440}\x09\x0f\x02\x02\u{440}\u{9d}\x03\x02\x02\
	\x02\u{441}\u{442}\x09\x10\x02\x02\u{442}\u{9f}\x03\x02\x02\x02\u{443}\u{445}\
	\x05\x0c\x07\x02\u{444}\u{443}\x03\x02\x02\x02\u{444}\u{445}\x03\x02\x02\
	\x02\u{445}\u{446}\x03\x02\x02\x02\u{446}\u{45c}\x05\u{a2}\x52\x02\u{447}\
	\u{448}\x05\x0c\x07\x02\u{448}\u{449}\x07\x46\x02\x02\u{449}\u{44a}\x05\
	\u{158}\u{ad}\x02\u{44a}\u{45c}\x03\x02\x02\x02\u{44b}\u{45c}\x07\x14\x02\
	\x02\u{44c}\u{45c}\x07\x15\x02\x02\u{44d}\u{45c}\x07\x16\x02\x02\u{44e}\
	\u{45c}\x07\x55\x02\x02\u{44f}\u{45c}\x07\x10\x02\x02\u{450}\u{45c}\x07\
	\x3e\x02\x02\u{451}\u{45c}\x07\x2f\x02\x02\u{452}\u{45c}\x07\x30\x02\x02\
	\u{453}\u{45c}\x07\x29\x02\x02\u{454}\u{45c}\x07\x3f\x02\x02\u{455}\u{45c}\
	\x07\x50\x02\x02\u{456}\u{45c}\x07\x29\x02\x02\u{457}\u{45c}\x07\x20\x02\
	\x02\u{458}\u{45c}\x07\x53\x02\x02\u{459}\u{45c}\x07\x0f\x02\x02\u{45a}\
	\u{45c}\x05\u{a4}\x53\x02\u{45b}\u{444}\x03\x02\x02\x02\u{45b}\u{447}\x03\
	\x02\x02\x02\u{45b}\u{44b}\x03\x02\x02\x02\u{45b}\u{44c}\x03\x02\x02\x02\
	\u{45b}\u{44d}\x03\x02\x02\x02\u{45b}\u{44e}\x03\x02\x02\x02\u{45b}\u{44f}\
	\x03\x02\x02\x02\u{45b}\u{450}\x03\x02\x02\x02\u{45b}\u{451}\x03\x02\x02\
	\x02\u{45b}\u{452}\x03\x02\x02\x02\u{45b}\u{453}\x03\x02\x02\x02\u{45b}\
	\u{454}\x03\x02\x02\x02\u{45b}\u{455}\x03\x02\x02\x02\u{45b}\u{456}\x03\
	\x02\x02\x02\u{45b}\u{457}\x03\x02\x02\x02\u{45b}\u{458}\x03\x02\x02\x02\
	\u{45b}\u{459}\x03\x02\x02\x02\u{45b}\u{45a}\x03\x02\x02\x02\u{45c}\u{a1}\
	\x03\x02\x02\x02\u{45d}\u{462}\x05\u{118}\u{8d}\x02\u{45e}\u{462}\x05\u{a8}\
	\x55\x02\u{45f}\u{462}\x05\u{92}\x4a\x02\u{460}\u{462}\x05\u{158}\u{ad}\
	\x02\u{461}\u{45d}\x03\x02\x02\x02\u{461}\u{45e}\x03\x02\x02\x02\u{461}\
	\u{45f}\x03\x02\x02\x02\u{461}\u{460}\x03\x02\x02\x02\u{462}\u{a3}\x03\x02\
	\x02\x02\u{463}\u{464}\x07\x1c\x02\x02\u{464}\u{467}\x07\x57\x02\x02\u{465}\
	\u{468}\x05\x5c\x2f\x02\u{466}\u{468}\x07\x0f\x02\x02\u{467}\u{465}\x03\
	\x02\x02\x02\u{467}\u{466}\x03\x02\x02\x02\u{468}\u{469}\x03\x02\x02\x02\
	\u{469}\u{46a}\x07\x58\x02\x02\u{46a}\u{a5}\x03\x02\x02\x02\u{46b}\u{47a}\
	\x05\u{122}\u{92}\x02\u{46c}\u{46e}\x05\u{ce}\x68\x02\u{46d}\u{46c}\x03\
	\x02\x02\x02\u{46d}\u{46e}\x03\x02\x02\x02\u{46e}\u{470}\x03\x02\x02\x02\
	\u{46f}\u{471}\x05\x0c\x07\x02\u{470}\u{46f}\x03\x02\x02\x02\u{470}\u{471}\
	\x03\x02\x02\x02\u{471}\u{472}\x03\x02\x02\x02\u{472}\u{47b}\x07\u{86}\x02\
	\x02\u{473}\u{47b}\x05\u{158}\u{ad}\x02\u{474}\u{476}\x05\x0c\x07\x02\u{475}\
	\u{477}\x07\x46\x02\x02\u{476}\u{475}\x03\x02\x02\x02\u{476}\u{477}\x03\
	\x02\x02\x02\u{477}\u{478}\x03\x02\x02\x02\u{478}\u{479}\x05\u{158}\u{ad}\
	\x02\u{479}\u{47b}\x03\x02\x02\x02\u{47a}\u{46d}\x03\x02\x02\x02\u{47a}\
	\u{473}\x03\x02\x02\x02\u{47a}\u{474}\x03\x02\x02\x02\u{47b}\u{482}\x03\
	\x02\x02\x02\u{47c}\u{47e}\x07\x23\x02\x02\u{47d}\u{47f}\x05\x0c\x07\x02\
	\u{47e}\u{47d}\x03\x02\x02\x02\u{47e}\u{47f}\x03\x02\x02\x02\u{47f}\u{480}\
	\x03\x02\x02\x02\u{480}\u{482}\x07\u{86}\x02\x02\u{481}\u{46b}\x03\x02\x02\
	\x02\u{481}\u{47c}\x03\x02\x02\x02\u{482}\u{a7}\x03\x02\x02\x02\u{483}\u{484}\
	\x07\u{86}\x02\x02\u{484}\u{a9}\x03\x02\x02\x02\u{485}\u{486}\x05\u{ac}\
	\x57\x02\u{486}\u{48b}\x07\x5b\x02\x02\u{487}\u{489}\x05\u{b4}\x5b\x02\u{488}\
	\u{48a}\x07\x7c\x02\x02\u{489}\u{488}\x03\x02\x02\x02\u{489}\u{48a}\x03\
	\x02\x02\x02\u{48a}\u{48c}\x03\x02\x02\x02\u{48b}\u{487}\x03\x02\x02\x02\
	\u{48b}\u{48c}\x03\x02\x02\x02\u{48c}\u{48d}\x03\x02\x02\x02\u{48d}\u{48e}\
	\x07\x5c\x02\x02\u{48e}\u{ab}\x03\x02\x02\x02\u{48f}\u{491}\x05\u{b0}\x59\
	\x02\u{490}\u{492}\x05\u{ce}\x68\x02\u{491}\u{490}\x03\x02\x02\x02\u{491}\
	\u{492}\x03\x02\x02\x02\u{492}\u{497}\x03\x02\x02\x02\u{493}\u{495}\x05\
	\x0c\x07\x02\u{494}\u{493}\x03\x02\x02\x02\u{494}\u{495}\x03\x02\x02\x02\
	\u{495}\u{496}\x03\x02\x02\x02\u{496}\u{498}\x07\u{86}\x02\x02\u{497}\u{494}\
	\x03\x02\x02\x02\u{497}\u{498}\x03\x02\x02\x02\u{498}\u{49a}\x03\x02\x02\
	\x02\u{499}\u{49b}\x05\u{b2}\x5a\x02\u{49a}\u{499}\x03\x02\x02\x02\u{49a}\
	\u{49b}\x03\x02\x02\x02\u{49b}\u{ad}\x03\x02\x02\x02\u{49c}\u{49e}\x05\u{b0}\
	\x59\x02\u{49d}\u{49f}\x05\u{ce}\x68\x02\u{49e}\u{49d}\x03\x02\x02\x02\u{49e}\
	\u{49f}\x03\x02\x02\x02\u{49f}\u{4a0}\x03\x02\x02\x02\u{4a0}\u{4a2}\x07\
	\u{86}\x02\x02\u{4a1}\u{4a3}\x05\u{b2}\x5a\x02\u{4a2}\u{4a1}\x03\x02\x02\
	\x02\u{4a2}\u{4a3}\x03\x02\x02\x02\u{4a3}\u{4a4}\x03\x02\x02\x02\u{4a4}\
	\u{4a5}\x07\u{82}\x02\x02\u{4a5}\u{af}\x03\x02\x02\x02\u{4a6}\u{4a8}\x07\
	\x23\x02\x02\u{4a7}\u{4a9}\x09\x11\x02\x02\u{4a8}\u{4a7}\x03\x02\x02\x02\
	\u{4a8}\u{4a9}\x03\x02\x02\x02\u{4a9}\u{b1}\x03\x02\x02\x02\u{4aa}\u{4ab}\
	\x07\u{80}\x02\x02\u{4ab}\u{4ac}\x05\u{98}\x4d\x02\u{4ac}\u{b3}\x03\x02\
	\x02\x02\u{4ad}\u{4b2}\x05\u{b6}\x5c\x02\u{4ae}\u{4af}\x07\x7c\x02\x02\u{4af}\
	\u{4b1}\x05\u{b6}\x5c\x02\u{4b0}\u{4ae}\x03\x02\x02\x02\u{4b1}\u{4b4}\x03\
	\x02\x02\x02\u{4b2}\u{4b0}\x03\x02\x02\x02\u{4b2}\u{4b3}\x03\x02\x02\x02\
	\u{4b3}\u{b5}\x03\x02\x02\x02\u{4b4}\u{4b2}\x03\x02\x02\x02\u{4b5}\u{4b8}\
	\x05\u{b8}\x5d\x02\u{4b6}\u{4b7}\x07\x67\x02\x02\u{4b7}\u{4b9}\x05\x5e\x30\
	\x02\u{4b8}\u{4b6}\x03\x02\x02\x02\u{4b8}\u{4b9}\x03\x02\x02\x02\u{4b9}\
	\u{b7}\x03\x02\x02\x02\u{4ba}\u{4bb}\x07\u{86}\x02\x02\u{4bb}\u{b9}\x03\
	\x02\x02\x02\u{4bc}\u{4bf}\x05\u{bc}\x5f\x02\u{4bd}\u{4bf}\x05\u{c0}\x61\
	\x02\u{4be}\u{4bc}\x03\x02\x02\x02\u{4be}\u{4bd}\x03\x02\x02\x02\u{4bf}\
	\u{bb}\x03\x02\x02\x02\u{4c0}\u{4c1}\x07\u{86}\x02\x02\u{4c1}\u{bd}\x03\
	\x02\x02\x02\u{4c2}\u{4c4}\x07\x2e\x02\x02\u{4c3}\u{4c2}\x03\x02\x02\x02\
	\u{4c3}\u{4c4}\x03\x02\x02\x02\u{4c4}\u{4c5}\x03\x02\x02\x02\u{4c5}\u{4c8}\
	\x07\x32\x02\x02\u{4c6}\u{4c9}\x07\u{86}\x02\x02\u{4c7}\u{4c9}\x05\u{bc}\
	\x5f\x02\u{4c8}\u{4c6}\x03\x02\x02\x02\u{4c8}\u{4c7}\x03\x02\x02\x02\u{4c8}\
	\u{4c9}\x03\x02\x02\x02\u{4c9}\u{4ca}\x03\x02\x02\x02\u{4ca}\u{4cc}\x07\
	\x5b\x02\x02\u{4cb}\u{4cd}\x05\x7a\x3e\x02\u{4cc}\u{4cb}\x03\x02\x02\x02\
	\u{4cc}\u{4cd}\x03\x02\x02\x02\u{4cd}\u{4ce}\x03\x02\x02\x02\u{4ce}\u{4cf}\
	\x07\x5c\x02\x02\u{4cf}\u{bf}\x03\x02\x02\x02\u{4d0}\u{4d1}\x07\u{86}\x02\
	\x02\u{4d1}\u{c1}\x03\x02\x02\x02\u{4d2}\u{4d3}\x07\x32\x02\x02\u{4d3}\u{4d4}\
	\x07\u{86}\x02\x02\u{4d4}\u{4d5}\x07\x67\x02\x02\u{4d5}\u{4d6}\x05\u{c4}\
	\x63\x02\u{4d6}\u{4d7}\x07\u{82}\x02\x02\u{4d7}\u{c3}\x03\x02\x02\x02\u{4d8}\
	\u{4da}\x05\x0c\x07\x02\u{4d9}\u{4d8}\x03\x02\x02\x02\u{4d9}\u{4da}\x03\
	\x02\x02\x02\u{4da}\u{4db}\x03\x02\x02\x02\u{4db}\u{4dc}\x05\u{ba}\x5e\x02\
	\u{4dc}\u{c5}\x03\x02\x02\x02\u{4dd}\u{4e3}\x07\x51\x02\x02\u{4de}\u{4e0}\
	\x07\x4e\x02\x02\u{4df}\u{4de}\x03\x02\x02\x02\u{4df}\u{4e0}\x03\x02\x02\
	\x02\u{4e0}\u{4e1}\x03\x02\x02\x02\u{4e1}\u{4e4}\x05\x0c\x07\x02\u{4e2}\
	\u{4e4}\x07\u{81}\x02\x02\u{4e3}\u{4df}\x03\x02\x02\x02\u{4e3}\u{4e2}\x03\
	\x02\x02\x02\u{4e4}\u{4e5}\x03\x02\x02\x02\u{4e5}\u{4e6}\x05\x08\x05\x02\
	\u{4e6}\u{4e7}\x07\u{82}\x02\x02\u{4e7}\u{c7}\x03\x02\x02\x02\u{4e8}\u{4ea}\
	\x05\u{ce}\x68\x02\u{4e9}\u{4e8}\x03\x02\x02\x02\u{4e9}\u{4ea}\x03\x02\x02\
	\x02\u{4ea}\u{4eb}\x03\x02\x02\x02\u{4eb}\u{4ec}\x07\x51\x02\x02\u{4ec}\
	\u{4ee}\x07\x32\x02\x02\u{4ed}\u{4ef}\x05\x0c\x07\x02\u{4ee}\u{4ed}\x03\
	\x02\x02\x02\u{4ee}\u{4ef}\x03\x02\x02\x02\u{4ef}\u{4f0}\x03\x02\x02\x02\
	\u{4f0}\u{4f1}\x05\u{ba}\x5e\x02\u{4f1}\u{4f2}\x07\u{82}\x02\x02\u{4f2}\
	\u{c9}\x03\x02\x02\x02\u{4f3}\u{4f4}\x07\x0e\x02\x02\u{4f4}\u{4f5}\x07\x57\
	\x02\x02\u{4f5}\u{4f6}\x07\x06\x02\x02\u{4f6}\u{4f7}\x07\x58\x02\x02\u{4f7}\
	\u{4f8}\x07\u{82}\x02\x02\u{4f8}\u{cb}\x03\x02\x02\x02\u{4f9}\u{4fa}\x07\
	\x26\x02\x02\u{4fa}\u{501}\x07\x06\x02\x02\u{4fb}\u{4fd}\x07\x5b\x02\x02\
	\u{4fc}\u{4fe}\x05\x7a\x3e\x02\u{4fd}\u{4fc}\x03\x02\x02\x02\u{4fd}\u{4fe}\
	\x03\x02\x02\x02\u{4fe}\u{4ff}\x03\x02\x02\x02\u{4ff}\u{502}\x07\x5c\x02\
	\x02\u{500}\u{502}\x05\x7c\x3f\x02\u{501}\u{4fb}\x03\x02\x02\x02\u{501}\
	\u{500}\x03\x02\x02\x02\u{502}\u{cd}\x03\x02\x02\x02\u{503}\u{505}\x05\u{d0}\
	\x69\x02\u{504}\u{503}\x03\x02\x02\x02\u{505}\u{506}\x03\x02\x02\x02\u{506}\
	\u{504}\x03\x02\x02\x02\u{506}\u{507}\x03\x02\x02\x02\u{507}\u{cf}\x03\x02\
	\x02\x02\u{508}\u{509}\x07\x59\x02\x02\u{509}\u{50b}\x07\x59\x02\x02\u{50a}\
	\u{50c}\x05\u{d4}\x6b\x02\u{50b}\u{50a}\x03\x02\x02\x02\u{50b}\u{50c}\x03\
	\x02\x02\x02\u{50c}\u{50d}\x03\x02\x02\x02\u{50d}\u{50e}\x07\x5a\x02\x02\
	\u{50e}\u{511}\x07\x5a\x02\x02\u{50f}\u{511}\x05\u{d2}\x6a\x02\u{510}\u{508}\
	\x03\x02\x02\x02\u{510}\u{50f}\x03\x02\x02\x02\u{511}\u{d1}\x03\x02\x02\
	\x02\u{512}\u{513}\x07\x0c\x02\x02\u{513}\u{516}\x07\x57\x02\x02\u{514}\
	\u{517}\x05\u{f8}\x7d\x02\u{515}\u{517}\x05\x5e\x30\x02\u{516}\u{514}\x03\
	\x02\x02\x02\u{516}\u{515}\x03\x02\x02\x02\u{517}\u{519}\x03\x02\x02\x02\
	\u{518}\u{51a}\x07\u{85}\x02\x02\u{519}\u{518}\x03\x02\x02\x02\u{519}\u{51a}\
	\x03\x02\x02\x02\u{51a}\u{51b}\x03\x02\x02\x02\u{51b}\u{51c}\x07\x58\x02\
	\x02\u{51c}\u{d3}\x03\x02\x02\x02\u{51d}\u{522}\x05\u{d6}\x6c\x02\u{51e}\
	\u{51f}\x07\x7c\x02\x02\u{51f}\u{521}\x05\u{d6}\x6c\x02\u{520}\u{51e}\x03\
	\x02\x02\x02\u{521}\u{524}\x03\x02\x02\x02\u{522}\u{520}\x03\x02\x02\x02\
	\u{522}\u{523}\x03\x02\x02\x02\u{523}\u{526}\x03\x02\x02\x02\u{524}\u{522}\
	\x03\x02\x02\x02\u{525}\u{527}\x07\u{85}\x02\x02\u{526}\u{525}\x03\x02\x02\
	\x02\u{526}\u{527}\x03\x02\x02\x02\u{527}\u{d5}\x03\x02\x02\x02\u{528}\u{529}\
	\x05\u{d8}\x6d\x02\u{529}\u{52a}\x07\u{81}\x02\x02\u{52a}\u{52c}\x03\x02\
	\x02\x02\u{52b}\u{528}\x03\x02\x02\x02\u{52b}\u{52c}\x03\x02\x02\x02\u{52c}\
	\u{52d}\x03\x02\x02\x02\u{52d}\u{52f}\x07\u{86}\x02\x02\u{52e}\u{530}\x05\
	\u{da}\x6e\x02\u{52f}\u{52e}\x03\x02\x02\x02\u{52f}\u{530}\x03\x02\x02\x02\
	\u{530}\u{d7}\x03\x02\x02\x02\u{531}\u{532}\x07\u{86}\x02\x02\u{532}\u{d9}\
	\x03\x02\x02\x02\u{533}\u{535}\x07\x57\x02\x02\u{534}\u{536}\x05\u{dc}\x6f\
	\x02\u{535}\u{534}\x03\x02\x02\x02\u{535}\u{536}\x03\x02\x02\x02\u{536}\
	\u{537}\x03\x02\x02\x02\u{537}\u{538}\x07\x58\x02\x02\u{538}\u{db}\x03\x02\
	\x02\x02\u{539}\u{53b}\x05\u{de}\x70\x02\u{53a}\u{539}\x03\x02\x02\x02\u{53b}\
	\u{53c}\x03\x02\x02\x02\u{53c}\u{53a}\x03\x02\x02\x02\u{53c}\u{53d}\x03\
	\x02\x02\x02\u{53d}\u{dd}\x03\x02\x02\x02\u{53e}\u{53f}\x07\x57\x02\x02\
	\u{53f}\u{540}\x05\u{dc}\x6f\x02\u{540}\u{541}\x07\x58\x02\x02\u{541}\u{550}\
	\x03\x02\x02\x02\u{542}\u{543}\x07\x59\x02\x02\u{543}\u{544}\x05\u{dc}\x6f\
	\x02\u{544}\u{545}\x07\x5a\x02\x02\u{545}\u{550}\x03\x02\x02\x02\u{546}\
	\u{547}\x07\x5b\x02\x02\u{547}\u{548}\x05\u{dc}\x6f\x02\u{548}\u{549}\x07\
	\x5c\x02\x02\u{549}\u{550}\x03\x02\x02\x02\u{54a}\u{54c}\x0a\x12\x02\x02\
	\u{54b}\u{54a}\x03\x02\x02\x02\u{54c}\u{54d}\x03\x02\x02\x02\u{54d}\u{54b}\
	\x03\x02\x02\x02\u{54d}\u{54e}\x03\x02\x02\x02\u{54e}\u{550}\x03\x02\x02\
	\x02\u{54f}\u{53e}\x03\x02\x02\x02\u{54f}\u{542}\x03\x02\x02\x02\u{54f}\
	\u{546}\x03\x02\x02\x02\u{54f}\u{54b}\x03\x02\x02\x02\u{550}\u{df}\x03\x02\
	\x02\x02\u{551}\u{556}\x05\u{e2}\x72\x02\u{552}\u{553}\x07\x7c\x02\x02\u{553}\
	\u{555}\x05\u{e2}\x72\x02\u{554}\u{552}\x03\x02\x02\x02\u{555}\u{558}\x03\
	\x02\x02\x02\u{556}\u{554}\x03\x02\x02\x02\u{556}\u{557}\x03\x02\x02\x02\
	\u{557}\u{e1}\x03\x02\x02\x02\u{558}\u{556}\x03\x02\x02\x02\u{559}\u{55b}\
	\x05\u{e4}\x73\x02\u{55a}\u{55c}\x05\u{10e}\u{88}\x02\u{55b}\u{55a}\x03\
	\x02\x02\x02\u{55b}\u{55c}\x03\x02\x02\x02\u{55c}\u{e3}\x03\x02\x02\x02\
	\u{55d}\u{563}\x05\u{e6}\x74\x02\u{55e}\u{55f}\x05\u{e8}\x75\x02\u{55f}\
	\u{560}\x05\u{ea}\x76\x02\u{560}\u{561}\x05\u{ec}\x77\x02\u{561}\u{563}\
	\x03\x02\x02\x02\u{562}\u{55d}\x03\x02\x02\x02\u{562}\u{55e}\x03\x02\x02\
	\x02\u{563}\u{e5}\x03\x02\x02\x02\u{564}\u{566}\x05\u{ee}\x78\x02\u{565}\
	\u{567}\x07\x18\x02\x02\u{566}\u{565}\x03\x02\x02\x02\u{566}\u{567}\x03\
	\x02\x02\x02\u{567}\u{569}\x03\x02\x02\x02\u{568}\u{564}\x03\x02\x02\x02\
	\u{569}\u{56c}\x03\x02\x02\x02\u{56a}\u{568}\x03\x02\x02\x02\u{56a}\u{56b}\
	\x03\x02\x02\x02\u{56b}\u{56d}\x03\x02\x02\x02\u{56c}\u{56a}\x03\x02\x02\
	\x02\u{56d}\u{56e}\x05\u{e8}\x75\x02\u{56e}\u{e7}\x03\x02\x02\x02\u{56f}\
	\u{570}\x08\x75\x01\x02\u{570}\u{572}\x05\u{f6}\x7c\x02\u{571}\u{573}\x05\
	\u{ce}\x68\x02\u{572}\u{571}\x03\x02\x02\x02\u{572}\u{573}\x03\x02\x02\x02\
	\u{573}\u{579}\x03\x02\x02\x02\u{574}\u{575}\x07\x57\x02\x02\u{575}\u{576}\
	\x05\u{e6}\x74\x02\u{576}\u{577}\x07\x58\x02\x02\u{577}\u{579}\x03\x02\x02\
	\x02\u{578}\u{56f}\x03\x02\x02\x02\u{578}\u{574}\x03\x02\x02\x02\u{579}\
	\u{588}\x03\x02\x02\x02\u{57a}\u{584}\x0c\x04\x02\x02\u{57b}\u{585}\x05\
	\u{ea}\x76\x02\u{57c}\u{57e}\x07\x59\x02\x02\u{57d}\u{57f}\x05\x5e\x30\x02\
	\u{57e}\u{57d}\x03\x02\x02\x02\u{57e}\u{57f}\x03\x02\x02\x02\u{57f}\u{580}\
	\x03\x02\x02\x02\u{580}\u{582}\x07\x5a\x02\x02\u{581}\u{583}\x05\u{ce}\x68\
	\x02\u{582}\u{581}\x03\x02\x02\x02\u{582}\u{583}\x03\x02\x02\x02\u{583}\
	\u{585}\x03\x02\x02\x02\u{584}\u{57b}\x03\x02\x02\x02\u{584}\u{57c}\x03\
	\x02\x02\x02\u{585}\u{587}\x03\x02\x02\x02\u{586}\u{57a}\x03\x02\x02\x02\
	\u{587}\u{58a}\x03\x02\x02\x02\u{588}\u{586}\x03\x02\x02\x02\u{588}\u{589}\
	\x03\x02\x02\x02\u{589}\u{e9}\x03\x02\x02\x02\u{58a}\u{588}\x03\x02\x02\
	\x02\u{58b}\u{58d}\x07\x57\x02\x02\u{58c}\u{58e}\x05\u{104}\u{83}\x02\u{58d}\
	\u{58c}\x03\x02\x02\x02\u{58d}\u{58e}\x03\x02\x02\x02\u{58e}\u{58f}\x03\
	\x02\x02\x02\u{58f}\u{591}\x07\x58\x02\x02\u{590}\u{592}\x05\u{f0}\x79\x02\
	\u{591}\u{590}\x03\x02\x02\x02\u{591}\u{592}\x03\x02\x02\x02\u{592}\u{594}\
	\x03\x02\x02\x02\u{593}\u{595}\x05\u{f4}\x7b\x02\u{594}\u{593}\x03\x02\x02\
	\x02\u{594}\u{595}\x03\x02\x02\x02\u{595}\u{597}\x03\x02\x02\x02\u{596}\
	\u{598}\x05\u{174}\u{bb}\x02\u{597}\u{596}\x03\x02\x02\x02\u{597}\u{598}\
	\x03\x02\x02\x02\u{598}\u{59a}\x03\x02\x02\x02\u{599}\u{59b}\x05\u{ce}\x68\
	\x02\u{59a}\u{599}\x03\x02\x02\x02\u{59a}\u{59b}\x03\x02\x02\x02\u{59b}\
	\u{eb}\x03\x02\x02\x02\u{59c}\u{59d}\x07\x7e\x02\x02\u{59d}\u{59f}\x05\u{9a}\
	\x4e\x02\u{59e}\u{5a0}\x05\u{fa}\x7e\x02\u{59f}\u{59e}\x03\x02\x02\x02\u{59f}\
	\u{5a0}\x03\x02\x02\x02\u{5a0}\u{ed}\x03\x02\x02\x02\u{5a1}\u{5a3}\x09\x13\
	\x02\x02\u{5a2}\u{5a4}\x05\u{ce}\x68\x02\u{5a3}\u{5a2}\x03\x02\x02\x02\u{5a3}\
	\u{5a4}\x03\x02\x02\x02\u{5a4}\u{5b0}\x03\x02\x02\x02\u{5a5}\u{5a7}\x05\
	\x0c\x07\x02\u{5a6}\u{5a5}\x03\x02\x02\x02\u{5a6}\u{5a7}\x03\x02\x02\x02\
	\u{5a7}\u{5a8}\x03\x02\x02\x02\u{5a8}\u{5aa}\x07\x5f\x02\x02\u{5a9}\u{5ab}\
	\x05\u{ce}\x68\x02\u{5aa}\u{5a9}\x03\x02\x02\x02\u{5aa}\u{5ab}\x03\x02\x02\
	\x02\u{5ab}\u{5ad}\x03\x02\x02\x02\u{5ac}\u{5ae}\x05\u{f0}\x79\x02\u{5ad}\
	\u{5ac}\x03\x02\x02\x02\u{5ad}\u{5ae}\x03\x02\x02\x02\u{5ae}\u{5b0}\x03\
	\x02\x02\x02\u{5af}\u{5a1}\x03\x02\x02\x02\u{5af}\u{5a6}\x03\x02\x02\x02\
	\u{5b0}\u{ef}\x03\x02\x02\x02\u{5b1}\u{5b3}\x05\u{f2}\x7a\x02\u{5b2}\u{5b1}\
	\x03\x02\x02\x02\u{5b3}\u{5b4}\x03\x02\x02\x02\u{5b4}\u{5b2}\x03\x02\x02\
	\x02\u{5b4}\u{5b5}\x03\x02\x02\x02\u{5b5}\u{f1}\x03\x02\x02\x02\u{5b6}\u{5b7}\
	\x09\x14\x02\x02\u{5b7}\u{f3}\x03\x02\x02\x02\u{5b8}\u{5b9}\x09\x13\x02\
	\x02\u{5b9}\u{f5}\x03\x02\x02\x02\u{5ba}\u{5bc}\x07\u{85}\x02\x02\u{5bb}\
	\u{5ba}\x03\x02\x02\x02\u{5bb}\u{5bc}\x03\x02\x02\x02\u{5bc}\u{5bd}\x03\
	\x02\x02\x02\u{5bd}\u{5be}\x05\x06\x04\x02\u{5be}\u{f7}\x03\x02\x02\x02\
	\u{5bf}\u{5c1}\x05\u{98}\x4d\x02\u{5c0}\u{5c2}\x05\u{fa}\x7e\x02\u{5c1}\
	\u{5c0}\x03\x02\x02\x02\u{5c1}\u{5c2}\x03\x02\x02\x02\u{5c2}\u{f9}\x03\x02\
	\x02\x02\u{5c3}\u{5cc}\x05\u{fc}\x7f\x02\u{5c4}\u{5c6}\x05\u{fe}\u{80}\x02\
	\u{5c5}\u{5c4}\x03\x02\x02\x02\u{5c5}\u{5c6}\x03\x02\x02\x02\u{5c6}\u{5c7}\
	\x03\x02\x02\x02\u{5c7}\u{5c8}\x05\u{ea}\x76\x02\u{5c8}\u{5c9}\x05\u{ec}\
	\x77\x02\u{5c9}\u{5cc}\x03\x02\x02\x02\u{5ca}\u{5cc}\x05\u{100}\u{81}\x02\
	\u{5cb}\u{5c3}\x03\x02\x02\x02\u{5cb}\u{5c5}\x03\x02\x02\x02\u{5cb}\u{5ca}\
	\x03\x02\x02\x02\u{5cc}\u{fb}\x03\x02\x02\x02\u{5cd}\u{5d7}\x05\u{fe}\u{80}\
	\x02\u{5ce}\u{5d0}\x05\u{ee}\x78\x02\u{5cf}\u{5ce}\x03\x02\x02\x02\u{5d0}\
	\u{5d1}\x03\x02\x02\x02\u{5d1}\u{5cf}\x03\x02\x02\x02\u{5d1}\u{5d2}\x03\
	\x02\x02\x02\u{5d2}\u{5d4}\x03\x02\x02\x02\u{5d3}\u{5d5}\x05\u{fe}\u{80}\
	\x02\u{5d4}\u{5d3}\x03\x02\x02\x02\u{5d4}\u{5d5}\x03\x02\x02\x02\u{5d5}\
	\u{5d7}\x03\x02\x02\x02\u{5d6}\u{5cd}\x03\x02\x02\x02\u{5d6}\u{5cf}\x03\
	\x02\x02\x02\u{5d7}\u{fd}\x03\x02\x02\x02\u{5d8}\u{5d9}\x08\u{80}\x01\x02\
	\u{5d9}\u{5e7}\x05\u{ea}\x76\x02\u{5da}\u{5dc}\x07\x59\x02\x02\u{5db}\u{5dd}\
	\x05\x5e\x30\x02\u{5dc}\u{5db}\x03\x02\x02\x02\u{5dc}\u{5dd}\x03\x02\x02\
	\x02\u{5dd}\u{5de}\x03\x02\x02\x02\u{5de}\u{5e0}\x07\x5a\x02\x02\u{5df}\
	\u{5e1}\x05\u{ce}\x68\x02\u{5e0}\u{5df}\x03\x02\x02\x02\u{5e0}\u{5e1}\x03\
	\x02\x02\x02\u{5e1}\u{5e7}\x03\x02\x02\x02\u{5e2}\u{5e3}\x07\x57\x02\x02\
	\u{5e3}\u{5e4}\x05\u{fc}\x7f\x02\u{5e4}\u{5e5}\x07\x58\x02\x02\u{5e5}\u{5e7}\
	\x03\x02\x02\x02\u{5e6}\u{5d8}\x03\x02\x02\x02\u{5e6}\u{5da}\x03\x02\x02\
	\x02\u{5e6}\u{5e2}\x03\x02\x02\x02\u{5e7}\u{5f7}\x03\x02\x02\x02\u{5e8}\
	\u{5f3}\x0c\x06\x02\x02\u{5e9}\u{5f4}\x05\u{ea}\x76\x02\u{5ea}\u{5eb}\x05\
	\u{fe}\u{80}\x02\u{5eb}\u{5ed}\x07\x59\x02\x02\u{5ec}\u{5ee}\x05\x5e\x30\
	\x02\u{5ed}\u{5ec}\x03\x02\x02\x02\u{5ed}\u{5ee}\x03\x02\x02\x02\u{5ee}\
	\u{5ef}\x03\x02\x02\x02\u{5ef}\u{5f1}\x07\x5a\x02\x02\u{5f0}\u{5f2}\x05\
	\u{ce}\x68\x02\u{5f1}\u{5f0}\x03\x02\x02\x02\u{5f1}\u{5f2}\x03\x02\x02\x02\
	\u{5f2}\u{5f4}\x03\x02\x02\x02\u{5f3}\u{5e9}\x03\x02\x02\x02\u{5f3}\u{5ea}\
	\x03\x02\x02\x02\u{5f4}\u{5f6}\x03\x02\x02\x02\u{5f5}\u{5e8}\x03\x02\x02\
	\x02\u{5f6}\u{5f9}\x03\x02\x02\x02\u{5f7}\u{5f5}\x03\x02\x02\x02\u{5f7}\
	\u{5f8}\x03\x02\x02\x02\u{5f8}\u{ff}\x03\x02\x02\x02\u{5f9}\u{5f7}\x03\x02\
	\x02\x02\u{5fa}\u{5fc}\x05\u{ee}\x78\x02\u{5fb}\u{5fa}\x03\x02\x02\x02\u{5fc}\
	\u{5ff}\x03\x02\x02\x02\u{5fd}\u{5fb}\x03\x02\x02\x02\u{5fd}\u{5fe}\x03\
	\x02\x02\x02\u{5fe}\u{600}\x03\x02\x02\x02\u{5ff}\u{5fd}\x03\x02\x02\x02\
	\u{600}\u{601}\x05\u{102}\u{82}\x02\u{601}\u{101}\x03\x02\x02\x02\u{602}\
	\u{603}\x08\u{82}\x01\x02\u{603}\u{604}\x07\u{85}\x02\x02\u{604}\u{613}\
	\x03\x02\x02\x02\u{605}\u{60f}\x0c\x04\x02\x02\u{606}\u{610}\x05\u{ea}\x76\
	\x02\u{607}\u{609}\x07\x59\x02\x02\u{608}\u{60a}\x05\x5e\x30\x02\u{609}\
	\u{608}\x03\x02\x02\x02\u{609}\u{60a}\x03\x02\x02\x02\u{60a}\u{60b}\x03\
	\x02\x02\x02\u{60b}\u{60d}\x07\x5a\x02\x02\u{60c}\u{60e}\x05\u{ce}\x68\x02\
	\u{60d}\u{60c}\x03\x02\x02\x02\u{60d}\u{60e}\x03\x02\x02\x02\u{60e}\u{610}\
	\x03\x02\x02\x02\u{60f}\u{606}\x03\x02\x02\x02\u{60f}\u{607}\x03\x02\x02\
	\x02\u{610}\u{612}\x03\x02\x02\x02\u{611}\u{605}\x03\x02\x02\x02\u{612}\
	\u{615}\x03\x02\x02\x02\u{613}\u{611}\x03\x02\x02\x02\u{613}\u{614}\x03\
	\x02\x02\x02\u{614}\u{103}\x03\x02\x02\x02\u{615}\u{613}\x03\x02\x02\x02\
	\u{616}\u{61b}\x05\u{106}\u{84}\x02\u{617}\u{619}\x07\x7c\x02\x02\u{618}\
	\u{617}\x03\x02\x02\x02\u{618}\u{619}\x03\x02\x02\x02\u{619}\u{61a}\x03\
	\x02\x02\x02\u{61a}\u{61c}\x07\u{85}\x02\x02\u{61b}\u{618}\x03\x02\x02\x02\
	\u{61b}\u{61c}\x03\x02\x02\x02\u{61c}\u{105}\x03\x02\x02\x02\u{61d}\u{622}\
	\x05\u{108}\u{85}\x02\u{61e}\u{61f}\x07\x7c\x02\x02\u{61f}\u{621}\x05\u{108}\
	\u{85}\x02\u{620}\u{61e}\x03\x02\x02\x02\u{621}\u{624}\x03\x02\x02\x02\u{622}\
	\u{620}\x03\x02\x02\x02\u{622}\u{623}\x03\x02\x02\x02\u{623}\u{107}\x03\
	\x02\x02\x02\u{624}\u{622}\x03\x02\x02\x02\u{625}\u{627}\x05\u{ce}\x68\x02\
	\u{626}\u{625}\x03\x02\x02\x02\u{626}\u{627}\x03\x02\x02\x02\u{627}\u{628}\
	\x03\x02\x02\x02\u{628}\u{62d}\x05\u{8c}\x47\x02\u{629}\u{62e}\x05\u{e4}\
	\x73\x02\u{62a}\u{62c}\x05\u{fa}\x7e\x02\u{62b}\u{62a}\x03\x02\x02\x02\u{62b}\
	\u{62c}\x03\x02\x02\x02\u{62c}\u{62e}\x03\x02\x02\x02\u{62d}\u{629}\x03\
	\x02\x02\x02\u{62d}\u{62b}\x03\x02\x02\x02\u{62e}\u{631}\x03\x02\x02\x02\
	\u{62f}\u{630}\x07\x67\x02\x02\u{630}\u{632}\x05\u{112}\u{8a}\x02\u{631}\
	\u{62f}\x03\x02\x02\x02\u{631}\u{632}\x03\x02\x02\x02\u{632}\u{109}\x03\
	\x02\x02\x02\u{633}\u{635}\x05\u{ce}\x68\x02\u{634}\u{633}\x03\x02\x02\x02\
	\u{634}\u{635}\x03\x02\x02\x02\u{635}\u{637}\x03\x02\x02\x02\u{636}\u{638}\
	\x05\u{8c}\x47\x02\u{637}\u{636}\x03\x02\x02\x02\u{637}\u{638}\x03\x02\x02\
	\x02\u{638}\u{639}\x03\x02\x02\x02\u{639}\u{63b}\x05\u{e4}\x73\x02\u{63a}\
	\u{63c}\x05\u{12c}\u{97}\x02\u{63b}\u{63a}\x03\x02\x02\x02\u{63b}\u{63c}\
	\x03\x02\x02\x02\u{63c}\u{63d}\x03\x02\x02\x02\u{63d}\u{63e}\x05\u{10c}\
	\u{87}\x02\u{63e}\u{10b}\x03\x02\x02\x02\u{63f}\u{641}\x05\u{144}\u{a3}\
	\x02\u{640}\u{63f}\x03\x02\x02\x02\u{640}\u{641}\x03\x02\x02\x02\u{641}\
	\u{642}\x03\x02\x02\x02\u{642}\u{648}\x05\x66\x34\x02\u{643}\u{648}\x05\
	\u{16a}\u{b6}\x02\u{644}\u{645}\x07\x67\x02\x02\u{645}\u{646}\x09\x15\x02\
	\x02\u{646}\u{648}\x07\u{82}\x02\x02\u{647}\u{640}\x03\x02\x02\x02\u{647}\
	\u{643}\x03\x02\x02\x02\u{647}\u{644}\x03\x02\x02\x02\u{648}\u{10d}\x03\
	\x02\x02\x02\u{649}\u{64f}\x05\u{110}\u{89}\x02\u{64a}\u{64b}\x07\x57\x02\
	\x02\u{64b}\u{64c}\x05\x24\x13\x02\u{64c}\u{64d}\x07\x58\x02\x02\u{64d}\
	\u{64f}\x03\x02\x02\x02\u{64e}\u{649}\x03\x02\x02\x02\u{64e}\u{64a}\x03\
	\x02\x02\x02\u{64f}\u{10f}\x03\x02\x02\x02\u{650}\u{651}\x07\x67\x02\x02\
	\u{651}\u{654}\x05\u{112}\u{8a}\x02\u{652}\u{654}\x05\u{116}\u{8c}\x02\u{653}\
	\u{650}\x03\x02\x02\x02\u{653}\u{652}\x03\x02\x02\x02\u{654}\u{111}\x03\
	\x02\x02\x02\u{655}\u{658}\x05\x58\x2d\x02\u{656}\u{658}\x05\u{116}\u{8c}\
	\x02\u{657}\u{655}\x03\x02\x02\x02\u{657}\u{656}\x03\x02\x02\x02\u{658}\
	\u{113}\x03\x02\x02\x02\u{659}\u{65b}\x05\u{112}\u{8a}\x02\u{65a}\u{65c}\
	\x07\u{85}\x02\x02\u{65b}\u{65a}\x03\x02\x02\x02\u{65b}\u{65c}\x03\x02\x02\
	\x02\u{65c}\u{664}\x03\x02\x02\x02\u{65d}\u{65e}\x07\x7c\x02\x02\u{65e}\
	\u{660}\x05\u{112}\u{8a}\x02\u{65f}\u{661}\x07\u{85}\x02\x02\u{660}\u{65f}\
	\x03\x02\x02\x02\u{660}\u{661}\x03\x02\x02\x02\u{661}\u{663}\x03\x02\x02\
	\x02\u{662}\u{65d}\x03\x02\x02\x02\u{663}\u{666}\x03\x02\x02\x02\u{664}\
	\u{662}\x03\x02\x02\x02\u{664}\u{665}\x03\x02\x02\x02\u{665}\u{115}\x03\
	\x02\x02\x02\u{666}\u{664}\x03\x02\x02\x02\u{667}\u{66c}\x07\x5b\x02\x02\
	\u{668}\u{66a}\x05\u{114}\u{8b}\x02\u{669}\u{66b}\x07\x7c\x02\x02\u{66a}\
	\u{669}\x03\x02\x02\x02\u{66a}\u{66b}\x03\x02\x02\x02\u{66b}\u{66d}\x03\
	\x02\x02\x02\u{66c}\u{668}\x03\x02\x02\x02\u{66c}\u{66d}\x03\x02\x02\x02\
	\u{66d}\u{66e}\x03\x02\x02\x02\u{66e}\u{66f}\x07\x5c\x02\x02\u{66f}\u{117}\
	\x03\x02\x02\x02\u{670}\u{673}\x07\u{86}\x02\x02\u{671}\u{673}\x05\u{158}\
	\u{ad}\x02\u{672}\u{670}\x03\x02\x02\x02\u{672}\u{671}\x03\x02\x02\x02\u{673}\
	\u{119}\x03\x02\x02\x02\u{674}\u{675}\x05\u{11c}\u{8f}\x02\u{675}\u{677}\
	\x07\x5b\x02\x02\u{676}\u{678}\x05\u{124}\u{93}\x02\u{677}\u{676}\x03\x02\
	\x02\x02\u{677}\u{678}\x03\x02\x02\x02\u{678}\u{679}\x03\x02\x02\x02\u{679}\
	\u{67a}\x07\x5c\x02\x02\u{67a}\u{11b}\x03\x02\x02\x02\u{67b}\u{67d}\x05\
	\u{122}\u{92}\x02\u{67c}\u{67e}\x05\u{ce}\x68\x02\u{67d}\u{67c}\x03\x02\
	\x02\x02\u{67d}\u{67e}\x03\x02\x02\x02\u{67e}\u{683}\x03\x02\x02\x02\u{67f}\
	\u{681}\x05\u{11e}\u{90}\x02\u{680}\u{682}\x05\u{120}\u{91}\x02\u{681}\u{680}\
	\x03\x02\x02\x02\u{681}\u{682}\x03\x02\x02\x02\u{682}\u{684}\x03\x02\x02\
	\x02\u{683}\u{67f}\x03\x02\x02\x02\u{683}\u{684}\x03\x02\x02\x02\u{684}\
	\u{686}\x03\x02\x02\x02\u{685}\u{687}\x05\u{132}\u{9a}\x02\u{686}\u{685}\
	\x03\x02\x02\x02\u{686}\u{687}\x03\x02\x02\x02\u{687}\u{693}\x03\x02\x02\
	\x02\u{688}\u{68a}\x07\x4f\x02\x02\u{689}\u{68b}\x05\u{ce}\x68\x02\u{68a}\
	\u{689}\x03\x02\x02\x02\u{68a}\u{68b}\x03\x02\x02\x02\u{68b}\u{690}\x03\
	\x02\x02\x02\u{68c}\u{68e}\x05\u{11e}\u{90}\x02\u{68d}\u{68f}\x05\u{120}\
	\u{91}\x02\u{68e}\u{68d}\x03\x02\x02\x02\u{68e}\u{68f}\x03\x02\x02\x02\u{68f}\
	\u{691}\x03\x02\x02\x02\u{690}\u{68c}\x03\x02\x02\x02\u{690}\u{691}\x03\
	\x02\x02\x02\u{691}\u{693}\x03\x02\x02\x02\u{692}\u{67b}\x03\x02\x02\x02\
	\u{692}\u{688}\x03\x02\x02\x02\u{693}\u{11d}\x03\x02\x02\x02\u{694}\u{696}\
	\x05\x0c\x07\x02\u{695}\u{694}\x03\x02\x02\x02\u{695}\u{696}\x03\x02\x02\
	\x02\u{696}\u{697}\x03\x02\x02\x02\u{697}\u{698}\x05\u{118}\u{8d}\x02\u{698}\
	\u{11f}\x03\x02\x02\x02\u{699}\u{69a}\x07\x28\x02\x02\u{69a}\u{121}\x03\
	\x02\x02\x02\u{69b}\u{69c}\x09\x11\x02\x02\u{69c}\u{123}\x03\x02\x02\x02\
	\u{69d}\u{6a2}\x05\u{126}\u{94}\x02\u{69e}\u{69f}\x05\u{13c}\u{9f}\x02\u{69f}\
	\u{6a0}\x07\u{80}\x02\x02\u{6a0}\u{6a2}\x03\x02\x02\x02\u{6a1}\u{69d}\x03\
	\x02\x02\x02\u{6a1}\u{69e}\x03\x02\x02\x02\u{6a2}\u{6a3}\x03\x02\x02\x02\
	\u{6a3}\u{6a1}\x03\x02\x02\x02\u{6a3}\u{6a4}\x03\x02\x02\x02\u{6a4}\u{125}\
	\x03\x02\x02\x02\u{6a5}\u{6a7}\x05\u{ce}\x68\x02\u{6a6}\u{6a5}\x03\x02\x02\
	\x02\u{6a6}\u{6a7}\x03\x02\x02\x02\u{6a7}\u{6a9}\x03\x02\x02\x02\u{6a8}\
	\u{6aa}\x05\u{8c}\x47\x02\u{6a9}\u{6a8}\x03\x02\x02\x02\u{6a9}\u{6aa}\x03\
	\x02\x02\x02\u{6aa}\u{6ac}\x03\x02\x02\x02\u{6ab}\u{6ad}\x05\u{128}\u{95}\
	\x02\u{6ac}\u{6ab}\x03\x02\x02\x02\u{6ac}\u{6ad}\x03\x02\x02\x02\u{6ad}\
	\u{6ae}\x03\x02\x02\x02\u{6ae}\u{6b6}\x07\u{82}\x02\x02\u{6af}\u{6b6}\x05\
	\u{10a}\u{86}\x02\u{6b0}\u{6b6}\x05\u{c6}\x64\x02\u{6b1}\u{6b6}\x05\u{84}\
	\x43\x02\u{6b2}\u{6b6}\x05\u{150}\u{a9}\x02\u{6b3}\u{6b6}\x05\u{80}\x41\
	\x02\u{6b4}\u{6b6}\x05\u{86}\x44\x02\u{6b5}\u{6a6}\x03\x02\x02\x02\u{6b5}\
	\u{6af}\x03\x02\x02\x02\u{6b5}\u{6b0}\x03\x02\x02\x02\u{6b5}\u{6b1}\x03\
	\x02\x02\x02\u{6b5}\u{6b2}\x03\x02\x02\x02\u{6b5}\u{6b3}\x03\x02\x02\x02\
	\u{6b5}\u{6b4}\x03\x02\x02\x02\u{6b6}\u{127}\x03\x02\x02\x02\u{6b7}\u{6bc}\
	\x05\u{12a}\u{96}\x02\u{6b8}\u{6b9}\x07\x7c\x02\x02\u{6b9}\u{6bb}\x05\u{12a}\
	\u{96}\x02\u{6ba}\u{6b8}\x03\x02\x02\x02\u{6bb}\u{6be}\x03\x02\x02\x02\u{6bc}\
	\u{6ba}\x03\x02\x02\x02\u{6bc}\u{6bd}\x03\x02\x02\x02\u{6bd}\u{129}\x03\
	\x02\x02\x02\u{6be}\u{6bc}\x03\x02\x02\x02\u{6bf}\u{6c8}\x05\u{e4}\x73\x02\
	\u{6c0}\u{6c9}\x05\u{12c}\u{97}\x02\u{6c1}\u{6c2}\x06\u{96}\x0b\x02\u{6c2}\
	\u{6c9}\x05\u{130}\u{99}\x02\u{6c3}\u{6c4}\x06\u{96}\x0c\x02\u{6c4}\u{6c5}\
	\x05\u{12c}\u{97}\x02\u{6c5}\u{6c6}\x05\u{130}\u{99}\x02\u{6c6}\u{6c9}\x03\
	\x02\x02\x02\u{6c7}\u{6c9}\x05\u{110}\u{89}\x02\u{6c8}\u{6c0}\x03\x02\x02\
	\x02\u{6c8}\u{6c1}\x03\x02\x02\x02\u{6c8}\u{6c3}\x03\x02\x02\x02\u{6c8}\
	\u{6c7}\x03\x02\x02\x02\u{6c9}\u{6d4}\x03\x02\x02\x02\u{6ca}\u{6d4}\x05\
	\u{e4}\x73\x02\u{6cb}\u{6cd}\x07\u{86}\x02\x02\u{6cc}\u{6cb}\x03\x02\x02\
	\x02\u{6cc}\u{6cd}\x03\x02\x02\x02\u{6cd}\u{6cf}\x03\x02\x02\x02\u{6ce}\
	\u{6d0}\x05\u{ce}\x68\x02\u{6cf}\u{6ce}\x03\x02\x02\x02\u{6cf}\u{6d0}\x03\
	\x02\x02\x02\u{6d0}\u{6d1}\x03\x02\x02\x02\u{6d1}\u{6d2}\x07\u{80}\x02\x02\
	\u{6d2}\u{6d4}\x05\x5e\x30\x02\u{6d3}\u{6bf}\x03\x02\x02\x02\u{6d3}\u{6ca}\
	\x03\x02\x02\x02\u{6d3}\u{6cc}\x03\x02\x02\x02\u{6d4}\u{12b}\x03\x02\x02\
	\x02\u{6d5}\u{6d7}\x05\u{12e}\u{98}\x02\u{6d6}\u{6d5}\x03\x02\x02\x02\u{6d7}\
	\u{6d8}\x03\x02\x02\x02\u{6d8}\u{6d6}\x03\x02\x02\x02\u{6d8}\u{6d9}\x03\
	\x02\x02\x02\u{6d9}\u{12d}\x03\x02\x02\x02\u{6da}\u{6db}\x09\x16\x02\x02\
	\u{6db}\u{12f}\x03\x02\x02\x02\u{6dc}\u{6dd}\x07\x67\x02\x02\u{6dd}\u{6de}\
	\x07\x03\x02\x02\u{6de}\u{131}\x03\x02\x02\x02\u{6df}\u{6e0}\x07\u{80}\x02\
	\x02\u{6e0}\u{6e1}\x05\u{134}\u{9b}\x02\u{6e1}\u{133}\x03\x02\x02\x02\u{6e2}\
	\u{6e4}\x05\u{136}\u{9c}\x02\u{6e3}\u{6e5}\x07\u{85}\x02\x02\u{6e4}\u{6e3}\
	\x03\x02\x02\x02\u{6e4}\u{6e5}\x03\x02\x02\x02\u{6e5}\u{6ed}\x03\x02\x02\
	\x02\u{6e6}\u{6e7}\x07\x7c\x02\x02\u{6e7}\u{6e9}\x05\u{136}\u{9c}\x02\u{6e8}\
	\u{6ea}\x07\u{85}\x02\x02\u{6e9}\u{6e8}\x03\x02\x02\x02\u{6e9}\u{6ea}\x03\
	\x02\x02\x02\u{6ea}\u{6ec}\x03\x02\x02\x02\u{6eb}\u{6e6}\x03\x02\x02\x02\
	\u{6ec}\u{6ef}\x03\x02\x02\x02\u{6ed}\u{6eb}\x03\x02\x02\x02\u{6ed}\u{6ee}\
	\x03\x02\x02\x02\u{6ee}\u{135}\x03\x02\x02\x02\u{6ef}\u{6ed}\x03\x02\x02\
	\x02\u{6f0}\u{6f2}\x05\u{ce}\x68\x02\u{6f1}\u{6f0}\x03\x02\x02\x02\u{6f1}\
	\u{6f2}\x03\x02\x02\x02\u{6f2}\u{6ff}\x03\x02\x02\x02\u{6f3}\u{700}\x05\
	\u{13a}\u{9e}\x02\u{6f4}\u{6f6}\x07\x52\x02\x02\u{6f5}\u{6f7}\x05\u{13c}\
	\u{9f}\x02\u{6f6}\u{6f5}\x03\x02\x02\x02\u{6f6}\u{6f7}\x03\x02\x02\x02\u{6f7}\
	\u{6f8}\x03\x02\x02\x02\u{6f8}\u{700}\x05\u{13a}\u{9e}\x02\u{6f9}\u{6fb}\
	\x05\u{13c}\u{9f}\x02\u{6fa}\u{6fc}\x07\x52\x02\x02\u{6fb}\u{6fa}\x03\x02\
	\x02\x02\u{6fb}\u{6fc}\x03\x02\x02\x02\u{6fc}\u{6fd}\x03\x02\x02\x02\u{6fd}\
	\u{6fe}\x05\u{13a}\u{9e}\x02\u{6fe}\u{700}\x03\x02\x02\x02\u{6ff}\u{6f3}\
	\x03\x02\x02\x02\u{6ff}\u{6f4}\x03\x02\x02\x02\u{6ff}\u{6f9}\x03\x02\x02\
	\x02\u{700}\u{137}\x03\x02\x02\x02\u{701}\u{703}\x05\x0c\x07\x02\u{702}\
	\u{701}\x03\x02\x02\x02\u{702}\u{703}\x03\x02\x02\x02\u{703}\u{704}\x03\
	\x02\x02\x02\u{704}\u{707}\x05\u{118}\u{8d}\x02\u{705}\u{707}\x05\u{a4}\
	\x53\x02\u{706}\u{702}\x03\x02\x02\x02\u{706}\u{705}\x03\x02\x02\x02\u{707}\
	\u{139}\x03\x02\x02\x02\u{708}\u{709}\x05\u{138}\u{9d}\x02\u{709}\u{13b}\
	\x03\x02\x02\x02\u{70a}\u{70b}\x09\x17\x02\x02\u{70b}\u{13d}\x03\x02\x02\
	\x02\u{70c}\u{70d}\x07\x36\x02\x02\u{70d}\u{70e}\x05\u{140}\u{a1}\x02\u{70e}\
	\u{13f}\x03\x02\x02\x02\u{70f}\u{711}\x05\u{98}\x4d\x02\u{710}\u{712}\x05\
	\u{142}\u{a2}\x02\u{711}\u{710}\x03\x02\x02\x02\u{711}\u{712}\x03\x02\x02\
	\x02\u{712}\u{141}\x03\x02\x02\x02\u{713}\u{715}\x05\u{ee}\x78\x02\u{714}\
	\u{716}\x05\u{142}\u{a2}\x02\u{715}\u{714}\x03\x02\x02\x02\u{715}\u{716}\
	\x03\x02\x02\x02\u{716}\u{143}\x03\x02\x02\x02\u{717}\u{718}\x07\u{80}\x02\
	\x02\u{718}\u{719}\x05\u{146}\u{a4}\x02\u{719}\u{145}\x03\x02\x02\x02\u{71a}\
	\u{71c}\x05\u{148}\u{a5}\x02\u{71b}\u{71d}\x07\u{85}\x02\x02\u{71c}\u{71b}\
	\x03\x02\x02\x02\u{71c}\u{71d}\x03\x02\x02\x02\u{71d}\u{725}\x03\x02\x02\
	\x02\u{71e}\u{71f}\x07\x7c\x02\x02\u{71f}\u{721}\x05\u{148}\u{a5}\x02\u{720}\
	\u{722}\x07\u{85}\x02\x02\u{721}\u{720}\x03\x02\x02\x02\u{721}\u{722}\x03\
	\x02\x02\x02\u{722}\u{724}\x03\x02\x02\x02\u{723}\u{71e}\x03\x02\x02\x02\
	\u{724}\u{727}\x03\x02\x02\x02\u{725}\u{723}\x03\x02\x02\x02\u{725}\u{726}\
	\x03\x02\x02\x02\u{726}\u{147}\x03\x02\x02\x02\u{727}\u{725}\x03\x02\x02\
	\x02\u{728}\u{72f}\x05\u{14a}\u{a6}\x02\u{729}\u{72b}\x07\x57\x02\x02\u{72a}\
	\u{72c}\x05\x24\x13\x02\u{72b}\u{72a}\x03\x02\x02\x02\u{72b}\u{72c}\x03\
	\x02\x02\x02\u{72c}\u{72d}\x03\x02\x02\x02\u{72d}\u{730}\x07\x58\x02\x02\
	\u{72e}\u{730}\x05\u{116}\u{8c}\x02\u{72f}\u{729}\x03\x02\x02\x02\u{72f}\
	\u{72e}\x03\x02\x02\x02\u{730}\u{149}\x03\x02\x02\x02\u{731}\u{734}\x05\
	\u{138}\u{9d}\x02\u{732}\u{734}\x07\u{86}\x02\x02\u{733}\u{731}\x03\x02\
	\x02\x02\u{733}\u{732}\x03\x02\x02\x02\u{734}\u{14b}\x03\x02\x02\x02\u{735}\
	\u{736}\x07\x36\x02\x02\u{736}\u{737}\x05\u{17c}\u{bf}\x02\u{737}\u{14d}\
	\x03\x02\x02\x02\u{738}\u{73c}\x07\x36\x02\x02\u{739}\u{73a}\x07\x06\x02\
	\x02\u{73a}\u{73d}\x07\u{86}\x02\x02\u{73b}\u{73d}\x07\u{8e}\x02\x02\u{73c}\
	\u{739}\x03\x02\x02\x02\u{73c}\u{73b}\x03\x02\x02\x02\u{73d}\u{14f}\x03\
	\x02\x02\x02\u{73e}\u{73f}\x07\x46\x02\x02\u{73f}\u{740}\x07\x68\x02\x02\
	\u{740}\u{741}\x05\u{152}\u{aa}\x02\u{741}\u{742}\x07\x69\x02\x02\u{742}\
	\u{743}\x05\x7c\x3f\x02\u{743}\u{151}\x03\x02\x02\x02\u{744}\u{749}\x05\
	\u{154}\u{ab}\x02\u{745}\u{746}\x07\x7c\x02\x02\u{746}\u{748}\x05\u{154}\
	\u{ab}\x02\u{747}\u{745}\x03\x02\x02\x02\u{748}\u{74b}\x03\x02\x02\x02\u{749}\
	\u{747}\x03\x02\x02\x02\u{749}\u{74a}\x03\x02\x02\x02\u{74a}\u{153}\x03\
	\x02\x02\x02\u{74b}\u{749}\x03\x02\x02\x02\u{74c}\u{74f}\x05\u{156}\u{ac}\
	\x02\u{74d}\u{74f}\x05\u{108}\u{85}\x02\u{74e}\u{74c}\x03\x02\x02\x02\u{74e}\
	\u{74d}\x03\x02\x02\x02\u{74f}\u{155}\x03\x02\x02\x02\u{750}\u{751}\x07\
	\x46\x02\x02\u{751}\u{752}\x07\x68\x02\x02\u{752}\u{753}\x05\u{152}\u{aa}\
	\x02\u{753}\u{754}\x07\x69\x02\x02\u{754}\u{756}\x03\x02\x02\x02\u{755}\
	\u{750}\x03\x02\x02\x02\u{755}\u{756}\x03\x02\x02\x02\u{756}\u{757}\x03\
	\x02\x02\x02\u{757}\u{75a}\x07\x17\x02\x02\u{758}\u{75a}\x07\x4e\x02\x02\
	\u{759}\u{755}\x03\x02\x02\x02\u{759}\u{758}\x03\x02\x02\x02\u{75a}\u{766}\
	\x03\x02\x02\x02\u{75b}\u{75d}\x07\u{85}\x02\x02\u{75c}\u{75b}\x03\x02\x02\
	\x02\u{75c}\u{75d}\x03\x02\x02\x02\u{75d}\u{75f}\x03\x02\x02\x02\u{75e}\
	\u{760}\x07\u{86}\x02\x02\u{75f}\u{75e}\x03\x02\x02\x02\u{75f}\u{760}\x03\
	\x02\x02\x02\u{760}\u{767}\x03\x02\x02\x02\u{761}\u{763}\x07\u{86}\x02\x02\
	\u{762}\u{761}\x03\x02\x02\x02\u{762}\u{763}\x03\x02\x02\x02\u{763}\u{764}\
	\x03\x02\x02\x02\u{764}\u{765}\x07\x67\x02\x02\u{765}\u{767}\x05\u{f8}\x7d\
	\x02\u{766}\u{75c}\x03\x02\x02\x02\u{766}\u{762}\x03\x02\x02\x02\u{767}\
	\u{157}\x03\x02\x02\x02\u{768}\u{769}\x05\u{15c}\u{af}\x02\u{769}\u{76b}\
	\x07\x68\x02\x02\u{76a}\u{76c}\x05\u{15e}\u{b0}\x02\u{76b}\u{76a}\x03\x02\
	\x02\x02\u{76b}\u{76c}\x03\x02\x02\x02\u{76c}\u{76d}\x03\x02\x02\x02\u{76d}\
	\u{76e}\x07\x69\x02\x02\u{76e}\u{159}\x03\x02\x02\x02\u{76f}\u{77b}\x05\
	\u{158}\u{ad}\x02\u{770}\u{773}\x05\u{14c}\u{a7}\x02\u{771}\u{773}\x05\u{14e}\
	\u{a8}\x02\u{772}\u{770}\x03\x02\x02\x02\u{772}\u{771}\x03\x02\x02\x02\u{773}\
	\u{774}\x03\x02\x02\x02\u{774}\u{776}\x07\x68\x02\x02\u{775}\u{777}\x05\
	\u{15e}\u{b0}\x02\u{776}\u{775}\x03\x02\x02\x02\u{776}\u{777}\x03\x02\x02\
	\x02\u{777}\u{778}\x03\x02\x02\x02\u{778}\u{779}\x07\x69\x02\x02\u{779}\
	\u{77b}\x03\x02\x02\x02\u{77a}\u{76f}\x03\x02\x02\x02\u{77a}\u{772}\x03\
	\x02\x02\x02\u{77b}\u{15b}\x03\x02\x02\x02\u{77c}\u{77d}\x07\u{86}\x02\x02\
	\u{77d}\u{15d}\x03\x02\x02\x02\u{77e}\u{780}\x05\u{160}\u{b1}\x02\u{77f}\
	\u{781}\x07\u{85}\x02\x02\u{780}\u{77f}\x03\x02\x02\x02\u{780}\u{781}\x03\
	\x02\x02\x02\u{781}\u{789}\x03\x02\x02\x02\u{782}\u{783}\x07\x7c\x02\x02\
	\u{783}\u{785}\x05\u{160}\u{b1}\x02\u{784}\u{786}\x07\u{85}\x02\x02\u{785}\
	\u{784}\x03\x02\x02\x02\u{785}\u{786}\x03\x02\x02\x02\u{786}\u{788}\x03\
	\x02\x02\x02\u{787}\u{782}\x03\x02\x02\x02\u{788}\u{78b}\x03\x02\x02\x02\
	\u{789}\u{787}\x03\x02\x02\x02\u{789}\u{78a}\x03\x02\x02\x02\u{78a}\u{15f}\
	\x03\x02\x02\x02\u{78b}\u{789}\x03\x02\x02\x02\u{78c}\u{790}\x05\u{f8}\x7d\
	\x02\u{78d}\u{790}\x05\x5e\x30\x02\u{78e}\u{790}\x05\x06\x04\x02\u{78f}\
	\u{78c}\x03\x02\x02\x02\u{78f}\u{78d}\x03\x02\x02\x02\u{78f}\u{78e}\x03\
	\x02\x02\x02\u{790}\u{161}\x03\x02\x02\x02\u{791}\u{792}\x07\x4e\x02\x02\
	\u{792}\u{798}\x05\x0c\x07\x02\u{793}\u{799}\x07\u{86}\x02\x02\u{794}\u{796}\
	\x07\x46\x02\x02\u{795}\u{794}\x03\x02\x02\x02\u{795}\u{796}\x03\x02\x02\
	\x02\u{796}\u{797}\x03\x02\x02\x02\u{797}\u{799}\x05\u{158}\u{ad}\x02\u{798}\
	\u{793}\x03\x02\x02\x02\u{798}\u{795}\x03\x02\x02\x02\u{799}\u{163}\x03\
	\x02\x02\x02\u{79a}\u{79c}\x07\x26\x02\x02\u{79b}\u{79a}\x03\x02\x02\x02\
	\u{79b}\u{79c}\x03\x02\x02\x02\u{79c}\u{79d}\x03\x02\x02\x02\u{79d}\u{79e}\
	\x07\x46\x02\x02\u{79e}\u{79f}\x05\x7c\x3f\x02\u{79f}\u{165}\x03\x02\x02\
	\x02\u{7a0}\u{7a1}\x07\x46\x02\x02\u{7a1}\u{7a2}\x07\x68\x02\x02\u{7a2}\
	\u{7a3}\x07\x69\x02\x02\u{7a3}\u{7a4}\x05\x7c\x3f\x02\u{7a4}\u{167}\x03\
	\x02\x02\x02\u{7a5}\u{7a6}\x07\x4b\x02\x02\u{7a6}\u{7a7}\x05\x66\x34\x02\
	\u{7a7}\u{7a8}\x05\u{16c}\u{b7}\x02\u{7a8}\u{169}\x03\x02\x02\x02\u{7a9}\
	\u{7ab}\x07\x4b\x02\x02\u{7aa}\u{7ac}\x05\u{144}\u{a3}\x02\u{7ab}\u{7aa}\
	\x03\x02\x02\x02\u{7ab}\u{7ac}\x03\x02\x02\x02\u{7ac}\u{7ad}\x03\x02\x02\
	\x02\u{7ad}\u{7ae}\x05\x66\x34\x02\u{7ae}\u{7af}\x05\u{16c}\u{b7}\x02\u{7af}\
	\u{16b}\x03\x02\x02\x02\u{7b0}\u{7b2}\x05\u{16e}\u{b8}\x02\u{7b1}\u{7b0}\
	\x03\x02\x02\x02\u{7b2}\u{7b3}\x03\x02\x02\x02\u{7b3}\u{7b1}\x03\x02\x02\
	\x02\u{7b3}\u{7b4}\x03\x02\x02\x02\u{7b4}\u{16d}\x03\x02\x02\x02\u{7b5}\
	\u{7b6}\x07\x13\x02\x02\u{7b6}\u{7b7}\x07\x57\x02\x02\u{7b7}\u{7b8}\x05\
	\u{170}\u{b9}\x02\u{7b8}\u{7b9}\x07\x58\x02\x02\u{7b9}\u{7ba}\x05\x66\x34\
	\x02\u{7ba}\u{16f}\x03\x02\x02\x02\u{7bb}\u{7bd}\x05\u{ce}\x68\x02\u{7bc}\
	\u{7bb}\x03\x02\x02\x02\u{7bc}\u{7bd}\x03\x02\x02\x02\u{7bd}\u{7be}\x03\
	\x02\x02\x02\u{7be}\u{7c1}\x05\u{98}\x4d\x02\u{7bf}\u{7c2}\x05\u{e4}\x73\
	\x02\u{7c0}\u{7c2}\x05\u{fa}\x7e\x02\u{7c1}\u{7bf}\x03\x02\x02\x02\u{7c1}\
	\u{7c0}\x03\x02\x02\x02\u{7c1}\u{7c2}\x03\x02\x02\x02\u{7c2}\u{7c5}\x03\
	\x02\x02\x02\u{7c3}\u{7c5}\x07\u{85}\x02\x02\u{7c4}\u{7bc}\x03\x02\x02\x02\
	\u{7c4}\u{7c3}\x03\x02\x02\x02\u{7c5}\u{171}\x03\x02\x02\x02\u{7c6}\u{7c8}\
	\x07\x49\x02\x02\u{7c7}\u{7c9}\x05\x58\x2d\x02\u{7c8}\u{7c7}\x03\x02\x02\
	\x02\u{7c8}\u{7c9}\x03\x02\x02\x02\u{7c9}\u{173}\x03\x02\x02\x02\u{7ca}\
	\u{7cd}\x05\u{176}\u{bc}\x02\u{7cb}\u{7cd}\x05\u{17a}\u{be}\x02\u{7cc}\u{7ca}\
	\x03\x02\x02\x02\u{7cc}\u{7cb}\x03\x02\x02\x02\u{7cd}\u{175}\x03\x02\x02\
	\x02\u{7ce}\u{7cf}\x07\x49\x02\x02\u{7cf}\u{7d1}\x07\x57\x02\x02\u{7d0}\
	\u{7d2}\x05\u{178}\u{bd}\x02\u{7d1}\u{7d0}\x03\x02\x02\x02\u{7d1}\u{7d2}\
	\x03\x02\x02\x02\u{7d2}\u{7d3}\x03\x02\x02\x02\u{7d3}\u{7d4}\x07\x58\x02\
	\x02\u{7d4}\u{177}\x03\x02\x02\x02\u{7d5}\u{7d7}\x05\u{f8}\x7d\x02\u{7d6}\
	\u{7d8}\x07\u{85}\x02\x02\u{7d7}\u{7d6}\x03\x02\x02\x02\u{7d7}\u{7d8}\x03\
	\x02\x02\x02\u{7d8}\u{7e0}\x03\x02\x02\x02\u{7d9}\u{7da}\x07\x7c\x02\x02\
	\u{7da}\u{7dc}\x05\u{f8}\x7d\x02\u{7db}\u{7dd}\x07\u{85}\x02\x02\u{7dc}\
	\u{7db}\x03\x02\x02\x02\u{7dc}\u{7dd}\x03\x02\x02\x02\u{7dd}\u{7df}\x03\
	\x02\x02\x02\u{7de}\u{7d9}\x03\x02\x02\x02\u{7df}\u{7e2}\x03\x02\x02\x02\
	\u{7e0}\u{7de}\x03\x02\x02\x02\u{7e0}\u{7e1}\x03\x02\x02\x02\u{7e1}\u{179}\
	\x03\x02\x02\x02\u{7e2}\u{7e0}\x03\x02\x02\x02\u{7e3}\u{7e4}\x07\x34\x02\
	\x02\u{7e4}\u{7e5}\x07\x57\x02\x02\u{7e5}\u{7e6}\x05\x5e\x30\x02\u{7e6}\
	\u{7e7}\x07\x58\x02\x02\u{7e7}\u{7ea}\x03\x02\x02\x02\u{7e8}\u{7ea}\x07\
	\x34\x02\x02\u{7e9}\u{7e3}\x03\x02\x02\x02\u{7e9}\u{7e8}\x03\x02\x02\x02\
	\u{7ea}\u{17b}\x03\x02\x02\x02\u{7eb}\u{7ee}\x07\x33\x02\x02\u{7ec}\u{7ed}\
	\x07\x59\x02\x02\u{7ed}\u{7ef}\x07\x5a\x02\x02\u{7ee}\u{7ec}\x03\x02\x02\
	\x02\u{7ee}\u{7ef}\x03\x02\x02\x02\u{7ef}\u{81f}\x03\x02\x02\x02\u{7f0}\
	\u{7f3}\x07\x1e\x02\x02\u{7f1}\u{7f2}\x07\x59\x02\x02\u{7f2}\u{7f4}\x07\
	\x5a\x02\x02\u{7f3}\u{7f1}\x03\x02\x02\x02\u{7f3}\u{7f4}\x03\x02\x02\x02\
	\u{7f4}\u{81f}\x03\x02\x02\x02\u{7f5}\u{81f}\x07\x5d\x02\x02\u{7f6}\u{81f}\
	\x07\x5e\x02\x02\u{7f7}\u{81f}\x07\x5f\x02\x02\u{7f8}\u{81f}\x07\x60\x02\
	\x02\u{7f9}\u{81f}\x07\x61\x02\x02\u{7fa}\u{81f}\x07\x62\x02\x02\u{7fb}\
	\u{81f}\x07\x63\x02\x02\u{7fc}\u{81f}\x07\x64\x02\x02\u{7fd}\u{81f}\x07\
	\x65\x02\x02\u{7fe}\u{81f}\x07\x66\x02\x02\u{7ff}\u{81f}\x07\x67\x02\x02\
	\u{800}\u{81f}\x07\x69\x02\x02\u{801}\u{81f}\x07\x68\x02\x02\u{802}\u{81f}\
	\x07\x77\x02\x02\u{803}\u{81f}\x07\x6a\x02\x02\u{804}\u{81f}\x07\x6b\x02\
	\x02\u{805}\u{81f}\x07\x6c\x02\x02\u{806}\u{81f}\x07\x6e\x02\x02\u{807}\
	\u{81f}\x07\x6f\x02\x02\u{808}\u{81f}\x07\x70\x02\x02\u{809}\u{81f}\x07\
	\x71\x02\x02\u{80a}\u{80b}\x07\x68\x02\x02\u{80b}\u{81f}\x07\x68\x02\x02\
	\u{80c}\u{80d}\x07\x69\x02\x02\u{80d}\u{81f}\x07\x69\x02\x02\u{80e}\u{81f}\
	\x07\x73\x02\x02\u{80f}\u{81f}\x07\x72\x02\x02\u{810}\u{81f}\x07\x74\x02\
	\x02\u{811}\u{81f}\x07\x75\x02\x02\u{812}\u{81f}\x07\x76\x02\x02\u{813}\
	\u{81f}\x07\x78\x02\x02\u{814}\u{81f}\x07\x79\x02\x02\u{815}\u{81f}\x07\
	\x7a\x02\x02\u{816}\u{81f}\x07\x7b\x02\x02\u{817}\u{81f}\x07\x7c\x02\x02\
	\u{818}\u{81f}\x07\x7d\x02\x02\u{819}\u{81f}\x07\x7e\x02\x02\u{81a}\u{81b}\
	\x07\x57\x02\x02\u{81b}\u{81f}\x07\x58\x02\x02\u{81c}\u{81d}\x07\x59\x02\
	\x02\u{81d}\u{81f}\x07\x5a\x02\x02\u{81e}\u{7eb}\x03\x02\x02\x02\u{81e}\
	\u{7f0}\x03\x02\x02\x02\u{81e}\u{7f5}\x03\x02\x02\x02\u{81e}\u{7f6}\x03\
	\x02\x02\x02\u{81e}\u{7f7}\x03\x02\x02\x02\u{81e}\u{7f8}\x03\x02\x02\x02\
	\u{81e}\u{7f9}\x03\x02\x02\x02\u{81e}\u{7fa}\x03\x02\x02\x02\u{81e}\u{7fb}\
	\x03\x02\x02\x02\u{81e}\u{7fc}\x03\x02\x02\x02\u{81e}\u{7fd}\x03\x02\x02\
	\x02\u{81e}\u{7fe}\x03\x02\x02\x02\u{81e}\u{7ff}\x03\x02\x02\x02\u{81e}\
	\u{800}\x03\x02\x02\x02\u{81e}\u{801}\x03\x02\x02\x02\u{81e}\u{802}\x03\
	\x02\x02\x02\u{81e}\u{803}\x03\x02\x02\x02\u{81e}\u{804}\x03\x02\x02\x02\
	\u{81e}\u{805}\x03\x02\x02\x02\u{81e}\u{806}\x03\x02\x02\x02\u{81e}\u{807}\
	\x03\x02\x02\x02\u{81e}\u{808}\x03\x02\x02\x02\u{81e}\u{809}\x03\x02\x02\
	\x02\u{81e}\u{80a}\x03\x02\x02\x02\u{81e}\u{80c}\x03\x02\x02\x02\u{81e}\
	\u{80e}\x03\x02\x02\x02\u{81e}\u{80f}\x03\x02\x02\x02\u{81e}\u{810}\x03\
	\x02\x02\x02\u{81e}\u{811}\x03\x02\x02\x02\u{81e}\u{812}\x03\x02\x02\x02\
	\u{81e}\u{813}\x03\x02\x02\x02\u{81e}\u{814}\x03\x02\x02\x02\u{81e}\u{815}\
	\x03\x02\x02\x02\u{81e}\u{816}\x03\x02\x02\x02\u{81e}\u{817}\x03\x02\x02\
	\x02\u{81e}\u{818}\x03\x02\x02\x02\u{81e}\u{819}\x03\x02\x02\x02\u{81e}\
	\u{81a}\x03\x02\x02\x02\u{81e}\u{81c}\x03\x02\x02\x02\u{81f}\u{17d}\x03\
	\x02\x02\x02\u{820}\u{821}\x09\x18\x02\x02\u{821}\u{17f}\x03\x02\x02\x02\
	\u{128}\u{181}\u{188}\u{191}\u{195}\u{19e}\u{1a1}\u{1a5}\u{1ad}\u{1b4}\u{1b7}\
	\u{1bc}\u{1c1}\u{1c7}\u{1cf}\u{1d1}\u{1da}\u{1de}\u{1e2}\u{1e5}\u{1e9}\u{1ec}\
	\u{1f3}\u{1f7}\u{1fa}\u{1fd}\u{200}\u{206}\u{20a}\u{20e}\u{21c}\u{220}\u{226}\
	\u{22d}\u{233}\u{237}\u{23b}\u{23d}\u{245}\u{24a}\u{257}\u{25e}\u{26a}\u{274}\
	\u{279}\u{27d}\u{284}\u{287}\u{28f}\u{293}\u{296}\u{29d}\u{2a4}\u{2a8}\u{2ad}\
	\u{2b1}\u{2b4}\u{2b9}\u{2c8}\u{2cf}\u{2d7}\u{2df}\u{2e8}\u{2ef}\u{2f6}\u{2fe}\
	\u{306}\u{30e}\u{316}\u{31e}\u{326}\u{32f}\u{337}\u{340}\u{348}\u{350}\u{352}\
	\u{355}\u{35b}\u{361}\u{367}\u{36e}\u{377}\u{37f}\u{383}\u{38a}\u{38c}\u{3a0}\
	\u{3a4}\u{3aa}\u{3af}\u{3b3}\u{3b6}\u{3bd}\u{3c4}\u{3c8}\u{3d1}\u{3dc}\u{3e6}\
	\u{3eb}\u{3f2}\u{3f5}\u{3fa}\u{3ff}\u{414}\u{419}\u{41c}\u{427}\u{42d}\u{432}\
	\u{435}\u{43a}\u{43d}\u{444}\u{45b}\u{461}\u{467}\u{46d}\u{470}\u{476}\u{47a}\
	\u{47e}\u{481}\u{489}\u{48b}\u{491}\u{494}\u{497}\u{49a}\u{49e}\u{4a2}\u{4a8}\
	\u{4b2}\u{4b8}\u{4be}\u{4c3}\u{4c8}\u{4cc}\u{4d9}\u{4df}\u{4e3}\u{4e9}\u{4ee}\
	\u{4fd}\u{501}\u{506}\u{50b}\u{510}\u{516}\u{519}\u{522}\u{526}\u{52b}\u{52f}\
	\u{535}\u{53c}\u{54d}\u{54f}\u{556}\u{55b}\u{562}\u{566}\u{56a}\u{572}\u{578}\
	\u{57e}\u{582}\u{584}\u{588}\u{58d}\u{591}\u{594}\u{597}\u{59a}\u{59f}\u{5a3}\
	\u{5a6}\u{5aa}\u{5ad}\u{5af}\u{5b4}\u{5bb}\u{5c1}\u{5c5}\u{5cb}\u{5d1}\u{5d4}\
	\u{5d6}\u{5dc}\u{5e0}\u{5e6}\u{5ed}\u{5f1}\u{5f3}\u{5f7}\u{5fd}\u{609}\u{60d}\
	\u{60f}\u{613}\u{618}\u{61b}\u{622}\u{626}\u{62b}\u{62d}\u{631}\u{634}\u{637}\
	\u{63b}\u{640}\u{647}\u{64e}\u{653}\u{657}\u{65b}\u{660}\u{664}\u{66a}\u{66c}\
	\u{672}\u{677}\u{67d}\u{681}\u{683}\u{686}\u{68a}\u{68e}\u{690}\u{692}\u{695}\
	\u{6a1}\u{6a3}\u{6a6}\u{6a9}\u{6ac}\u{6b5}\u{6bc}\u{6c8}\u{6cc}\u{6cf}\u{6d3}\
	\u{6d8}\u{6e4}\u{6e9}\u{6ed}\u{6f1}\u{6f6}\u{6fb}\u{6ff}\u{702}\u{706}\u{711}\
	\u{715}\u{71c}\u{721}\u{725}\u{72b}\u{72f}\u{733}\u{73c}\u{749}\u{74e}\u{755}\
	\u{759}\u{75c}\u{75f}\u{762}\u{766}\u{76b}\u{772}\u{776}\u{77a}\u{780}\u{785}\
	\u{789}\u{78f}\u{795}\u{798}\u{79b}\u{7ab}\u{7b3}\u{7bc}\u{7c1}\u{7c4}\u{7c8}\
	\u{7cc}\u{7d1}\u{7d7}\u{7dc}\u{7e0}\u{7e9}\u{7ee}\u{7f3}\u{81e}";

