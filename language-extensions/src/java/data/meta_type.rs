use std::str::FromStr;

use serde::{
    Serialize, 
    Deserialize
};

use suzaku_codegen::MetaType;

pub struct MetaTypeConvertError {}

#[derive(Debug, PartialEq, Copy, Clone, Serialize, Deserialize, MetaType, Eq)]
pub enum MetaType {
    File,
    PackageDeclaration,
    ImportDeclaration,
    TypeDeclaration,
    Modifier,
    VariableModifier,
    ClassDeclaration,
    TypeParameters,
    TypeParameter,
    TypeBound,
    EnumDeclaration,
    EnumConstants,
    EnumConstant,
    EnumBodyDeclarations,
    InterfaceDeclaration,
    ClassBody,
    InterfaceBody,
    ClassBodyDeclaration,
    MemberDeclaration,
    MethodDeclaration,
    MethodBody,
    TypeTypeOrVoid,
    GenericMethodDeclaration,
    GenericConstructorDeclaration,
    ConstructorDeclaration,
    CompactConstructorDeclaration,
    FieldDeclaration,
    InterfaceBodyDeclaration,
    InterfaceMemberDeclaration,
    ConstDeclaration,
    ConstantDeclarator,
    InterfaceMethodDeclaration,
    InterfaceMethodModifier,
    GenericInterfaceMethodDeclaration,
    InterfaceCommonBodyDeclaration,
    VariableDeclarators,
    VariableDeclarator,
    VariableDeclaratorId,
    VariableInitializer,
    ArrayInitializer,
    ClassOrInterfaceType,
    TypeArgument,
    QualifiedNameList,
    FormalParameters,
    ReceiverParameter,
    FormalParameterList,
    FormalParameter,
    LastFormalParameter,
    LambdaLVTIList,
    LambdaLVTIParameter,
    QualifiedName,
    Literal,
    IntegerLiteral,
    FloatLiteral,
    AltAnnotationQualifiedName,
    Annotation,
    ElementValuePairs,
    ElementValuePair,
    ElementValue,
    ElementValueArrayInitializer,
    AnnotationTypeDeclaration,
    AnnotationTypeBody,
    AnnotationTypeElementDeclaration,
    AnnotationTypeElementRest,
    AnnotationMethodOrConstantRest,
    AnnotationMethodRest,
    AnnotationConstantRest,
    DefaultValue,
    ModuleDeclaration,
    ModuleBody,
    ModuleDirective,
    RequiresModifier,
    RecordDeclaration,
    RecordHeader,
    RecordComponentList,
    RecordComponent,
    RecordBody,
    Block,
    BlockStatement,
    LocalVariableDeclaration,
    Identifier,
    TypeIdentifier,
    LocalTypeDeclaration,
    Statement,
    CatchClause,
    CatchType,
    FinallyBlock,
    ResourceSpecification,
    Resources,
    Resource,
    SwitchBlockStatementGroup,
    SwitchLabel,
    ForControl,
    ForInit,
    EnhancedForControl,
    ParExpression,
    ExpressionList,
    MethodCall,
    Expression,
    Pattern,
    LambdaExpression,
    LambdaParameters,
    LambdaBody,
    Primary,
    SwitchExpression,
    SwitchLabeledRule,
    GuardedPattern,
    SwitchRuleOutcome,
    ClassType,
    Creator,
    CreatedName,
    InnerCreator,
    ArrayCreatorRest,
    ClassCreatorRest,
    ExplicitGenericInvocation,
    TypeArgumentsOrDiamond,
    NonWildcardTypeArgumentsOrDiamond,
    NonWildcardTypeArguments,
    TypeList,
    TypeType,
    PrimitiveType,
    TypeArguments,
    SuperSuffix,
    ExplicitGenericInvocationSuffix,
    Arguments,

    Operator,
    Keyword,
    Separator,
}

impl ToString for MetaType {
    fn to_string(&self) -> String {
        format!("{:?}", self)
    }
}

impl FromStr for MetaType {
    type Err = MetaTypeConvertError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "file" => Ok(MetaType::File),
            "packagedeclaration" => Ok(MetaType::PackageDeclaration),
            "importdeclaration" => Ok(MetaType::ImportDeclaration),
            "typedeclaration" => Ok(MetaType::TypeDeclaration),
            "modifier" => Ok(MetaType::Modifier),
            "variablemodifier" => Ok(MetaType::VariableModifier),
            "classdeclaration" => Ok(MetaType::ClassDeclaration),
            "typeparameters" => Ok(MetaType::TypeParameters),
            "typeparameter" => Ok(MetaType::TypeParameter),
            "typebound" => Ok(MetaType::TypeBound),
            "enumdeclaration" => Ok(MetaType::EnumDeclaration),
            "enumconstants" => Ok(MetaType::EnumConstants),
            "enumconstant" => Ok(MetaType::EnumConstant),
            "enumbodydeclarations" => Ok(MetaType::EnumBodyDeclarations),
            "interfacedeclaration" => Ok(MetaType::InterfaceDeclaration),
            "classbody" => Ok(MetaType::ClassBody),
            "interfacebody" => Ok(MetaType::InterfaceBody),
            "classbodydeclaration" => Ok(MetaType::ClassBodyDeclaration),
            "memberdeclaration" => Ok(MetaType::MemberDeclaration),
            "methoddeclaration" => Ok(MetaType::MethodDeclaration),
            "methodbody" => Ok(MetaType::MethodBody),
            "typetypeorvoid" => Ok(MetaType::TypeTypeOrVoid),
            "genericmethoddeclaration" => Ok(MetaType::GenericMethodDeclaration),
            "genericconstructordeclaration" => Ok(MetaType::GenericConstructorDeclaration),
            "constructordeclaration" => Ok(MetaType::ConstructorDeclaration),
            "compactconstructordeclaration" => Ok(MetaType::CompactConstructorDeclaration),
            "fielddeclaration" => Ok(MetaType::FieldDeclaration),
            "interfacebodydeclaration" => Ok(MetaType::InterfaceBodyDeclaration),
            "interfacememberdeclaration" => Ok(MetaType::InterfaceMemberDeclaration),
            "constdeclaration" => Ok(MetaType::ConstDeclaration),
            "constantdeclarator" => Ok(MetaType::ConstantDeclarator),
            "interfacemethoddeclaration" => Ok(MetaType::InterfaceMethodDeclaration),
            "interfacemethodmodifier" => Ok(MetaType::InterfaceMethodModifier),
            "genericinterfacemethoddeclaration" => Ok(MetaType::GenericInterfaceMethodDeclaration),
            "interfacecommonbodydeclaration" => Ok(MetaType::InterfaceCommonBodyDeclaration),
            "variabledeclarators" => Ok(MetaType::VariableDeclarators),
            "variabledeclarator" => Ok(MetaType::VariableDeclarator),
            "variabledeclaratorid" => Ok(MetaType::VariableDeclaratorId),
            "variableinitializer" => Ok(MetaType::VariableInitializer),
            "arrayinitializer" => Ok(MetaType::ArrayInitializer),
            "classorinterfacetype" => Ok(MetaType::ClassOrInterfaceType),
            "typeargument" => Ok(MetaType::TypeArgument),
            "qualifiednamelist" => Ok(MetaType::QualifiedNameList),
            "formalparameters" => Ok(MetaType::FormalParameters),
            "receiverparameter" => Ok(MetaType::ReceiverParameter),
            "formalparameterlist" => Ok(MetaType::FormalParameterList),
            "formalparameter" => Ok(MetaType::FormalParameter),
            "lastformalparameter" => Ok(MetaType::LastFormalParameter),
            "lambdalvtilist" => Ok(MetaType::LambdaLVTIList),
            "lambdalvtiparameter" => Ok(MetaType::LambdaLVTIParameter),
            "qualifiedname" => Ok(MetaType::QualifiedName),
            "literal" => Ok(MetaType::Literal),
            "integerliteral" => Ok(MetaType::IntegerLiteral),
            "floatliteral" => Ok(MetaType::FloatLiteral),
            "altannotationqualifiedname" => Ok(MetaType::AltAnnotationQualifiedName),
            "annotation" => Ok(MetaType::Annotation),
            "elementvaluepairs" => Ok(MetaType::ElementValuePairs),
            "elementvaluepair" => Ok(MetaType::ElementValuePair),
            "elementvalue" => Ok(MetaType::ElementValue),
            "elementvaluearrayinitializer" => Ok(MetaType::ElementValueArrayInitializer),
            "annotationtypedeclaration" => Ok(MetaType::AnnotationTypeDeclaration),
            "annotationtypebody" => Ok(MetaType::AnnotationTypeBody),
            "annotationtypeelementdeclaration" => Ok(MetaType::AnnotationTypeElementDeclaration),
            "annotationtypeelementrest" => Ok(MetaType::AnnotationTypeElementRest),
            "annotationmethodorconstantrest" => Ok(MetaType::AnnotationMethodOrConstantRest),
            "annotationmethodrest" => Ok(MetaType::AnnotationMethodRest),
            "annotationconstantrest" => Ok(MetaType::AnnotationConstantRest),
            "defaultvalue" => Ok(MetaType::DefaultValue),
            "moduledeclaration" => Ok(MetaType::ModuleDeclaration),
            "modulebody" => Ok(MetaType::ModuleBody),
            "moduledirective" => Ok(MetaType::ModuleDirective),
            "requiresmodifier" => Ok(MetaType::RequiresModifier),
            "recorddeclaration" => Ok(MetaType::RecordDeclaration),
            "recordheader" => Ok(MetaType::RecordHeader),
            "recordcomponentlist" => Ok(MetaType::RecordComponentList),
            "recordcomponent" => Ok(MetaType::RecordComponent),
            "recordbody" => Ok(MetaType::RecordBody),
            "block" => Ok(MetaType::Block),
            "blockstatement" => Ok(MetaType::BlockStatement),
            "localvariabledeclaration" => Ok(MetaType::LocalVariableDeclaration),
            "identifier" => Ok(MetaType::Identifier),
            "typeidentifier" => Ok(MetaType::TypeIdentifier),
            "localtypedeclaration" => Ok(MetaType::LocalTypeDeclaration),
            "statement" => Ok(MetaType::Statement),
            "catchclause" => Ok(MetaType::CatchClause),
            "catchtype" => Ok(MetaType::CatchType),
            "finallyblock" => Ok(MetaType::FinallyBlock),
            "resourcespecification" => Ok(MetaType::ResourceSpecification),
            "resources" => Ok(MetaType::Resources),
            "resource" => Ok(MetaType::Resource),
            "switchblockstatementgroup" => Ok(MetaType::SwitchBlockStatementGroup),
            "switchlabel" => Ok(MetaType::SwitchLabel),
            "forcontrol" => Ok(MetaType::ForControl),
            "forinit" => Ok(MetaType::ForInit),
            "enhancedforcontrol" => Ok(MetaType::EnhancedForControl),
            "parexpression" => Ok(MetaType::ParExpression),
            "expressionlist" => Ok(MetaType::ExpressionList),
            "methodcall" => Ok(MetaType::MethodCall),
            "expression" => Ok(MetaType::Expression),
            "pattern" => Ok(MetaType::Pattern),
            "lambdaexpression" => Ok(MetaType::LambdaExpression),
            "lambdaparameters" => Ok(MetaType::LambdaParameters),
            "lambdabody" => Ok(MetaType::LambdaBody),
            "primary" => Ok(MetaType::Primary),
            "switchexpression" => Ok(MetaType::SwitchExpression),
            "switchlabeledrule" => Ok(MetaType::SwitchLabeledRule),
            "guardedpattern" => Ok(MetaType::GuardedPattern),
            "switchruleoutcome" => Ok(MetaType::SwitchRuleOutcome),
            "classtype" => Ok(MetaType::ClassType),
            "creator" => Ok(MetaType::Creator),
            "createdname" => Ok(MetaType::CreatedName),
            "innercreator" => Ok(MetaType::InnerCreator),
            "arraycreatorrest" => Ok(MetaType::ArrayCreatorRest),
            "classcreatorrest" => Ok(MetaType::ClassCreatorRest),
            "explicitgenericinvocation" => Ok(MetaType::ExplicitGenericInvocation),
            "typeargumentsordiamond" => Ok(MetaType::TypeArgumentsOrDiamond),
            "nonwildcardtypeargumentsordiamond" => Ok(MetaType::NonWildcardTypeArgumentsOrDiamond),
            "nonwildcardtypearguments" => Ok(MetaType::NonWildcardTypeArguments),
            "typelist" => Ok(MetaType::TypeList),
            "typetype" => Ok(MetaType::TypeType),
            "primitivetype" => Ok(MetaType::PrimitiveType),
            "typearguments" => Ok(MetaType::TypeArguments),
            "supersuffix" => Ok(MetaType::SuperSuffix),
            "explicitgenericinvocationsuffix" => Ok(MetaType::ExplicitGenericInvocationSuffix),
            "arguments" => Ok(MetaType::Arguments),
            "operator" => Ok(MetaType::Operator),
            "keyword" => Ok(MetaType::Keyword),
            _ => Err(MetaTypeConvertError{})
        }
    }
}