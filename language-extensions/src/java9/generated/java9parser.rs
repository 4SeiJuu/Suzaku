// Generated from ./core/src/languages/java/generated/Java9Parser.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
use antlr_rust::PredictionContextCache;
use antlr_rust::parser::{Parser, BaseParser, ParserRecog, ParserNodeType};
use antlr_rust::token_stream::TokenStream;
use antlr_rust::TokenSource;
use antlr_rust::parser_atn_simulator::ParserATNSimulator;
use antlr_rust::errors::*;
use antlr_rust::rule_context::{BaseRuleContext, CustomRuleContext, RuleContext};
use antlr_rust::recognizer::{Recognizer,Actions};
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::atn::{ATN, INVALID_ALT};
use antlr_rust::error_strategy::{ErrorStrategy, DefaultErrorStrategy};
use antlr_rust::parser_rule_context::{BaseParserRuleContext, ParserRuleContext,cast,cast_mut};
use antlr_rust::tree::*;
use antlr_rust::token::{TOKEN_EOF,OwningToken,Token};
use antlr_rust::int_stream::EOF;
use antlr_rust::vocabulary::{Vocabulary,VocabularyImpl};
use antlr_rust::token_factory::{CommonTokenFactory,TokenFactory, TokenAware};
use super::java9parserlistener::*;
use antlr_rust::lazy_static;
use antlr_rust::{TidAble,TidExt};

use std::marker::PhantomData;
use std::sync::Arc;
use std::rc::Rc;
use std::convert::TryFrom;
use std::cell::RefCell;
use std::ops::{DerefMut, Deref};
use std::borrow::{Borrow,BorrowMut};
use std::any::{Any,TypeId};

		pub const ABSTRACT:isize=1; 
		pub const ASSERT:isize=2; 
		pub const BOOLEAN:isize=3; 
		pub const BREAK:isize=4; 
		pub const BYTE:isize=5; 
		pub const CASE:isize=6; 
		pub const CATCH:isize=7; 
		pub const CHAR:isize=8; 
		pub const CLASS:isize=9; 
		pub const CONST:isize=10; 
		pub const CONTINUE:isize=11; 
		pub const DEFAULT:isize=12; 
		pub const DO:isize=13; 
		pub const DOUBLE:isize=14; 
		pub const ELSE:isize=15; 
		pub const ENUM:isize=16; 
		pub const EXPORTS:isize=17; 
		pub const EXTENDS:isize=18; 
		pub const FINAL:isize=19; 
		pub const FINALLY:isize=20; 
		pub const FLOAT:isize=21; 
		pub const FOR:isize=22; 
		pub const IF:isize=23; 
		pub const GOTO:isize=24; 
		pub const IMPLEMENTS:isize=25; 
		pub const IMPORT:isize=26; 
		pub const INSTANCEOF:isize=27; 
		pub const INT:isize=28; 
		pub const INTERFACE:isize=29; 
		pub const LONG:isize=30; 
		pub const MODULE:isize=31; 
		pub const NATIVE:isize=32; 
		pub const NEW:isize=33; 
		pub const OPEN:isize=34; 
		pub const OPERNS:isize=35; 
		pub const PACKAGE:isize=36; 
		pub const PRIVATE:isize=37; 
		pub const PROTECTED:isize=38; 
		pub const PROVIDES:isize=39; 
		pub const PUBLIC:isize=40; 
		pub const REQUIRES:isize=41; 
		pub const RETURN:isize=42; 
		pub const SHORT:isize=43; 
		pub const STATIC:isize=44; 
		pub const STRICTFP:isize=45; 
		pub const SUPER:isize=46; 
		pub const SWITCH:isize=47; 
		pub const SYNCHRONIZED:isize=48; 
		pub const THIS:isize=49; 
		pub const THROW:isize=50; 
		pub const THROWS:isize=51; 
		pub const TO:isize=52; 
		pub const TRANSIENT:isize=53; 
		pub const TRANSITIVE:isize=54; 
		pub const TRY:isize=55; 
		pub const USES:isize=56; 
		pub const VOID:isize=57; 
		pub const VOLATILE:isize=58; 
		pub const WHILE:isize=59; 
		pub const WITH:isize=60; 
		pub const UNDER_SCORE:isize=61; 
		pub const IntegerLiteral:isize=62; 
		pub const FloatingPointLiteral:isize=63; 
		pub const BooleanLiteral:isize=64; 
		pub const CharacterLiteral:isize=65; 
		pub const StringLiteral:isize=66; 
		pub const NullLiteral:isize=67; 
		pub const LPAREN:isize=68; 
		pub const RPAREN:isize=69; 
		pub const LBRACE:isize=70; 
		pub const RBRACE:isize=71; 
		pub const LBRACK:isize=72; 
		pub const RBRACK:isize=73; 
		pub const SEMI:isize=74; 
		pub const COMMA:isize=75; 
		pub const DOT:isize=76; 
		pub const ELLIPSIS:isize=77; 
		pub const AT:isize=78; 
		pub const COLONCOLON:isize=79; 
		pub const ASSIGN:isize=80; 
		pub const GT:isize=81; 
		pub const LT:isize=82; 
		pub const BANG:isize=83; 
		pub const TILDE:isize=84; 
		pub const QUESTION:isize=85; 
		pub const COLON:isize=86; 
		pub const ARROW:isize=87; 
		pub const EQUAL:isize=88; 
		pub const LE:isize=89; 
		pub const GE:isize=90; 
		pub const NOTEQUAL:isize=91; 
		pub const AND:isize=92; 
		pub const OR:isize=93; 
		pub const INC:isize=94; 
		pub const DEC:isize=95; 
		pub const ADD:isize=96; 
		pub const SUB:isize=97; 
		pub const MUL:isize=98; 
		pub const DIV:isize=99; 
		pub const BITAND:isize=100; 
		pub const BITOR:isize=101; 
		pub const CARET:isize=102; 
		pub const MOD:isize=103; 
		pub const ADD_ASSIGN:isize=104; 
		pub const SUB_ASSIGN:isize=105; 
		pub const MUL_ASSIGN:isize=106; 
		pub const DIV_ASSIGN:isize=107; 
		pub const AND_ASSIGN:isize=108; 
		pub const OR_ASSIGN:isize=109; 
		pub const XOR_ASSIGN:isize=110; 
		pub const MOD_ASSIGN:isize=111; 
		pub const LSHIFT_ASSIGN:isize=112; 
		pub const RSHIFT_ASSIGN:isize=113; 
		pub const URSHIFT_ASSIGN:isize=114; 
		pub const Identifier:isize=115; 
		pub const WS:isize=116; 
		pub const COMMENT:isize=117; 
		pub const LINE_COMMENT:isize=118;
	pub const RULE_literal:usize = 0; 
	pub const RULE_primitiveType:usize = 1; 
	pub const RULE_numericType:usize = 2; 
	pub const RULE_integralType:usize = 3; 
	pub const RULE_floatingPointType:usize = 4; 
	pub const RULE_referenceType:usize = 5; 
	pub const RULE_classOrInterfaceType:usize = 6; 
	pub const RULE_classType:usize = 7; 
	pub const RULE_classType_lf_classOrInterfaceType:usize = 8; 
	pub const RULE_classType_lfno_classOrInterfaceType:usize = 9; 
	pub const RULE_interfaceType:usize = 10; 
	pub const RULE_interfaceType_lf_classOrInterfaceType:usize = 11; 
	pub const RULE_interfaceType_lfno_classOrInterfaceType:usize = 12; 
	pub const RULE_typeVariable:usize = 13; 
	pub const RULE_arrayType:usize = 14; 
	pub const RULE_dims:usize = 15; 
	pub const RULE_typeParameter:usize = 16; 
	pub const RULE_typeParameterModifier:usize = 17; 
	pub const RULE_typeBound:usize = 18; 
	pub const RULE_additionalBound:usize = 19; 
	pub const RULE_typeArguments:usize = 20; 
	pub const RULE_typeArgumentList:usize = 21; 
	pub const RULE_typeArgument:usize = 22; 
	pub const RULE_wildcard:usize = 23; 
	pub const RULE_wildcardBounds:usize = 24; 
	pub const RULE_moduleName:usize = 25; 
	pub const RULE_packageName:usize = 26; 
	pub const RULE_typeName:usize = 27; 
	pub const RULE_packageOrTypeName:usize = 28; 
	pub const RULE_expressionName:usize = 29; 
	pub const RULE_methodName:usize = 30; 
	pub const RULE_ambiguousName:usize = 31; 
	pub const RULE_compilationUnit:usize = 32; 
	pub const RULE_ordinaryCompilation:usize = 33; 
	pub const RULE_modularCompilation:usize = 34; 
	pub const RULE_packageDeclaration:usize = 35; 
	pub const RULE_packageModifier:usize = 36; 
	pub const RULE_importDeclaration:usize = 37; 
	pub const RULE_singleTypeImportDeclaration:usize = 38; 
	pub const RULE_typeImportOnDemandDeclaration:usize = 39; 
	pub const RULE_singleStaticImportDeclaration:usize = 40; 
	pub const RULE_staticImportOnDemandDeclaration:usize = 41; 
	pub const RULE_typeDeclaration:usize = 42; 
	pub const RULE_moduleDeclaration:usize = 43; 
	pub const RULE_moduleDirective:usize = 44; 
	pub const RULE_requiresModifier:usize = 45; 
	pub const RULE_classDeclaration:usize = 46; 
	pub const RULE_normalClassDeclaration:usize = 47; 
	pub const RULE_classModifier:usize = 48; 
	pub const RULE_typeParameters:usize = 49; 
	pub const RULE_typeParameterList:usize = 50; 
	pub const RULE_superclass:usize = 51; 
	pub const RULE_superinterfaces:usize = 52; 
	pub const RULE_interfaceTypeList:usize = 53; 
	pub const RULE_classBody:usize = 54; 
	pub const RULE_classBodyDeclaration:usize = 55; 
	pub const RULE_classMemberDeclaration:usize = 56; 
	pub const RULE_fieldDeclaration:usize = 57; 
	pub const RULE_fieldModifier:usize = 58; 
	pub const RULE_variableDeclaratorList:usize = 59; 
	pub const RULE_variableDeclarator:usize = 60; 
	pub const RULE_variableDeclaratorId:usize = 61; 
	pub const RULE_variableInitializer:usize = 62; 
	pub const RULE_unannType:usize = 63; 
	pub const RULE_unannPrimitiveType:usize = 64; 
	pub const RULE_unannReferenceType:usize = 65; 
	pub const RULE_unannClassOrInterfaceType:usize = 66; 
	pub const RULE_unannClassType:usize = 67; 
	pub const RULE_unannClassType_lf_unannClassOrInterfaceType:usize = 68; 
	pub const RULE_unannClassType_lfno_unannClassOrInterfaceType:usize = 69; 
	pub const RULE_unannInterfaceType:usize = 70; 
	pub const RULE_unannInterfaceType_lf_unannClassOrInterfaceType:usize = 71; 
	pub const RULE_unannInterfaceType_lfno_unannClassOrInterfaceType:usize = 72; 
	pub const RULE_unannTypeVariable:usize = 73; 
	pub const RULE_unannArrayType:usize = 74; 
	pub const RULE_methodDeclaration:usize = 75; 
	pub const RULE_methodModifier:usize = 76; 
	pub const RULE_methodHeader:usize = 77; 
	pub const RULE_result:usize = 78; 
	pub const RULE_methodDeclarator:usize = 79; 
	pub const RULE_formalParameterList:usize = 80; 
	pub const RULE_formalParameters:usize = 81; 
	pub const RULE_formalParameter:usize = 82; 
	pub const RULE_variableModifier:usize = 83; 
	pub const RULE_lastFormalParameter:usize = 84; 
	pub const RULE_receiverParameter:usize = 85; 
	pub const RULE_throws_:usize = 86; 
	pub const RULE_exceptionTypeList:usize = 87; 
	pub const RULE_exceptionType:usize = 88; 
	pub const RULE_methodBody:usize = 89; 
	pub const RULE_instanceInitializer:usize = 90; 
	pub const RULE_staticInitializer:usize = 91; 
	pub const RULE_constructorDeclaration:usize = 92; 
	pub const RULE_constructorModifier:usize = 93; 
	pub const RULE_constructorDeclarator:usize = 94; 
	pub const RULE_simpleTypeName:usize = 95; 
	pub const RULE_constructorBody:usize = 96; 
	pub const RULE_explicitConstructorInvocation:usize = 97; 
	pub const RULE_enumDeclaration:usize = 98; 
	pub const RULE_enumBody:usize = 99; 
	pub const RULE_enumConstantList:usize = 100; 
	pub const RULE_enumConstant:usize = 101; 
	pub const RULE_enumConstantModifier:usize = 102; 
	pub const RULE_enumBodyDeclarations:usize = 103; 
	pub const RULE_interfaceDeclaration:usize = 104; 
	pub const RULE_normalInterfaceDeclaration:usize = 105; 
	pub const RULE_interfaceModifier:usize = 106; 
	pub const RULE_extendsInterfaces:usize = 107; 
	pub const RULE_interfaceBody:usize = 108; 
	pub const RULE_interfaceMemberDeclaration:usize = 109; 
	pub const RULE_constantDeclaration:usize = 110; 
	pub const RULE_constantModifier:usize = 111; 
	pub const RULE_interfaceMethodDeclaration:usize = 112; 
	pub const RULE_interfaceMethodModifier:usize = 113; 
	pub const RULE_annotationTypeDeclaration:usize = 114; 
	pub const RULE_annotationTypeBody:usize = 115; 
	pub const RULE_annotationTypeMemberDeclaration:usize = 116; 
	pub const RULE_annotationTypeElementDeclaration:usize = 117; 
	pub const RULE_annotationTypeElementModifier:usize = 118; 
	pub const RULE_defaultValue:usize = 119; 
	pub const RULE_annotation:usize = 120; 
	pub const RULE_normalAnnotation:usize = 121; 
	pub const RULE_elementValuePairList:usize = 122; 
	pub const RULE_elementValuePair:usize = 123; 
	pub const RULE_elementValue:usize = 124; 
	pub const RULE_elementValueArrayInitializer:usize = 125; 
	pub const RULE_elementValueList:usize = 126; 
	pub const RULE_markerAnnotation:usize = 127; 
	pub const RULE_singleElementAnnotation:usize = 128; 
	pub const RULE_arrayInitializer:usize = 129; 
	pub const RULE_variableInitializerList:usize = 130; 
	pub const RULE_block:usize = 131; 
	pub const RULE_blockStatements:usize = 132; 
	pub const RULE_blockStatement:usize = 133; 
	pub const RULE_localVariableDeclarationStatement:usize = 134; 
	pub const RULE_localVariableDeclaration:usize = 135; 
	pub const RULE_statement:usize = 136; 
	pub const RULE_statementNoShortIf:usize = 137; 
	pub const RULE_statementWithoutTrailingSubstatement:usize = 138; 
	pub const RULE_emptyStatement_:usize = 139; 
	pub const RULE_labeledStatement:usize = 140; 
	pub const RULE_labeledStatementNoShortIf:usize = 141; 
	pub const RULE_expressionStatement:usize = 142; 
	pub const RULE_statementExpression:usize = 143; 
	pub const RULE_ifThenStatement:usize = 144; 
	pub const RULE_ifThenElseStatement:usize = 145; 
	pub const RULE_ifThenElseStatementNoShortIf:usize = 146; 
	pub const RULE_assertStatement:usize = 147; 
	pub const RULE_switchStatement:usize = 148; 
	pub const RULE_switchBlock:usize = 149; 
	pub const RULE_switchBlockStatementGroup:usize = 150; 
	pub const RULE_switchLabels:usize = 151; 
	pub const RULE_switchLabel:usize = 152; 
	pub const RULE_enumConstantName:usize = 153; 
	pub const RULE_whileStatement:usize = 154; 
	pub const RULE_whileStatementNoShortIf:usize = 155; 
	pub const RULE_doStatement:usize = 156; 
	pub const RULE_forStatement:usize = 157; 
	pub const RULE_forStatementNoShortIf:usize = 158; 
	pub const RULE_basicForStatement:usize = 159; 
	pub const RULE_basicForStatementNoShortIf:usize = 160; 
	pub const RULE_forInit:usize = 161; 
	pub const RULE_forUpdate:usize = 162; 
	pub const RULE_statementExpressionList:usize = 163; 
	pub const RULE_enhancedForStatement:usize = 164; 
	pub const RULE_enhancedForStatementNoShortIf:usize = 165; 
	pub const RULE_breakStatement:usize = 166; 
	pub const RULE_continueStatement:usize = 167; 
	pub const RULE_returnStatement:usize = 168; 
	pub const RULE_throwStatement:usize = 169; 
	pub const RULE_synchronizedStatement:usize = 170; 
	pub const RULE_tryStatement:usize = 171; 
	pub const RULE_catches:usize = 172; 
	pub const RULE_catchClause:usize = 173; 
	pub const RULE_catchFormalParameter:usize = 174; 
	pub const RULE_catchType:usize = 175; 
	pub const RULE_finally_:usize = 176; 
	pub const RULE_tryWithResourcesStatement:usize = 177; 
	pub const RULE_resourceSpecification:usize = 178; 
	pub const RULE_resourceList:usize = 179; 
	pub const RULE_resource:usize = 180; 
	pub const RULE_variableAccess:usize = 181; 
	pub const RULE_primary:usize = 182; 
	pub const RULE_primaryNoNewArray:usize = 183; 
	pub const RULE_primaryNoNewArray_lf_arrayAccess:usize = 184; 
	pub const RULE_primaryNoNewArray_lfno_arrayAccess:usize = 185; 
	pub const RULE_primaryNoNewArray_lf_primary:usize = 186; 
	pub const RULE_primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary:usize = 187; 
	pub const RULE_primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary:usize = 188; 
	pub const RULE_primaryNoNewArray_lfno_primary:usize = 189; 
	pub const RULE_primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary:usize = 190; 
	pub const RULE_primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary:usize = 191; 
	pub const RULE_classLiteral:usize = 192; 
	pub const RULE_classInstanceCreationExpression:usize = 193; 
	pub const RULE_classInstanceCreationExpression_lf_primary:usize = 194; 
	pub const RULE_classInstanceCreationExpression_lfno_primary:usize = 195; 
	pub const RULE_typeArgumentsOrDiamond:usize = 196; 
	pub const RULE_fieldAccess:usize = 197; 
	pub const RULE_fieldAccess_lf_primary:usize = 198; 
	pub const RULE_fieldAccess_lfno_primary:usize = 199; 
	pub const RULE_arrayAccess:usize = 200; 
	pub const RULE_arrayAccess_lf_primary:usize = 201; 
	pub const RULE_arrayAccess_lfno_primary:usize = 202; 
	pub const RULE_methodInvocation:usize = 203; 
	pub const RULE_methodInvocation_lf_primary:usize = 204; 
	pub const RULE_methodInvocation_lfno_primary:usize = 205; 
	pub const RULE_argumentList:usize = 206; 
	pub const RULE_methodReference:usize = 207; 
	pub const RULE_methodReference_lf_primary:usize = 208; 
	pub const RULE_methodReference_lfno_primary:usize = 209; 
	pub const RULE_arrayCreationExpression:usize = 210; 
	pub const RULE_dimExprs:usize = 211; 
	pub const RULE_dimExpr:usize = 212; 
	pub const RULE_constantExpression:usize = 213; 
	pub const RULE_expression:usize = 214; 
	pub const RULE_lambdaExpression:usize = 215; 
	pub const RULE_lambdaParameters:usize = 216; 
	pub const RULE_inferredFormalParameterList:usize = 217; 
	pub const RULE_lambdaBody:usize = 218; 
	pub const RULE_assignmentExpression:usize = 219; 
	pub const RULE_assignment:usize = 220; 
	pub const RULE_leftHandSide:usize = 221; 
	pub const RULE_assignmentOperator:usize = 222; 
	pub const RULE_conditionalExpression:usize = 223; 
	pub const RULE_conditionalOrExpression:usize = 224; 
	pub const RULE_conditionalAndExpression:usize = 225; 
	pub const RULE_inclusiveOrExpression:usize = 226; 
	pub const RULE_exclusiveOrExpression:usize = 227; 
	pub const RULE_andExpression:usize = 228; 
	pub const RULE_equalityExpression:usize = 229; 
	pub const RULE_relationalExpression:usize = 230; 
	pub const RULE_shiftExpression:usize = 231; 
	pub const RULE_additiveExpression:usize = 232; 
	pub const RULE_multiplicativeExpression:usize = 233; 
	pub const RULE_unaryExpression:usize = 234; 
	pub const RULE_preIncrementExpression:usize = 235; 
	pub const RULE_preDecrementExpression:usize = 236; 
	pub const RULE_unaryExpressionNotPlusMinus:usize = 237; 
	pub const RULE_postfixExpression:usize = 238; 
	pub const RULE_postIncrementExpression:usize = 239; 
	pub const RULE_postIncrementExpression_lf_postfixExpression:usize = 240; 
	pub const RULE_postDecrementExpression:usize = 241; 
	pub const RULE_postDecrementExpression_lf_postfixExpression:usize = 242; 
	pub const RULE_castExpression:usize = 243; 
	pub const RULE_identifier:usize = 244;
	pub const ruleNames: [&'static str; 245] =  [
		"literal", "primitiveType", "numericType", "integralType", "floatingPointType", 
		"referenceType", "classOrInterfaceType", "classType", "classType_lf_classOrInterfaceType", 
		"classType_lfno_classOrInterfaceType", "interfaceType", "interfaceType_lf_classOrInterfaceType", 
		"interfaceType_lfno_classOrInterfaceType", "typeVariable", "arrayType", 
		"dims", "typeParameter", "typeParameterModifier", "typeBound", "additionalBound", 
		"typeArguments", "typeArgumentList", "typeArgument", "wildcard", "wildcardBounds", 
		"moduleName", "packageName", "typeName", "packageOrTypeName", "expressionName", 
		"methodName", "ambiguousName", "compilationUnit", "ordinaryCompilation", 
		"modularCompilation", "packageDeclaration", "packageModifier", "importDeclaration", 
		"singleTypeImportDeclaration", "typeImportOnDemandDeclaration", "singleStaticImportDeclaration", 
		"staticImportOnDemandDeclaration", "typeDeclaration", "moduleDeclaration", 
		"moduleDirective", "requiresModifier", "classDeclaration", "normalClassDeclaration", 
		"classModifier", "typeParameters", "typeParameterList", "superclass", 
		"superinterfaces", "interfaceTypeList", "classBody", "classBodyDeclaration", 
		"classMemberDeclaration", "fieldDeclaration", "fieldModifier", "variableDeclaratorList", 
		"variableDeclarator", "variableDeclaratorId", "variableInitializer", "unannType", 
		"unannPrimitiveType", "unannReferenceType", "unannClassOrInterfaceType", 
		"unannClassType", "unannClassType_lf_unannClassOrInterfaceType", "unannClassType_lfno_unannClassOrInterfaceType", 
		"unannInterfaceType", "unannInterfaceType_lf_unannClassOrInterfaceType", 
		"unannInterfaceType_lfno_unannClassOrInterfaceType", "unannTypeVariable", 
		"unannArrayType", "methodDeclaration", "methodModifier", "methodHeader", 
		"result", "methodDeclarator", "formalParameterList", "formalParameters", 
		"formalParameter", "variableModifier", "lastFormalParameter", "receiverParameter", 
		"throws_", "exceptionTypeList", "exceptionType", "methodBody", "instanceInitializer", 
		"staticInitializer", "constructorDeclaration", "constructorModifier", 
		"constructorDeclarator", "simpleTypeName", "constructorBody", "explicitConstructorInvocation", 
		"enumDeclaration", "enumBody", "enumConstantList", "enumConstant", "enumConstantModifier", 
		"enumBodyDeclarations", "interfaceDeclaration", "normalInterfaceDeclaration", 
		"interfaceModifier", "extendsInterfaces", "interfaceBody", "interfaceMemberDeclaration", 
		"constantDeclaration", "constantModifier", "interfaceMethodDeclaration", 
		"interfaceMethodModifier", "annotationTypeDeclaration", "annotationTypeBody", 
		"annotationTypeMemberDeclaration", "annotationTypeElementDeclaration", 
		"annotationTypeElementModifier", "defaultValue", "annotation", "normalAnnotation", 
		"elementValuePairList", "elementValuePair", "elementValue", "elementValueArrayInitializer", 
		"elementValueList", "markerAnnotation", "singleElementAnnotation", "arrayInitializer", 
		"variableInitializerList", "block", "blockStatements", "blockStatement", 
		"localVariableDeclarationStatement", "localVariableDeclaration", "statement", 
		"statementNoShortIf", "statementWithoutTrailingSubstatement", "emptyStatement_", 
		"labeledStatement", "labeledStatementNoShortIf", "expressionStatement", 
		"statementExpression", "ifThenStatement", "ifThenElseStatement", "ifThenElseStatementNoShortIf", 
		"assertStatement", "switchStatement", "switchBlock", "switchBlockStatementGroup", 
		"switchLabels", "switchLabel", "enumConstantName", "whileStatement", "whileStatementNoShortIf", 
		"doStatement", "forStatement", "forStatementNoShortIf", "basicForStatement", 
		"basicForStatementNoShortIf", "forInit", "forUpdate", "statementExpressionList", 
		"enhancedForStatement", "enhancedForStatementNoShortIf", "breakStatement", 
		"continueStatement", "returnStatement", "throwStatement", "synchronizedStatement", 
		"tryStatement", "catches", "catchClause", "catchFormalParameter", "catchType", 
		"finally_", "tryWithResourcesStatement", "resourceSpecification", "resourceList", 
		"resource", "variableAccess", "primary", "primaryNoNewArray", "primaryNoNewArray_lf_arrayAccess", 
		"primaryNoNewArray_lfno_arrayAccess", "primaryNoNewArray_lf_primary", 
		"primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary", "primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary", 
		"primaryNoNewArray_lfno_primary", "primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary", 
		"primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary", "classLiteral", 
		"classInstanceCreationExpression", "classInstanceCreationExpression_lf_primary", 
		"classInstanceCreationExpression_lfno_primary", "typeArgumentsOrDiamond", 
		"fieldAccess", "fieldAccess_lf_primary", "fieldAccess_lfno_primary", "arrayAccess", 
		"arrayAccess_lf_primary", "arrayAccess_lfno_primary", "methodInvocation", 
		"methodInvocation_lf_primary", "methodInvocation_lfno_primary", "argumentList", 
		"methodReference", "methodReference_lf_primary", "methodReference_lfno_primary", 
		"arrayCreationExpression", "dimExprs", "dimExpr", "constantExpression", 
		"expression", "lambdaExpression", "lambdaParameters", "inferredFormalParameterList", 
		"lambdaBody", "assignmentExpression", "assignment", "leftHandSide", "assignmentOperator", 
		"conditionalExpression", "conditionalOrExpression", "conditionalAndExpression", 
		"inclusiveOrExpression", "exclusiveOrExpression", "andExpression", "equalityExpression", 
		"relationalExpression", "shiftExpression", "additiveExpression", "multiplicativeExpression", 
		"unaryExpression", "preIncrementExpression", "preDecrementExpression", 
		"unaryExpressionNotPlusMinus", "postfixExpression", "postIncrementExpression", 
		"postIncrementExpression_lf_postfixExpression", "postDecrementExpression", 
		"postDecrementExpression_lf_postfixExpression", "castExpression", "identifier"
	];


	pub const _LITERAL_NAMES: [Option<&'static str>;115] = [
		None, Some("'abstract'"), Some("'assert'"), Some("'boolean'"), Some("'break'"), 
		Some("'byte'"), Some("'case'"), Some("'catch'"), Some("'char'"), Some("'class'"), 
		Some("'const'"), Some("'continue'"), Some("'default'"), Some("'do'"), 
		Some("'double'"), Some("'else'"), Some("'enum'"), Some("'exports'"), Some("'extends'"), 
		Some("'final'"), Some("'finally'"), Some("'float'"), Some("'for'"), Some("'if'"), 
		Some("'goto'"), Some("'implements'"), Some("'import'"), Some("'instanceof'"), 
		Some("'int'"), Some("'interface'"), Some("'long'"), Some("'module'"), 
		Some("'native'"), Some("'new'"), Some("'open'"), Some("'opens'"), Some("'package'"), 
		Some("'private'"), Some("'protected'"), Some("'provides'"), Some("'public'"), 
		Some("'requires'"), Some("'return'"), Some("'short'"), Some("'static'"), 
		Some("'strictfp'"), Some("'super'"), Some("'switch'"), Some("'synchronized'"), 
		Some("'this'"), Some("'throw'"), Some("'throws'"), Some("'to'"), Some("'transient'"), 
		Some("'transitive'"), Some("'try'"), Some("'uses'"), Some("'void'"), Some("'volatile'"), 
		Some("'while'"), Some("'with'"), Some("'_'"), None, None, None, None, 
		None, Some("'null'"), Some("'('"), Some("')'"), Some("'{'"), Some("'}'"), 
		Some("'['"), Some("']'"), Some("';'"), Some("','"), Some("'.'"), Some("'...'"), 
		Some("'@'"), Some("'::'"), Some("'='"), Some("'>'"), Some("'<'"), Some("'!'"), 
		Some("'~'"), Some("'?'"), Some("':'"), Some("'->'"), Some("'=='"), Some("'<='"), 
		Some("'>='"), Some("'!='"), Some("'&&'"), Some("'||'"), Some("'++'"), 
		Some("'--'"), Some("'+'"), Some("'-'"), Some("'*'"), Some("'/'"), Some("'&'"), 
		Some("'|'"), Some("'^'"), Some("'%'"), Some("'+='"), Some("'-='"), Some("'*='"), 
		Some("'/='"), Some("'&='"), Some("'|='"), Some("'^='"), Some("'%='"), 
		Some("'<<='"), Some("'>>='"), Some("'>>>='")
	];
	pub const _SYMBOLIC_NAMES: [Option<&'static str>;119]  = [
		None, Some("ABSTRACT"), Some("ASSERT"), Some("BOOLEAN"), Some("BREAK"), 
		Some("BYTE"), Some("CASE"), Some("CATCH"), Some("CHAR"), Some("CLASS"), 
		Some("CONST"), Some("CONTINUE"), Some("DEFAULT"), Some("DO"), Some("DOUBLE"), 
		Some("ELSE"), Some("ENUM"), Some("EXPORTS"), Some("EXTENDS"), Some("FINAL"), 
		Some("FINALLY"), Some("FLOAT"), Some("FOR"), Some("IF"), Some("GOTO"), 
		Some("IMPLEMENTS"), Some("IMPORT"), Some("INSTANCEOF"), Some("INT"), Some("INTERFACE"), 
		Some("LONG"), Some("MODULE"), Some("NATIVE"), Some("NEW"), Some("OPEN"), 
		Some("OPERNS"), Some("PACKAGE"), Some("PRIVATE"), Some("PROTECTED"), Some("PROVIDES"), 
		Some("PUBLIC"), Some("REQUIRES"), Some("RETURN"), Some("SHORT"), Some("STATIC"), 
		Some("STRICTFP"), Some("SUPER"), Some("SWITCH"), Some("SYNCHRONIZED"), 
		Some("THIS"), Some("THROW"), Some("THROWS"), Some("TO"), Some("TRANSIENT"), 
		Some("TRANSITIVE"), Some("TRY"), Some("USES"), Some("VOID"), Some("VOLATILE"), 
		Some("WHILE"), Some("WITH"), Some("UNDER_SCORE"), Some("IntegerLiteral"), 
		Some("FloatingPointLiteral"), Some("BooleanLiteral"), Some("CharacterLiteral"), 
		Some("StringLiteral"), Some("NullLiteral"), Some("LPAREN"), Some("RPAREN"), 
		Some("LBRACE"), Some("RBRACE"), Some("LBRACK"), Some("RBRACK"), Some("SEMI"), 
		Some("COMMA"), Some("DOT"), Some("ELLIPSIS"), Some("AT"), Some("COLONCOLON"), 
		Some("ASSIGN"), Some("GT"), Some("LT"), Some("BANG"), Some("TILDE"), Some("QUESTION"), 
		Some("COLON"), Some("ARROW"), Some("EQUAL"), Some("LE"), Some("GE"), Some("NOTEQUAL"), 
		Some("AND"), Some("OR"), Some("INC"), Some("DEC"), Some("ADD"), Some("SUB"), 
		Some("MUL"), Some("DIV"), Some("BITAND"), Some("BITOR"), Some("CARET"), 
		Some("MOD"), Some("ADD_ASSIGN"), Some("SUB_ASSIGN"), Some("MUL_ASSIGN"), 
		Some("DIV_ASSIGN"), Some("AND_ASSIGN"), Some("OR_ASSIGN"), Some("XOR_ASSIGN"), 
		Some("MOD_ASSIGN"), Some("LSHIFT_ASSIGN"), Some("RSHIFT_ASSIGN"), Some("URSHIFT_ASSIGN"), 
		Some("Identifier"), Some("WS"), Some("COMMENT"), Some("LINE_COMMENT")
	];
	lazy_static!{
	    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
		static ref VOCABULARY: Box<dyn Vocabulary> = Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
	}


type BaseParserType<'input, I> =
	BaseParser<'input,Java9ParserExt<'input>, I, Java9ParserContextType , dyn Java9ParserListener<'input> + 'input >;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type Java9ParserTreeWalker<'input,'a> =
	ParseTreeWalker<'input, 'a, Java9ParserContextType , dyn Java9ParserListener<'input> + 'a>;

/// Parser for Java9Parser grammar
pub struct Java9Parser<'input,I,H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	base:BaseParserType<'input,I>,
	interpreter:Arc<ParserATNSimulator>,
	_shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn get_serialized_atn() -> &'static str { _serializedATN }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
		antlr_rust::recognizer::check_version("0","3");
		let interpreter = Arc::new(ParserATNSimulator::new(
			_ATN.clone(),
			_decision_to_DFA.clone(),
			_shared_context_cache.clone(),
		));
		Self {
			base: BaseParser::new_base_parser(
				input,
				Arc::clone(&interpreter),
				Java9ParserExt{
					_pd: Default::default(),
				}
			),
			interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }

}

type DynStrategy<'input,I> = Box<dyn ErrorStrategy<'input,BaseParserType<'input,I>> + 'input>;

impl<'input, I> Java9Parser<'input, I, DynStrategy<'input,I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self{
    	Self::with_strategy(input,Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> Java9Parser<'input, I, DefaultErrorStrategy<'input,Java9ParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn new(input: I) -> Self{
    	Self::with_strategy(input,DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for Java9Parser
pub trait Java9ParserContext<'input>:
	for<'x> Listenable<dyn Java9ParserListener<'input> + 'x > + 
	ParserRuleContext<'input, TF=LocalTokenFactory<'input>, Ctx=Java9ParserContextType>
{}

antlr_rust::coerce_from!{ 'input : Java9ParserContext<'input> }

impl<'input> Java9ParserContext<'input> for TerminalNode<'input,Java9ParserContextType> {}
impl<'input> Java9ParserContext<'input> for ErrorNode<'input,Java9ParserContextType> {}

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn Java9ParserContext<'input> + 'input }

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn Java9ParserListener<'input> + 'input }

pub struct Java9ParserContextType;
antlr_rust::tid!{Java9ParserContextType}

impl<'input> ParserNodeType<'input> for Java9ParserContextType{
	type TF = LocalTokenFactory<'input>;
	type Type = dyn Java9ParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    type Target = BaseParserType<'input,I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct Java9ParserExt<'input>{
	_pd: PhantomData<&'input str>,
}

impl<'input> Java9ParserExt<'input>{
}
antlr_rust::tid! { Java9ParserExt<'a> }

impl<'input> TokenAware<'input> for Java9ParserExt<'input>{
	type TF = LocalTokenFactory<'input>;
}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> ParserRecog<'input, BaseParserType<'input,I>> for Java9ParserExt<'input>{}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> Actions<'input, BaseParserType<'input,I>> for Java9ParserExt<'input>{
	fn get_grammar_file_name(&self) -> & str{ "Java9Parser.g4"}

   	fn get_rule_names(&self) -> &[& str] {&ruleNames}

   	fn get_vocabulary(&self) -> &dyn Vocabulary { &**VOCABULARY }
	fn sempred(_localctx: Option<&(dyn Java9ParserContext<'input> + 'input)>, rule_index: isize, pred_index: isize,
			   recog:&mut BaseParserType<'input,I>
	)->bool{
		match rule_index {
					25 => Java9Parser::<'input,I,_>::moduleName_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					26 => Java9Parser::<'input,I,_>::packageName_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					28 => Java9Parser::<'input,I,_>::packageOrTypeName_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					31 => Java9Parser::<'input,I,_>::ambiguousName_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					224 => Java9Parser::<'input,I,_>::conditionalOrExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					225 => Java9Parser::<'input,I,_>::conditionalAndExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					226 => Java9Parser::<'input,I,_>::inclusiveOrExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					227 => Java9Parser::<'input,I,_>::exclusiveOrExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					228 => Java9Parser::<'input,I,_>::andExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					229 => Java9Parser::<'input,I,_>::equalityExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					230 => Java9Parser::<'input,I,_>::relationalExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					231 => Java9Parser::<'input,I,_>::shiftExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					232 => Java9Parser::<'input,I,_>::additiveExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					233 => Java9Parser::<'input,I,_>::multiplicativeExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
			_ => true
		}
	}
}

impl<'input, I> Java9Parser<'input, I, DefaultErrorStrategy<'input,Java9ParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
	fn moduleName_sempred(_localctx: Option<&ModuleNameContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				0=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn packageName_sempred(_localctx: Option<&PackageNameContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				1=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn packageOrTypeName_sempred(_localctx: Option<&PackageOrTypeNameContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				2=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn ambiguousName_sempred(_localctx: Option<&AmbiguousNameContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				3=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn conditionalOrExpression_sempred(_localctx: Option<&ConditionalOrExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				4=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn conditionalAndExpression_sempred(_localctx: Option<&ConditionalAndExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				5=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn inclusiveOrExpression_sempred(_localctx: Option<&InclusiveOrExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				6=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn exclusiveOrExpression_sempred(_localctx: Option<&ExclusiveOrExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				7=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn andExpression_sempred(_localctx: Option<&AndExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				8=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn equalityExpression_sempred(_localctx: Option<&EqualityExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				9=>{
					recog.precpred(None, 2)
				}
				10=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn relationalExpression_sempred(_localctx: Option<&RelationalExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				11=>{
					recog.precpred(None, 5)
				}
				12=>{
					recog.precpred(None, 4)
				}
				13=>{
					recog.precpred(None, 3)
				}
				14=>{
					recog.precpred(None, 2)
				}
				15=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn shiftExpression_sempred(_localctx: Option<&ShiftExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				16=>{
					recog.precpred(None, 3)
				}
				17=>{
					recog.precpred(None, 2)
				}
				18=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn additiveExpression_sempred(_localctx: Option<&AdditiveExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				19=>{
					recog.precpred(None, 2)
				}
				20=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn multiplicativeExpression_sempred(_localctx: Option<&MultiplicativeExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				21=>{
					recog.precpred(None, 3)
				}
				22=>{
					recog.precpred(None, 2)
				}
				23=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
}
//------------------- literal ----------------
pub type LiteralContextAll<'input> = LiteralContext<'input>;


pub type LiteralContext<'input> = BaseParserRuleContext<'input,LiteralContextExt<'input>>;

#[derive(Clone)]
pub struct LiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for LiteralContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for LiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_literal(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_literal(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_literal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_literal }
}
antlr_rust::tid!{LiteralContextExt<'a>}

impl<'input> LiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LiteralContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<LiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IntegerLiteral
/// Returns `None` if there is no child corresponding to token IntegerLiteral
fn IntegerLiteral(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(IntegerLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token FloatingPointLiteral
/// Returns `None` if there is no child corresponding to token FloatingPointLiteral
fn FloatingPointLiteral(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FloatingPointLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token BooleanLiteral
/// Returns `None` if there is no child corresponding to token BooleanLiteral
fn BooleanLiteral(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(BooleanLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token CharacterLiteral
/// Returns `None` if there is no child corresponding to token CharacterLiteral
fn CharacterLiteral(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(CharacterLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token StringLiteral
/// Returns `None` if there is no child corresponding to token StringLiteral
fn StringLiteral(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(StringLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token NullLiteral
/// Returns `None` if there is no child corresponding to token NullLiteral
fn NullLiteral(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(NullLiteral, 0)
}

}

impl<'input> LiteralContextAttrs<'input> for LiteralContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn literal(&mut self,)
	-> Result<Rc<LiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_literal);
        let mut _localctx: Rc<LiteralContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(490);
			_la = recog.base.input.la(1);
			if { !(((((_la - 62)) & !0x3f) == 0 && ((1usize << (_la - 62)) & ((1usize << (IntegerLiteral - 62)) | (1usize << (FloatingPointLiteral - 62)) | (1usize << (BooleanLiteral - 62)) | (1usize << (CharacterLiteral - 62)) | (1usize << (StringLiteral - 62)) | (1usize << (NullLiteral - 62)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primitiveType ----------------
pub type PrimitiveTypeContextAll<'input> = PrimitiveTypeContext<'input>;


pub type PrimitiveTypeContext<'input> = BaseParserRuleContext<'input,PrimitiveTypeContextExt<'input>>;

#[derive(Clone)]
pub struct PrimitiveTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PrimitiveTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PrimitiveTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primitiveType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_primitiveType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimitiveTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primitiveType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primitiveType }
}
antlr_rust::tid!{PrimitiveTypeContextExt<'a>}

impl<'input> PrimitiveTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimitiveTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimitiveTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimitiveTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PrimitiveTypeContextExt<'input>>{

fn numericType(&self) -> Option<Rc<NumericTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token BOOLEAN
/// Returns `None` if there is no child corresponding to token BOOLEAN
fn BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(BOOLEAN, 0)
}

}

impl<'input> PrimitiveTypeContextAttrs<'input> for PrimitiveTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primitiveType(&mut self,)
	-> Result<Rc<PrimitiveTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimitiveTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_primitiveType);
        let mut _localctx: Rc<PrimitiveTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(506);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(2,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(495);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(492);
						recog.annotation()?;

						}
						}
						recog.base.set_state(497);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule numericType*/
					recog.base.set_state(498);
					recog.numericType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(502);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(499);
						recog.annotation()?;

						}
						}
						recog.base.set_state(504);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(505);
					recog.base.match_token(BOOLEAN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- numericType ----------------
pub type NumericTypeContextAll<'input> = NumericTypeContext<'input>;


pub type NumericTypeContext<'input> = BaseParserRuleContext<'input,NumericTypeContextExt<'input>>;

#[derive(Clone)]
pub struct NumericTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for NumericTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for NumericTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_numericType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_numericType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NumericTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_numericType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_numericType }
}
antlr_rust::tid!{NumericTypeContextExt<'a>}

impl<'input> NumericTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NumericTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NumericTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NumericTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<NumericTypeContextExt<'input>>{

fn integralType(&self) -> Option<Rc<IntegralTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn floatingPointType(&self) -> Option<Rc<FloatingPointTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NumericTypeContextAttrs<'input> for NumericTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn numericType(&mut self,)
	-> Result<Rc<NumericTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NumericTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_numericType);
        let mut _localctx: Rc<NumericTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(510);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BYTE | CHAR | INT | LONG | SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule integralType*/
					recog.base.set_state(508);
					recog.integralType()?;

					}
				}

			 DOUBLE | FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule floatingPointType*/
					recog.base.set_state(509);
					recog.floatingPointType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- integralType ----------------
pub type IntegralTypeContextAll<'input> = IntegralTypeContext<'input>;


pub type IntegralTypeContext<'input> = BaseParserRuleContext<'input,IntegralTypeContextExt<'input>>;

#[derive(Clone)]
pub struct IntegralTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for IntegralTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for IntegralTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_integralType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_integralType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IntegralTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_integralType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_integralType }
}
antlr_rust::tid!{IntegralTypeContextExt<'a>}

impl<'input> IntegralTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IntegralTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IntegralTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IntegralTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<IntegralTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BYTE
/// Returns `None` if there is no child corresponding to token BYTE
fn BYTE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(BYTE, 0)
}
/// Retrieves first TerminalNode corresponding to token SHORT
/// Returns `None` if there is no child corresponding to token SHORT
fn SHORT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SHORT, 0)
}
/// Retrieves first TerminalNode corresponding to token INT
/// Returns `None` if there is no child corresponding to token INT
fn INT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(INT, 0)
}
/// Retrieves first TerminalNode corresponding to token LONG
/// Returns `None` if there is no child corresponding to token LONG
fn LONG(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LONG, 0)
}
/// Retrieves first TerminalNode corresponding to token CHAR
/// Returns `None` if there is no child corresponding to token CHAR
fn CHAR(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(CHAR, 0)
}

}

impl<'input> IntegralTypeContextAttrs<'input> for IntegralTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn integralType(&mut self,)
	-> Result<Rc<IntegralTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IntegralTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_integralType);
        let mut _localctx: Rc<IntegralTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(512);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BYTE) | (1usize << CHAR) | (1usize << INT) | (1usize << LONG))) != 0) || _la==SHORT) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- floatingPointType ----------------
pub type FloatingPointTypeContextAll<'input> = FloatingPointTypeContext<'input>;


pub type FloatingPointTypeContext<'input> = BaseParserRuleContext<'input,FloatingPointTypeContextExt<'input>>;

#[derive(Clone)]
pub struct FloatingPointTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for FloatingPointTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for FloatingPointTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_floatingPointType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_floatingPointType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FloatingPointTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_floatingPointType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_floatingPointType }
}
antlr_rust::tid!{FloatingPointTypeContextExt<'a>}

impl<'input> FloatingPointTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FloatingPointTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FloatingPointTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FloatingPointTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<FloatingPointTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FLOAT
/// Returns `None` if there is no child corresponding to token FLOAT
fn FLOAT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FLOAT, 0)
}
/// Retrieves first TerminalNode corresponding to token DOUBLE
/// Returns `None` if there is no child corresponding to token DOUBLE
fn DOUBLE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOUBLE, 0)
}

}

impl<'input> FloatingPointTypeContextAttrs<'input> for FloatingPointTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn floatingPointType(&mut self,)
	-> Result<Rc<FloatingPointTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FloatingPointTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_floatingPointType);
        let mut _localctx: Rc<FloatingPointTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(514);
			_la = recog.base.input.la(1);
			if { !(_la==DOUBLE || _la==FLOAT) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- referenceType ----------------
pub type ReferenceTypeContextAll<'input> = ReferenceTypeContext<'input>;


pub type ReferenceTypeContext<'input> = BaseParserRuleContext<'input,ReferenceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ReferenceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ReferenceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ReferenceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_referenceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_referenceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ReferenceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_referenceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_referenceType }
}
antlr_rust::tid!{ReferenceTypeContextExt<'a>}

impl<'input> ReferenceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReferenceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReferenceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReferenceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ReferenceTypeContextExt<'input>>{

fn classOrInterfaceType(&self) -> Option<Rc<ClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeVariable(&self) -> Option<Rc<TypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayType(&self) -> Option<Rc<ArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReferenceTypeContextAttrs<'input> for ReferenceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn referenceType(&mut self,)
	-> Result<Rc<ReferenceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReferenceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_referenceType);
        let mut _localctx: Rc<ReferenceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(519);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(4,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classOrInterfaceType*/
					recog.base.set_state(516);
					recog.classOrInterfaceType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeVariable*/
					recog.base.set_state(517);
					recog.typeVariable()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule arrayType*/
					recog.base.set_state(518);
					recog.arrayType()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classOrInterfaceType ----------------
pub type ClassOrInterfaceTypeContextAll<'input> = ClassOrInterfaceTypeContext<'input>;


pub type ClassOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,ClassOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ClassOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classOrInterfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classOrInterfaceType }
}
antlr_rust::tid!{ClassOrInterfaceTypeContextExt<'a>}

impl<'input> ClassOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassOrInterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassOrInterfaceTypeContextExt<'input>>{

fn classType_lfno_classOrInterfaceType(&self) -> Option<Rc<ClassType_lfno_classOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceType_lfno_classOrInterfaceType(&self) -> Option<Rc<InterfaceType_lfno_classOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classType_lf_classOrInterfaceType_all(&self) ->  Vec<Rc<ClassType_lf_classOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classType_lf_classOrInterfaceType(&self, i: usize) -> Option<Rc<ClassType_lf_classOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn interfaceType_lf_classOrInterfaceType_all(&self) ->  Vec<Rc<InterfaceType_lf_classOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceType_lf_classOrInterfaceType(&self, i: usize) -> Option<Rc<InterfaceType_lf_classOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ClassOrInterfaceTypeContextAttrs<'input> for ClassOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classOrInterfaceType(&mut self,)
	-> Result<Rc<ClassOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_classOrInterfaceType);
        let mut _localctx: Rc<ClassOrInterfaceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(523);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(5,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule classType_lfno_classOrInterfaceType*/
					recog.base.set_state(521);
					recog.classType_lfno_classOrInterfaceType()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule interfaceType_lfno_classOrInterfaceType*/
					recog.base.set_state(522);
					recog.interfaceType_lfno_classOrInterfaceType()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(529);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(7,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					recog.base.set_state(527);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(6,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule classType_lf_classOrInterfaceType*/
							recog.base.set_state(525);
							recog.classType_lf_classOrInterfaceType()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule interfaceType_lf_classOrInterfaceType*/
							recog.base.set_state(526);
							recog.interfaceType_lf_classOrInterfaceType()?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(531);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(7,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classType ----------------
pub type ClassTypeContextAll<'input> = ClassTypeContext<'input>;


pub type ClassTypeContext<'input> = BaseParserRuleContext<'input,ClassTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ClassTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classType }
}
antlr_rust::tid!{ClassTypeContextExt<'a>}

impl<'input> ClassTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassTypeContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classOrInterfaceType(&self) -> Option<Rc<ClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> ClassTypeContextAttrs<'input> for ClassTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classType(&mut self,)
	-> Result<Rc<ClassTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_classType);
        let mut _localctx: Rc<ClassTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(554);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(12,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(535);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(532);
						recog.annotation()?;

						}
						}
						recog.base.set_state(537);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule identifier*/
					recog.base.set_state(538);
					recog.identifier()?;

					recog.base.set_state(540);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(539);
						recog.typeArguments()?;

						}
					}

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule classOrInterfaceType*/
					recog.base.set_state(542);
					recog.classOrInterfaceType()?;

					recog.base.set_state(543);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(547);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(544);
						recog.annotation()?;

						}
						}
						recog.base.set_state(549);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule identifier*/
					recog.base.set_state(550);
					recog.identifier()?;

					recog.base.set_state(552);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(551);
						recog.typeArguments()?;

						}
					}

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classType_lf_classOrInterfaceType ----------------
pub type ClassType_lf_classOrInterfaceTypeContextAll<'input> = ClassType_lf_classOrInterfaceTypeContext<'input>;


pub type ClassType_lf_classOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,ClassType_lf_classOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ClassType_lf_classOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassType_lf_classOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassType_lf_classOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classType_lf_classOrInterfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classType_lf_classOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassType_lf_classOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classType_lf_classOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classType_lf_classOrInterfaceType }
}
antlr_rust::tid!{ClassType_lf_classOrInterfaceTypeContextExt<'a>}

impl<'input> ClassType_lf_classOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassType_lf_classOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassType_lf_classOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassType_lf_classOrInterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassType_lf_classOrInterfaceTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassType_lf_classOrInterfaceTypeContextAttrs<'input> for ClassType_lf_classOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classType_lf_classOrInterfaceType(&mut self,)
	-> Result<Rc<ClassType_lf_classOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassType_lf_classOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_classType_lf_classOrInterfaceType);
        let mut _localctx: Rc<ClassType_lf_classOrInterfaceTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(556);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(560);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(557);
				recog.annotation()?;

				}
				}
				recog.base.set_state(562);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule identifier*/
			recog.base.set_state(563);
			recog.identifier()?;

			recog.base.set_state(565);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(14,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(564);
					recog.typeArguments()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classType_lfno_classOrInterfaceType ----------------
pub type ClassType_lfno_classOrInterfaceTypeContextAll<'input> = ClassType_lfno_classOrInterfaceTypeContext<'input>;


pub type ClassType_lfno_classOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,ClassType_lfno_classOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ClassType_lfno_classOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassType_lfno_classOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassType_lfno_classOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classType_lfno_classOrInterfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classType_lfno_classOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassType_lfno_classOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classType_lfno_classOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classType_lfno_classOrInterfaceType }
}
antlr_rust::tid!{ClassType_lfno_classOrInterfaceTypeContextExt<'a>}

impl<'input> ClassType_lfno_classOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassType_lfno_classOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassType_lfno_classOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassType_lfno_classOrInterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassType_lfno_classOrInterfaceTypeContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassType_lfno_classOrInterfaceTypeContextAttrs<'input> for ClassType_lfno_classOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classType_lfno_classOrInterfaceType(&mut self,)
	-> Result<Rc<ClassType_lfno_classOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassType_lfno_classOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_classType_lfno_classOrInterfaceType);
        let mut _localctx: Rc<ClassType_lfno_classOrInterfaceTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(570);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(567);
				recog.annotation()?;

				}
				}
				recog.base.set_state(572);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule identifier*/
			recog.base.set_state(573);
			recog.identifier()?;

			recog.base.set_state(575);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(16,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(574);
					recog.typeArguments()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceType ----------------
pub type InterfaceTypeContextAll<'input> = InterfaceTypeContext<'input>;


pub type InterfaceTypeContext<'input> = BaseParserRuleContext<'input,InterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_interfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceType }
}
antlr_rust::tid!{InterfaceTypeContextExt<'a>}

impl<'input> InterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InterfaceTypeContextExt<'input>>{

fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfaceTypeContextAttrs<'input> for InterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceType(&mut self,)
	-> Result<Rc<InterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_interfaceType);
        let mut _localctx: Rc<InterfaceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule classType*/
			recog.base.set_state(577);
			recog.classType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceType_lf_classOrInterfaceType ----------------
pub type InterfaceType_lf_classOrInterfaceTypeContextAll<'input> = InterfaceType_lf_classOrInterfaceTypeContext<'input>;


pub type InterfaceType_lf_classOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,InterfaceType_lf_classOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceType_lf_classOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InterfaceType_lf_classOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InterfaceType_lf_classOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceType_lf_classOrInterfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_interfaceType_lf_classOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InterfaceType_lf_classOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceType_lf_classOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceType_lf_classOrInterfaceType }
}
antlr_rust::tid!{InterfaceType_lf_classOrInterfaceTypeContextExt<'a>}

impl<'input> InterfaceType_lf_classOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceType_lf_classOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceType_lf_classOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceType_lf_classOrInterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InterfaceType_lf_classOrInterfaceTypeContextExt<'input>>{

fn classType_lf_classOrInterfaceType(&self) -> Option<Rc<ClassType_lf_classOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfaceType_lf_classOrInterfaceTypeContextAttrs<'input> for InterfaceType_lf_classOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceType_lf_classOrInterfaceType(&mut self,)
	-> Result<Rc<InterfaceType_lf_classOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceType_lf_classOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_interfaceType_lf_classOrInterfaceType);
        let mut _localctx: Rc<InterfaceType_lf_classOrInterfaceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule classType_lf_classOrInterfaceType*/
			recog.base.set_state(579);
			recog.classType_lf_classOrInterfaceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceType_lfno_classOrInterfaceType ----------------
pub type InterfaceType_lfno_classOrInterfaceTypeContextAll<'input> = InterfaceType_lfno_classOrInterfaceTypeContext<'input>;


pub type InterfaceType_lfno_classOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,InterfaceType_lfno_classOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceType_lfno_classOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InterfaceType_lfno_classOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InterfaceType_lfno_classOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceType_lfno_classOrInterfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_interfaceType_lfno_classOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InterfaceType_lfno_classOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceType_lfno_classOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceType_lfno_classOrInterfaceType }
}
antlr_rust::tid!{InterfaceType_lfno_classOrInterfaceTypeContextExt<'a>}

impl<'input> InterfaceType_lfno_classOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceType_lfno_classOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceType_lfno_classOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceType_lfno_classOrInterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InterfaceType_lfno_classOrInterfaceTypeContextExt<'input>>{

fn classType_lfno_classOrInterfaceType(&self) -> Option<Rc<ClassType_lfno_classOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfaceType_lfno_classOrInterfaceTypeContextAttrs<'input> for InterfaceType_lfno_classOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceType_lfno_classOrInterfaceType(&mut self,)
	-> Result<Rc<InterfaceType_lfno_classOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceType_lfno_classOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_interfaceType_lfno_classOrInterfaceType);
        let mut _localctx: Rc<InterfaceType_lfno_classOrInterfaceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule classType_lfno_classOrInterfaceType*/
			recog.base.set_state(581);
			recog.classType_lfno_classOrInterfaceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeVariable ----------------
pub type TypeVariableContextAll<'input> = TypeVariableContext<'input>;


pub type TypeVariableContext<'input> = BaseParserRuleContext<'input,TypeVariableContextExt<'input>>;

#[derive(Clone)]
pub struct TypeVariableContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeVariableContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeVariableContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeVariable(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeVariable(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeVariableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeVariable }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeVariable }
}
antlr_rust::tid!{TypeVariableContextExt<'a>}

impl<'input> TypeVariableContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeVariableContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeVariableContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeVariableContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeVariableContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeVariableContextAttrs<'input> for TypeVariableContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeVariable(&mut self,)
	-> Result<Rc<TypeVariableContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeVariableContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_typeVariable);
        let mut _localctx: Rc<TypeVariableContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(586);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(583);
				recog.annotation()?;

				}
				}
				recog.base.set_state(588);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule identifier*/
			recog.base.set_state(589);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayType ----------------
pub type ArrayTypeContextAll<'input> = ArrayTypeContext<'input>;


pub type ArrayTypeContext<'input> = BaseParserRuleContext<'input,ArrayTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ArrayTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ArrayTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_arrayType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayType }
}
antlr_rust::tid!{ArrayTypeContextExt<'a>}

impl<'input> ArrayTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ArrayTypeContextExt<'input>>{

fn primitiveType(&self) -> Option<Rc<PrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classOrInterfaceType(&self) -> Option<Rc<ClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeVariable(&self) -> Option<Rc<TypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayTypeContextAttrs<'input> for ArrayTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayType(&mut self,)
	-> Result<Rc<ArrayTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_arrayType);
        let mut _localctx: Rc<ArrayTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(600);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(18,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule primitiveType*/
					recog.base.set_state(591);
					recog.primitiveType()?;

					/*InvokeRule dims*/
					recog.base.set_state(592);
					recog.dims()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule classOrInterfaceType*/
					recog.base.set_state(594);
					recog.classOrInterfaceType()?;

					/*InvokeRule dims*/
					recog.base.set_state(595);
					recog.dims()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule typeVariable*/
					recog.base.set_state(597);
					recog.typeVariable()?;

					/*InvokeRule dims*/
					recog.base.set_state(598);
					recog.dims()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dims ----------------
pub type DimsContextAll<'input> = DimsContext<'input>;


pub type DimsContext<'input> = BaseParserRuleContext<'input,DimsContextExt<'input>>;

#[derive(Clone)]
pub struct DimsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for DimsContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for DimsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_dims(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_dims(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DimsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dims }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dims }
}
antlr_rust::tid!{DimsContextExt<'a>}

impl<'input> DimsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DimsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DimsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DimsContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<DimsContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token LBRACK in current rule
fn LBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token LBRACK is less or equal than `i`.
fn LBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RBRACK in current rule
fn RBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token RBRACK is less or equal than `i`.
fn RBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> DimsContextAttrs<'input> for DimsContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dims(&mut self,)
	-> Result<Rc<DimsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DimsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_dims);
        let mut _localctx: Rc<DimsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(605);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(602);
				recog.annotation()?;

				}
				}
				recog.base.set_state(607);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(608);
			recog.base.match_token(LBRACK,&mut recog.err_handler)?;

			recog.base.set_state(609);
			recog.base.match_token(RBRACK,&mut recog.err_handler)?;

			recog.base.set_state(620);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(21,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(613);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(610);
						recog.annotation()?;

						}
						}
						recog.base.set_state(615);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(616);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					recog.base.set_state(617);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(622);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(21,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameter ----------------
pub type TypeParameterContextAll<'input> = TypeParameterContext<'input>;


pub type TypeParameterContext<'input> = BaseParserRuleContext<'input,TypeParameterContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeParameterContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameter(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameter }
}
antlr_rust::tid!{TypeParameterContextExt<'a>}

impl<'input> TypeParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeParameterContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeParameterModifier_all(&self) ->  Vec<Rc<TypeParameterModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeParameterModifier(&self, i: usize) -> Option<Rc<TypeParameterModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeBound(&self) -> Option<Rc<TypeBoundContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeParameterContextAttrs<'input> for TypeParameterContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameter(&mut self,)
	-> Result<Rc<TypeParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_typeParameter);
        let mut _localctx: Rc<TypeParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(626);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule typeParameterModifier*/
				recog.base.set_state(623);
				recog.typeParameterModifier()?;

				}
				}
				recog.base.set_state(628);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule identifier*/
			recog.base.set_state(629);
			recog.identifier()?;

			recog.base.set_state(631);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXTENDS {
				{
				/*InvokeRule typeBound*/
				recog.base.set_state(630);
				recog.typeBound()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameterModifier ----------------
pub type TypeParameterModifierContextAll<'input> = TypeParameterModifierContext<'input>;


pub type TypeParameterModifierContext<'input> = BaseParserRuleContext<'input,TypeParameterModifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeParameterModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeParameterModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameterModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeParameterModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeParameterModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameterModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameterModifier }
}
antlr_rust::tid!{TypeParameterModifierContextExt<'a>}

impl<'input> TypeParameterModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeParameterModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeParameterModifierContextAttrs<'input> for TypeParameterModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameterModifier(&mut self,)
	-> Result<Rc<TypeParameterModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_typeParameterModifier);
        let mut _localctx: Rc<TypeParameterModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule annotation*/
			recog.base.set_state(633);
			recog.annotation()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeBound ----------------
pub type TypeBoundContextAll<'input> = TypeBoundContext<'input>;


pub type TypeBoundContext<'input> = BaseParserRuleContext<'input,TypeBoundContextExt<'input>>;

#[derive(Clone)]
pub struct TypeBoundContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeBoundContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeBoundContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeBound(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeBound(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeBoundContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeBound }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeBound }
}
antlr_rust::tid!{TypeBoundContextExt<'a>}

impl<'input> TypeBoundContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeBoundContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeBoundContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeBoundContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeBoundContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXTENDS
/// Returns `None` if there is no child corresponding to token EXTENDS
fn EXTENDS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(EXTENDS, 0)
}
fn typeVariable(&self) -> Option<Rc<TypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classOrInterfaceType(&self) -> Option<Rc<ClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn additionalBound_all(&self) ->  Vec<Rc<AdditionalBoundContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn additionalBound(&self, i: usize) -> Option<Rc<AdditionalBoundContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeBoundContextAttrs<'input> for TypeBoundContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeBound(&mut self,)
	-> Result<Rc<TypeBoundContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeBoundContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_typeBound);
        let mut _localctx: Rc<TypeBoundContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(645);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(25,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(635);
					recog.base.match_token(EXTENDS,&mut recog.err_handler)?;

					/*InvokeRule typeVariable*/
					recog.base.set_state(636);
					recog.typeVariable()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(637);
					recog.base.match_token(EXTENDS,&mut recog.err_handler)?;

					/*InvokeRule classOrInterfaceType*/
					recog.base.set_state(638);
					recog.classOrInterfaceType()?;

					recog.base.set_state(642);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==BITAND {
						{
						{
						/*InvokeRule additionalBound*/
						recog.base.set_state(639);
						recog.additionalBound()?;

						}
						}
						recog.base.set_state(644);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- additionalBound ----------------
pub type AdditionalBoundContextAll<'input> = AdditionalBoundContext<'input>;


pub type AdditionalBoundContext<'input> = BaseParserRuleContext<'input,AdditionalBoundContextExt<'input>>;

#[derive(Clone)]
pub struct AdditionalBoundContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AdditionalBoundContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AdditionalBoundContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_additionalBound(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_additionalBound(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AdditionalBoundContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_additionalBound }
	//fn type_rule_index() -> usize where Self: Sized { RULE_additionalBound }
}
antlr_rust::tid!{AdditionalBoundContextExt<'a>}

impl<'input> AdditionalBoundContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AdditionalBoundContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AdditionalBoundContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AdditionalBoundContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AdditionalBoundContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BITAND
/// Returns `None` if there is no child corresponding to token BITAND
fn BITAND(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(BITAND, 0)
}
fn interfaceType(&self) -> Option<Rc<InterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AdditionalBoundContextAttrs<'input> for AdditionalBoundContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn additionalBound(&mut self,)
	-> Result<Rc<AdditionalBoundContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AdditionalBoundContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_additionalBound);
        let mut _localctx: Rc<AdditionalBoundContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(647);
			recog.base.match_token(BITAND,&mut recog.err_handler)?;

			/*InvokeRule interfaceType*/
			recog.base.set_state(648);
			recog.interfaceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeArguments ----------------
pub type TypeArgumentsContextAll<'input> = TypeArgumentsContext<'input>;


pub type TypeArgumentsContext<'input> = BaseParserRuleContext<'input,TypeArgumentsContextExt<'input>>;

#[derive(Clone)]
pub struct TypeArgumentsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeArgumentsContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeArgumentsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeArguments(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeArguments(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeArgumentsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeArguments }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeArguments }
}
antlr_rust::tid!{TypeArgumentsContextExt<'a>}

impl<'input> TypeArgumentsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeArgumentsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeArgumentsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeArgumentsContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeArgumentsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LT
/// Returns `None` if there is no child corresponding to token LT
fn LT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LT, 0)
}
fn typeArgumentList(&self) -> Option<Rc<TypeArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token GT
/// Returns `None` if there is no child corresponding to token GT
fn GT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(GT, 0)
}

}

impl<'input> TypeArgumentsContextAttrs<'input> for TypeArgumentsContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeArguments(&mut self,)
	-> Result<Rc<TypeArgumentsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeArgumentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_typeArguments);
        let mut _localctx: Rc<TypeArgumentsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(650);
			recog.base.match_token(LT,&mut recog.err_handler)?;

			/*InvokeRule typeArgumentList*/
			recog.base.set_state(651);
			recog.typeArgumentList()?;

			recog.base.set_state(652);
			recog.base.match_token(GT,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeArgumentList ----------------
pub type TypeArgumentListContextAll<'input> = TypeArgumentListContext<'input>;


pub type TypeArgumentListContext<'input> = BaseParserRuleContext<'input,TypeArgumentListContextExt<'input>>;

#[derive(Clone)]
pub struct TypeArgumentListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeArgumentListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeArgumentListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeArgumentList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeArgumentList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeArgumentListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeArgumentList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeArgumentList }
}
antlr_rust::tid!{TypeArgumentListContextExt<'a>}

impl<'input> TypeArgumentListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeArgumentListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeArgumentListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeArgumentListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeArgumentListContextExt<'input>>{

fn typeArgument_all(&self) ->  Vec<Rc<TypeArgumentContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeArgument(&self, i: usize) -> Option<Rc<TypeArgumentContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TypeArgumentListContextAttrs<'input> for TypeArgumentListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeArgumentList(&mut self,)
	-> Result<Rc<TypeArgumentListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeArgumentListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_typeArgumentList);
        let mut _localctx: Rc<TypeArgumentListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typeArgument*/
			recog.base.set_state(654);
			recog.typeArgument()?;

			recog.base.set_state(659);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(655);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule typeArgument*/
				recog.base.set_state(656);
				recog.typeArgument()?;

				}
				}
				recog.base.set_state(661);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeArgument ----------------
pub type TypeArgumentContextAll<'input> = TypeArgumentContext<'input>;


pub type TypeArgumentContext<'input> = BaseParserRuleContext<'input,TypeArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct TypeArgumentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeArgumentContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeArgument(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeArgument(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeArgument }
}
antlr_rust::tid!{TypeArgumentContextExt<'a>}

impl<'input> TypeArgumentContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeArgumentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeArgumentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeArgumentContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeArgumentContextExt<'input>>{

fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn wildcard(&self) -> Option<Rc<WildcardContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeArgumentContextAttrs<'input> for TypeArgumentContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeArgument(&mut self,)
	-> Result<Rc<TypeArgumentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_typeArgument);
        let mut _localctx: Rc<TypeArgumentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(664);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(27,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule referenceType*/
					recog.base.set_state(662);
					recog.referenceType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule wildcard*/
					recog.base.set_state(663);
					recog.wildcard()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- wildcard ----------------
pub type WildcardContextAll<'input> = WildcardContext<'input>;


pub type WildcardContext<'input> = BaseParserRuleContext<'input,WildcardContextExt<'input>>;

#[derive(Clone)]
pub struct WildcardContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for WildcardContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for WildcardContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_wildcard(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_wildcard(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for WildcardContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_wildcard }
	//fn type_rule_index() -> usize where Self: Sized { RULE_wildcard }
}
antlr_rust::tid!{WildcardContextExt<'a>}

impl<'input> WildcardContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WildcardContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WildcardContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WildcardContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<WildcardContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUESTION
/// Returns `None` if there is no child corresponding to token QUESTION
fn QUESTION(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(QUESTION, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn wildcardBounds(&self) -> Option<Rc<WildcardBoundsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WildcardContextAttrs<'input> for WildcardContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn wildcard(&mut self,)
	-> Result<Rc<WildcardContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WildcardContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_wildcard);
        let mut _localctx: Rc<WildcardContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(669);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(666);
				recog.annotation()?;

				}
				}
				recog.base.set_state(671);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(672);
			recog.base.match_token(QUESTION,&mut recog.err_handler)?;

			recog.base.set_state(674);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXTENDS || _la==SUPER {
				{
				/*InvokeRule wildcardBounds*/
				recog.base.set_state(673);
				recog.wildcardBounds()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- wildcardBounds ----------------
pub type WildcardBoundsContextAll<'input> = WildcardBoundsContext<'input>;


pub type WildcardBoundsContext<'input> = BaseParserRuleContext<'input,WildcardBoundsContextExt<'input>>;

#[derive(Clone)]
pub struct WildcardBoundsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for WildcardBoundsContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for WildcardBoundsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_wildcardBounds(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_wildcardBounds(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for WildcardBoundsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_wildcardBounds }
	//fn type_rule_index() -> usize where Self: Sized { RULE_wildcardBounds }
}
antlr_rust::tid!{WildcardBoundsContextExt<'a>}

impl<'input> WildcardBoundsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WildcardBoundsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WildcardBoundsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WildcardBoundsContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<WildcardBoundsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXTENDS
/// Returns `None` if there is no child corresponding to token EXTENDS
fn EXTENDS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(EXTENDS, 0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}

}

impl<'input> WildcardBoundsContextAttrs<'input> for WildcardBoundsContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn wildcardBounds(&mut self,)
	-> Result<Rc<WildcardBoundsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WildcardBoundsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_wildcardBounds);
        let mut _localctx: Rc<WildcardBoundsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(680);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 EXTENDS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(676);
					recog.base.match_token(EXTENDS,&mut recog.err_handler)?;

					/*InvokeRule referenceType*/
					recog.base.set_state(677);
					recog.referenceType()?;

					}
				}

			 SUPER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(678);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					/*InvokeRule referenceType*/
					recog.base.set_state(679);
					recog.referenceType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moduleName ----------------
pub type ModuleNameContextAll<'input> = ModuleNameContext<'input>;


pub type ModuleNameContext<'input> = BaseParserRuleContext<'input,ModuleNameContextExt<'input>>;

#[derive(Clone)]
pub struct ModuleNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ModuleNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ModuleNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moduleName(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_moduleName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ModuleNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moduleName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moduleName }
}
antlr_rust::tid!{ModuleNameContextExt<'a>}

impl<'input> ModuleNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModuleNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModuleNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModuleNameContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ModuleNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moduleName(&self) -> Option<Rc<ModuleNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> ModuleNameContextAttrs<'input> for ModuleNameContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  moduleName(&mut self,)
	-> Result<Rc<ModuleNameContextAll<'input>>,ANTLRError> {
		self.moduleName_rec(0)
	}

	fn moduleName_rec(&mut self, _p: isize)
	-> Result<Rc<ModuleNameContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = ModuleNameContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 50, RULE_moduleName, _p);
	    let mut _localctx: Rc<ModuleNameContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 50;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule identifier*/
			recog.base.set_state(683);
			recog.identifier()?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(690);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(31,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = ModuleNameContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_moduleName);
					_localctx = tmp;
					recog.base.set_state(685);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(686);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(687);
					recog.identifier()?;

					}
					} 
				}
				recog.base.set_state(692);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(31,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- packageName ----------------
pub type PackageNameContextAll<'input> = PackageNameContext<'input>;


pub type PackageNameContext<'input> = BaseParserRuleContext<'input,PackageNameContextExt<'input>>;

#[derive(Clone)]
pub struct PackageNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PackageNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PackageNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packageName(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_packageName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PackageNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packageName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packageName }
}
antlr_rust::tid!{PackageNameContextExt<'a>}

impl<'input> PackageNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackageNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackageNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackageNameContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PackageNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn packageName(&self) -> Option<Rc<PackageNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> PackageNameContextAttrs<'input> for PackageNameContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  packageName(&mut self,)
	-> Result<Rc<PackageNameContextAll<'input>>,ANTLRError> {
		self.packageName_rec(0)
	}

	fn packageName_rec(&mut self, _p: isize)
	-> Result<Rc<PackageNameContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = PackageNameContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 52, RULE_packageName, _p);
	    let mut _localctx: Rc<PackageNameContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 52;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule identifier*/
			recog.base.set_state(694);
			recog.identifier()?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(701);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(32,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = PackageNameContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_packageName);
					_localctx = tmp;
					recog.base.set_state(696);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(697);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(698);
					recog.identifier()?;

					}
					} 
				}
				recog.base.set_state(703);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(32,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- typeName ----------------
pub type TypeNameContextAll<'input> = TypeNameContext<'input>;


pub type TypeNameContext<'input> = BaseParserRuleContext<'input,TypeNameContextExt<'input>>;

#[derive(Clone)]
pub struct TypeNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeName(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeName }
}
antlr_rust::tid!{TypeNameContextExt<'a>}

impl<'input> TypeNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeNameContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn packageOrTypeName(&self) -> Option<Rc<PackageOrTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> TypeNameContextAttrs<'input> for TypeNameContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeName(&mut self,)
	-> Result<Rc<TypeNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_typeName);
        let mut _localctx: Rc<TypeNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(709);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(33,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule identifier*/
					recog.base.set_state(704);
					recog.identifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule packageOrTypeName*/
					recog.base.set_state(705);
					recog.packageOrTypeName_rec(0)?;

					recog.base.set_state(706);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(707);
					recog.identifier()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packageOrTypeName ----------------
pub type PackageOrTypeNameContextAll<'input> = PackageOrTypeNameContext<'input>;


pub type PackageOrTypeNameContext<'input> = BaseParserRuleContext<'input,PackageOrTypeNameContextExt<'input>>;

#[derive(Clone)]
pub struct PackageOrTypeNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PackageOrTypeNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PackageOrTypeNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packageOrTypeName(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_packageOrTypeName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PackageOrTypeNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packageOrTypeName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packageOrTypeName }
}
antlr_rust::tid!{PackageOrTypeNameContextExt<'a>}

impl<'input> PackageOrTypeNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackageOrTypeNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackageOrTypeNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackageOrTypeNameContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PackageOrTypeNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn packageOrTypeName(&self) -> Option<Rc<PackageOrTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> PackageOrTypeNameContextAttrs<'input> for PackageOrTypeNameContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  packageOrTypeName(&mut self,)
	-> Result<Rc<PackageOrTypeNameContextAll<'input>>,ANTLRError> {
		self.packageOrTypeName_rec(0)
	}

	fn packageOrTypeName_rec(&mut self, _p: isize)
	-> Result<Rc<PackageOrTypeNameContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = PackageOrTypeNameContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 56, RULE_packageOrTypeName, _p);
	    let mut _localctx: Rc<PackageOrTypeNameContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 56;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule identifier*/
			recog.base.set_state(712);
			recog.identifier()?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(719);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(34,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = PackageOrTypeNameContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_packageOrTypeName);
					_localctx = tmp;
					recog.base.set_state(714);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(715);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(716);
					recog.identifier()?;

					}
					} 
				}
				recog.base.set_state(721);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(34,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- expressionName ----------------
pub type ExpressionNameContextAll<'input> = ExpressionNameContext<'input>;


pub type ExpressionNameContext<'input> = BaseParserRuleContext<'input,ExpressionNameContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ExpressionNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ExpressionNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_expressionName(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_expressionName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExpressionNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expressionName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expressionName }
}
antlr_rust::tid!{ExpressionNameContextExt<'a>}

impl<'input> ExpressionNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionNameContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ExpressionNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ambiguousName(&self) -> Option<Rc<AmbiguousNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> ExpressionNameContextAttrs<'input> for ExpressionNameContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expressionName(&mut self,)
	-> Result<Rc<ExpressionNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_expressionName);
        let mut _localctx: Rc<ExpressionNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(727);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(35,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule identifier*/
					recog.base.set_state(722);
					recog.identifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule ambiguousName*/
					recog.base.set_state(723);
					recog.ambiguousName_rec(0)?;

					recog.base.set_state(724);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(725);
					recog.identifier()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodName ----------------
pub type MethodNameContextAll<'input> = MethodNameContext<'input>;


pub type MethodNameContext<'input> = BaseParserRuleContext<'input,MethodNameContextExt<'input>>;

#[derive(Clone)]
pub struct MethodNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodName(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodName }
}
antlr_rust::tid!{MethodNameContextExt<'a>}

impl<'input> MethodNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodNameContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodNameContextAttrs<'input> for MethodNameContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodName(&mut self,)
	-> Result<Rc<MethodNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_methodName);
        let mut _localctx: Rc<MethodNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(729);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ambiguousName ----------------
pub type AmbiguousNameContextAll<'input> = AmbiguousNameContext<'input>;


pub type AmbiguousNameContext<'input> = BaseParserRuleContext<'input,AmbiguousNameContextExt<'input>>;

#[derive(Clone)]
pub struct AmbiguousNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AmbiguousNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AmbiguousNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ambiguousName(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_ambiguousName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AmbiguousNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ambiguousName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ambiguousName }
}
antlr_rust::tid!{AmbiguousNameContextExt<'a>}

impl<'input> AmbiguousNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AmbiguousNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AmbiguousNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AmbiguousNameContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AmbiguousNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ambiguousName(&self) -> Option<Rc<AmbiguousNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> AmbiguousNameContextAttrs<'input> for AmbiguousNameContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  ambiguousName(&mut self,)
	-> Result<Rc<AmbiguousNameContextAll<'input>>,ANTLRError> {
		self.ambiguousName_rec(0)
	}

	fn ambiguousName_rec(&mut self, _p: isize)
	-> Result<Rc<AmbiguousNameContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = AmbiguousNameContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 62, RULE_ambiguousName, _p);
	    let mut _localctx: Rc<AmbiguousNameContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 62;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule identifier*/
			recog.base.set_state(732);
			recog.identifier()?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(739);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(36,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = AmbiguousNameContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_ambiguousName);
					_localctx = tmp;
					recog.base.set_state(734);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(735);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(736);
					recog.identifier()?;

					}
					} 
				}
				recog.base.set_state(741);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(36,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- compilationUnit ----------------
pub type CompilationUnitContextAll<'input> = CompilationUnitContext<'input>;


pub type CompilationUnitContext<'input> = BaseParserRuleContext<'input,CompilationUnitContextExt<'input>>;

#[derive(Clone)]
pub struct CompilationUnitContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for CompilationUnitContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for CompilationUnitContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_compilationUnit(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_compilationUnit(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CompilationUnitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_compilationUnit }
	//fn type_rule_index() -> usize where Self: Sized { RULE_compilationUnit }
}
antlr_rust::tid!{CompilationUnitContextExt<'a>}

impl<'input> CompilationUnitContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CompilationUnitContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CompilationUnitContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CompilationUnitContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<CompilationUnitContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}
fn ordinaryCompilation(&self) -> Option<Rc<OrdinaryCompilationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modularCompilation(&self) -> Option<Rc<ModularCompilationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CompilationUnitContextAttrs<'input> for CompilationUnitContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn compilationUnit(&mut self,)
	-> Result<Rc<CompilationUnitContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CompilationUnitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_compilationUnit);
        let mut _localctx: Rc<CompilationUnitContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(744);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(37,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule ordinaryCompilation*/
					recog.base.set_state(742);
					recog.ordinaryCompilation()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule modularCompilation*/
					recog.base.set_state(743);
					recog.modularCompilation()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(746);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ordinaryCompilation ----------------
pub type OrdinaryCompilationContextAll<'input> = OrdinaryCompilationContext<'input>;


pub type OrdinaryCompilationContext<'input> = BaseParserRuleContext<'input,OrdinaryCompilationContextExt<'input>>;

#[derive(Clone)]
pub struct OrdinaryCompilationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for OrdinaryCompilationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for OrdinaryCompilationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ordinaryCompilation(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_ordinaryCompilation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for OrdinaryCompilationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ordinaryCompilation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ordinaryCompilation }
}
antlr_rust::tid!{OrdinaryCompilationContextExt<'a>}

impl<'input> OrdinaryCompilationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrdinaryCompilationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrdinaryCompilationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrdinaryCompilationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<OrdinaryCompilationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}
fn packageDeclaration(&self) -> Option<Rc<PackageDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn importDeclaration_all(&self) ->  Vec<Rc<ImportDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn importDeclaration(&self, i: usize) -> Option<Rc<ImportDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeDeclaration_all(&self) ->  Vec<Rc<TypeDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeDeclaration(&self, i: usize) -> Option<Rc<TypeDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> OrdinaryCompilationContextAttrs<'input> for OrdinaryCompilationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ordinaryCompilation(&mut self,)
	-> Result<Rc<OrdinaryCompilationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrdinaryCompilationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_ordinaryCompilation);
        let mut _localctx: Rc<OrdinaryCompilationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(749);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(38,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule packageDeclaration*/
					recog.base.set_state(748);
					recog.packageDeclaration()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(754);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==IMPORT {
				{
				{
				/*InvokeRule importDeclaration*/
				recog.base.set_state(751);
				recog.importDeclaration()?;

				}
				}
				recog.base.set_state(756);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(760);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABSTRACT) | (1usize << CLASS) | (1usize << ENUM) | (1usize << FINAL) | (1usize << INTERFACE))) != 0) || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (PRIVATE - 37)) | (1usize << (PROTECTED - 37)) | (1usize << (PUBLIC - 37)) | (1usize << (STATIC - 37)) | (1usize << (STRICTFP - 37)))) != 0) || _la==SEMI || _la==AT {
				{
				{
				/*InvokeRule typeDeclaration*/
				recog.base.set_state(757);
				recog.typeDeclaration()?;

				}
				}
				recog.base.set_state(762);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(763);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- modularCompilation ----------------
pub type ModularCompilationContextAll<'input> = ModularCompilationContext<'input>;


pub type ModularCompilationContext<'input> = BaseParserRuleContext<'input,ModularCompilationContextExt<'input>>;

#[derive(Clone)]
pub struct ModularCompilationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ModularCompilationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ModularCompilationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_modularCompilation(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_modularCompilation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ModularCompilationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_modularCompilation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_modularCompilation }
}
antlr_rust::tid!{ModularCompilationContextExt<'a>}

impl<'input> ModularCompilationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModularCompilationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModularCompilationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModularCompilationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ModularCompilationContextExt<'input>>{

fn moduleDeclaration(&self) -> Option<Rc<ModuleDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn importDeclaration_all(&self) ->  Vec<Rc<ImportDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn importDeclaration(&self, i: usize) -> Option<Rc<ImportDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ModularCompilationContextAttrs<'input> for ModularCompilationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn modularCompilation(&mut self,)
	-> Result<Rc<ModularCompilationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModularCompilationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_modularCompilation);
        let mut _localctx: Rc<ModularCompilationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(768);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==IMPORT {
				{
				{
				/*InvokeRule importDeclaration*/
				recog.base.set_state(765);
				recog.importDeclaration()?;

				}
				}
				recog.base.set_state(770);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule moduleDeclaration*/
			recog.base.set_state(771);
			recog.moduleDeclaration()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packageDeclaration ----------------
pub type PackageDeclarationContextAll<'input> = PackageDeclarationContext<'input>;


pub type PackageDeclarationContext<'input> = BaseParserRuleContext<'input,PackageDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct PackageDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PackageDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PackageDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packageDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_packageDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PackageDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packageDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packageDeclaration }
}
antlr_rust::tid!{PackageDeclarationContextExt<'a>}

impl<'input> PackageDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackageDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackageDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackageDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PackageDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PACKAGE
/// Returns `None` if there is no child corresponding to token PACKAGE
fn PACKAGE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PACKAGE, 0)
}
fn packageName(&self) -> Option<Rc<PackageNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn packageModifier_all(&self) ->  Vec<Rc<PackageModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn packageModifier(&self, i: usize) -> Option<Rc<PackageModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PackageDeclarationContextAttrs<'input> for PackageDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packageDeclaration(&mut self,)
	-> Result<Rc<PackageDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackageDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_packageDeclaration);
        let mut _localctx: Rc<PackageDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(776);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule packageModifier*/
				recog.base.set_state(773);
				recog.packageModifier()?;

				}
				}
				recog.base.set_state(778);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(779);
			recog.base.match_token(PACKAGE,&mut recog.err_handler)?;

			/*InvokeRule packageName*/
			recog.base.set_state(780);
			recog.packageName_rec(0)?;

			recog.base.set_state(781);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packageModifier ----------------
pub type PackageModifierContextAll<'input> = PackageModifierContext<'input>;


pub type PackageModifierContext<'input> = BaseParserRuleContext<'input,PackageModifierContextExt<'input>>;

#[derive(Clone)]
pub struct PackageModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PackageModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PackageModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packageModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_packageModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PackageModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packageModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packageModifier }
}
antlr_rust::tid!{PackageModifierContextExt<'a>}

impl<'input> PackageModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackageModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackageModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackageModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PackageModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackageModifierContextAttrs<'input> for PackageModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packageModifier(&mut self,)
	-> Result<Rc<PackageModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackageModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_packageModifier);
        let mut _localctx: Rc<PackageModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule annotation*/
			recog.base.set_state(783);
			recog.annotation()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- importDeclaration ----------------
pub type ImportDeclarationContextAll<'input> = ImportDeclarationContext<'input>;


pub type ImportDeclarationContext<'input> = BaseParserRuleContext<'input,ImportDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ImportDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ImportDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ImportDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_importDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_importDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ImportDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_importDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_importDeclaration }
}
antlr_rust::tid!{ImportDeclarationContextExt<'a>}

impl<'input> ImportDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImportDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImportDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImportDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ImportDeclarationContextExt<'input>>{

fn singleTypeImportDeclaration(&self) -> Option<Rc<SingleTypeImportDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeImportOnDemandDeclaration(&self) -> Option<Rc<TypeImportOnDemandDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn singleStaticImportDeclaration(&self) -> Option<Rc<SingleStaticImportDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn staticImportOnDemandDeclaration(&self) -> Option<Rc<StaticImportOnDemandDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ImportDeclarationContextAttrs<'input> for ImportDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn importDeclaration(&mut self,)
	-> Result<Rc<ImportDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImportDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_importDeclaration);
        let mut _localctx: Rc<ImportDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(789);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(43,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule singleTypeImportDeclaration*/
					recog.base.set_state(785);
					recog.singleTypeImportDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeImportOnDemandDeclaration*/
					recog.base.set_state(786);
					recog.typeImportOnDemandDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule singleStaticImportDeclaration*/
					recog.base.set_state(787);
					recog.singleStaticImportDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule staticImportOnDemandDeclaration*/
					recog.base.set_state(788);
					recog.staticImportOnDemandDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- singleTypeImportDeclaration ----------------
pub type SingleTypeImportDeclarationContextAll<'input> = SingleTypeImportDeclarationContext<'input>;


pub type SingleTypeImportDeclarationContext<'input> = BaseParserRuleContext<'input,SingleTypeImportDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct SingleTypeImportDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SingleTypeImportDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SingleTypeImportDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_singleTypeImportDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_singleTypeImportDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SingleTypeImportDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_singleTypeImportDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_singleTypeImportDeclaration }
}
antlr_rust::tid!{SingleTypeImportDeclarationContextExt<'a>}

impl<'input> SingleTypeImportDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SingleTypeImportDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SingleTypeImportDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SingleTypeImportDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SingleTypeImportDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> SingleTypeImportDeclarationContextAttrs<'input> for SingleTypeImportDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn singleTypeImportDeclaration(&mut self,)
	-> Result<Rc<SingleTypeImportDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SingleTypeImportDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_singleTypeImportDeclaration);
        let mut _localctx: Rc<SingleTypeImportDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(791);
			recog.base.match_token(IMPORT,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(792);
			recog.typeName()?;

			recog.base.set_state(793);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeImportOnDemandDeclaration ----------------
pub type TypeImportOnDemandDeclarationContextAll<'input> = TypeImportOnDemandDeclarationContext<'input>;


pub type TypeImportOnDemandDeclarationContext<'input> = BaseParserRuleContext<'input,TypeImportOnDemandDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct TypeImportOnDemandDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeImportOnDemandDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeImportOnDemandDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeImportOnDemandDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeImportOnDemandDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeImportOnDemandDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeImportOnDemandDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeImportOnDemandDeclaration }
}
antlr_rust::tid!{TypeImportOnDemandDeclarationContextExt<'a>}

impl<'input> TypeImportOnDemandDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeImportOnDemandDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeImportOnDemandDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeImportOnDemandDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeImportOnDemandDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
fn packageOrTypeName(&self) -> Option<Rc<PackageOrTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token MUL
/// Returns `None` if there is no child corresponding to token MUL
fn MUL(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(MUL, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> TypeImportOnDemandDeclarationContextAttrs<'input> for TypeImportOnDemandDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeImportOnDemandDeclaration(&mut self,)
	-> Result<Rc<TypeImportOnDemandDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeImportOnDemandDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_typeImportOnDemandDeclaration);
        let mut _localctx: Rc<TypeImportOnDemandDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(795);
			recog.base.match_token(IMPORT,&mut recog.err_handler)?;

			/*InvokeRule packageOrTypeName*/
			recog.base.set_state(796);
			recog.packageOrTypeName_rec(0)?;

			recog.base.set_state(797);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(798);
			recog.base.match_token(MUL,&mut recog.err_handler)?;

			recog.base.set_state(799);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- singleStaticImportDeclaration ----------------
pub type SingleStaticImportDeclarationContextAll<'input> = SingleStaticImportDeclarationContext<'input>;


pub type SingleStaticImportDeclarationContext<'input> = BaseParserRuleContext<'input,SingleStaticImportDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct SingleStaticImportDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SingleStaticImportDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SingleStaticImportDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_singleStaticImportDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_singleStaticImportDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SingleStaticImportDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_singleStaticImportDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_singleStaticImportDeclaration }
}
antlr_rust::tid!{SingleStaticImportDeclarationContextExt<'a>}

impl<'input> SingleStaticImportDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SingleStaticImportDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SingleStaticImportDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SingleStaticImportDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SingleStaticImportDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> SingleStaticImportDeclarationContextAttrs<'input> for SingleStaticImportDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn singleStaticImportDeclaration(&mut self,)
	-> Result<Rc<SingleStaticImportDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SingleStaticImportDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_singleStaticImportDeclaration);
        let mut _localctx: Rc<SingleStaticImportDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(801);
			recog.base.match_token(IMPORT,&mut recog.err_handler)?;

			recog.base.set_state(802);
			recog.base.match_token(STATIC,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(803);
			recog.typeName()?;

			recog.base.set_state(804);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(805);
			recog.identifier()?;

			recog.base.set_state(806);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- staticImportOnDemandDeclaration ----------------
pub type StaticImportOnDemandDeclarationContextAll<'input> = StaticImportOnDemandDeclarationContext<'input>;


pub type StaticImportOnDemandDeclarationContext<'input> = BaseParserRuleContext<'input,StaticImportOnDemandDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct StaticImportOnDemandDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for StaticImportOnDemandDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for StaticImportOnDemandDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_staticImportOnDemandDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_staticImportOnDemandDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StaticImportOnDemandDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_staticImportOnDemandDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_staticImportOnDemandDeclaration }
}
antlr_rust::tid!{StaticImportOnDemandDeclarationContextExt<'a>}

impl<'input> StaticImportOnDemandDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StaticImportOnDemandDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StaticImportOnDemandDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StaticImportOnDemandDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<StaticImportOnDemandDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token MUL
/// Returns `None` if there is no child corresponding to token MUL
fn MUL(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(MUL, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> StaticImportOnDemandDeclarationContextAttrs<'input> for StaticImportOnDemandDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn staticImportOnDemandDeclaration(&mut self,)
	-> Result<Rc<StaticImportOnDemandDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StaticImportOnDemandDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_staticImportOnDemandDeclaration);
        let mut _localctx: Rc<StaticImportOnDemandDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(808);
			recog.base.match_token(IMPORT,&mut recog.err_handler)?;

			recog.base.set_state(809);
			recog.base.match_token(STATIC,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(810);
			recog.typeName()?;

			recog.base.set_state(811);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(812);
			recog.base.match_token(MUL,&mut recog.err_handler)?;

			recog.base.set_state(813);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeDeclaration ----------------
pub type TypeDeclarationContextAll<'input> = TypeDeclarationContext<'input>;


pub type TypeDeclarationContext<'input> = BaseParserRuleContext<'input,TypeDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct TypeDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeDeclaration }
}
antlr_rust::tid!{TypeDeclarationContextExt<'a>}

impl<'input> TypeDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeDeclarationContextExt<'input>>{

fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceDeclaration(&self) -> Option<Rc<InterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> TypeDeclarationContextAttrs<'input> for TypeDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeDeclaration(&mut self,)
	-> Result<Rc<TypeDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_typeDeclaration);
        let mut _localctx: Rc<TypeDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(818);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(44,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(815);
					recog.classDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule interfaceDeclaration*/
					recog.base.set_state(816);
					recog.interfaceDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(817);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moduleDeclaration ----------------
pub type ModuleDeclarationContextAll<'input> = ModuleDeclarationContext<'input>;


pub type ModuleDeclarationContext<'input> = BaseParserRuleContext<'input,ModuleDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ModuleDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ModuleDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ModuleDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moduleDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_moduleDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ModuleDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moduleDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moduleDeclaration }
}
antlr_rust::tid!{ModuleDeclarationContextExt<'a>}

impl<'input> ModuleDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModuleDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModuleDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModuleDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ModuleDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token MODULE
/// Returns `None` if there is no child corresponding to token MODULE
fn MODULE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(MODULE, 0)
}
fn moduleName(&self) -> Option<Rc<ModuleNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token OPEN
/// Returns `None` if there is no child corresponding to token OPEN
fn OPEN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(OPEN, 0)
}
fn moduleDirective_all(&self) ->  Vec<Rc<ModuleDirectiveContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn moduleDirective(&self, i: usize) -> Option<Rc<ModuleDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ModuleDeclarationContextAttrs<'input> for ModuleDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moduleDeclaration(&mut self,)
	-> Result<Rc<ModuleDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModuleDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_moduleDeclaration);
        let mut _localctx: Rc<ModuleDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(823);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(820);
				recog.annotation()?;

				}
				}
				recog.base.set_state(825);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(827);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==OPEN {
				{
				recog.base.set_state(826);
				recog.base.match_token(OPEN,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(829);
			recog.base.match_token(MODULE,&mut recog.err_handler)?;

			/*InvokeRule moduleName*/
			recog.base.set_state(830);
			recog.moduleName_rec(0)?;

			recog.base.set_state(831);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(835);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==EXPORTS || ((((_la - 35)) & !0x3f) == 0 && ((1usize << (_la - 35)) & ((1usize << (OPERNS - 35)) | (1usize << (PROVIDES - 35)) | (1usize << (REQUIRES - 35)) | (1usize << (USES - 35)))) != 0) {
				{
				{
				/*InvokeRule moduleDirective*/
				recog.base.set_state(832);
				recog.moduleDirective()?;

				}
				}
				recog.base.set_state(837);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(838);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moduleDirective ----------------
pub type ModuleDirectiveContextAll<'input> = ModuleDirectiveContext<'input>;


pub type ModuleDirectiveContext<'input> = BaseParserRuleContext<'input,ModuleDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct ModuleDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ModuleDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ModuleDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moduleDirective(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_moduleDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ModuleDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moduleDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moduleDirective }
}
antlr_rust::tid!{ModuleDirectiveContextExt<'a>}

impl<'input> ModuleDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModuleDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModuleDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModuleDirectiveContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ModuleDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token REQUIRES
/// Returns `None` if there is no child corresponding to token REQUIRES
fn REQUIRES(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(REQUIRES, 0)
}
fn moduleName_all(&self) ->  Vec<Rc<ModuleNameContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn moduleName(&self, i: usize) -> Option<Rc<ModuleNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn requiresModifier_all(&self) ->  Vec<Rc<RequiresModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn requiresModifier(&self, i: usize) -> Option<Rc<RequiresModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token EXPORTS
/// Returns `None` if there is no child corresponding to token EXPORTS
fn EXPORTS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(EXPORTS, 0)
}
fn packageName(&self) -> Option<Rc<PackageNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token TO
/// Returns `None` if there is no child corresponding to token TO
fn TO(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(TO, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves first TerminalNode corresponding to token OPERNS
/// Returns `None` if there is no child corresponding to token OPERNS
fn OPERNS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(OPERNS, 0)
}
/// Retrieves first TerminalNode corresponding to token USES
/// Returns `None` if there is no child corresponding to token USES
fn USES(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(USES, 0)
}
fn typeName_all(&self) ->  Vec<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeName(&self, i: usize) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token PROVIDES
/// Returns `None` if there is no child corresponding to token PROVIDES
fn PROVIDES(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PROVIDES, 0)
}
/// Retrieves first TerminalNode corresponding to token WITH
/// Returns `None` if there is no child corresponding to token WITH
fn WITH(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(WITH, 0)
}

}

impl<'input> ModuleDirectiveContextAttrs<'input> for ModuleDirectiveContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moduleDirective(&mut self,)
	-> Result<Rc<ModuleDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModuleDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_moduleDirective);
        let mut _localctx: Rc<ModuleDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(897);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 REQUIRES 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(840);
					recog.base.match_token(REQUIRES,&mut recog.err_handler)?;

					recog.base.set_state(844);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==STATIC || _la==TRANSITIVE {
						{
						{
						/*InvokeRule requiresModifier*/
						recog.base.set_state(841);
						recog.requiresModifier()?;

						}
						}
						recog.base.set_state(846);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule moduleName*/
					recog.base.set_state(847);
					recog.moduleName_rec(0)?;

					recog.base.set_state(848);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

			 EXPORTS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(850);
					recog.base.match_token(EXPORTS,&mut recog.err_handler)?;

					/*InvokeRule packageName*/
					recog.base.set_state(851);
					recog.packageName_rec(0)?;

					recog.base.set_state(861);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TO {
						{
						recog.base.set_state(852);
						recog.base.match_token(TO,&mut recog.err_handler)?;

						/*InvokeRule moduleName*/
						recog.base.set_state(853);
						recog.moduleName_rec(0)?;

						recog.base.set_state(858);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==COMMA {
							{
							{
							recog.base.set_state(854);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule moduleName*/
							recog.base.set_state(855);
							recog.moduleName_rec(0)?;

							}
							}
							recog.base.set_state(860);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						}
					}

					recog.base.set_state(863);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

			 OPERNS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(865);
					recog.base.match_token(OPERNS,&mut recog.err_handler)?;

					/*InvokeRule packageName*/
					recog.base.set_state(866);
					recog.packageName_rec(0)?;

					recog.base.set_state(876);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TO {
						{
						recog.base.set_state(867);
						recog.base.match_token(TO,&mut recog.err_handler)?;

						/*InvokeRule moduleName*/
						recog.base.set_state(868);
						recog.moduleName_rec(0)?;

						recog.base.set_state(873);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==COMMA {
							{
							{
							recog.base.set_state(869);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule moduleName*/
							recog.base.set_state(870);
							recog.moduleName_rec(0)?;

							}
							}
							recog.base.set_state(875);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						}
					}

					recog.base.set_state(878);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

			 USES 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(880);
					recog.base.match_token(USES,&mut recog.err_handler)?;

					/*InvokeRule typeName*/
					recog.base.set_state(881);
					recog.typeName()?;

					recog.base.set_state(882);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

			 PROVIDES 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(884);
					recog.base.match_token(PROVIDES,&mut recog.err_handler)?;

					/*InvokeRule typeName*/
					recog.base.set_state(885);
					recog.typeName()?;

					recog.base.set_state(886);
					recog.base.match_token(WITH,&mut recog.err_handler)?;

					/*InvokeRule typeName*/
					recog.base.set_state(887);
					recog.typeName()?;

					recog.base.set_state(892);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						recog.base.set_state(888);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule typeName*/
						recog.base.set_state(889);
						recog.typeName()?;

						}
						}
						recog.base.set_state(894);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(895);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- requiresModifier ----------------
pub type RequiresModifierContextAll<'input> = RequiresModifierContext<'input>;


pub type RequiresModifierContext<'input> = BaseParserRuleContext<'input,RequiresModifierContextExt<'input>>;

#[derive(Clone)]
pub struct RequiresModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for RequiresModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for RequiresModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_requiresModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_requiresModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RequiresModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_requiresModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_requiresModifier }
}
antlr_rust::tid!{RequiresModifierContextExt<'a>}

impl<'input> RequiresModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RequiresModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RequiresModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RequiresModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<RequiresModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TRANSITIVE
/// Returns `None` if there is no child corresponding to token TRANSITIVE
fn TRANSITIVE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(TRANSITIVE, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}

}

impl<'input> RequiresModifierContextAttrs<'input> for RequiresModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn requiresModifier(&mut self,)
	-> Result<Rc<RequiresModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RequiresModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_requiresModifier);
        let mut _localctx: Rc<RequiresModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(899);
			_la = recog.base.input.la(1);
			if { !(_la==STATIC || _la==TRANSITIVE) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classDeclaration ----------------
pub type ClassDeclarationContextAll<'input> = ClassDeclarationContext<'input>;


pub type ClassDeclarationContext<'input> = BaseParserRuleContext<'input,ClassDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ClassDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classDeclaration }
}
antlr_rust::tid!{ClassDeclarationContextExt<'a>}

impl<'input> ClassDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassDeclarationContextExt<'input>>{

fn normalClassDeclaration(&self) -> Option<Rc<NormalClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enumDeclaration(&self) -> Option<Rc<EnumDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassDeclarationContextAttrs<'input> for ClassDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classDeclaration(&mut self,)
	-> Result<Rc<ClassDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_classDeclaration);
        let mut _localctx: Rc<ClassDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(903);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(55,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule normalClassDeclaration*/
					recog.base.set_state(901);
					recog.normalClassDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule enumDeclaration*/
					recog.base.set_state(902);
					recog.enumDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- normalClassDeclaration ----------------
pub type NormalClassDeclarationContextAll<'input> = NormalClassDeclarationContext<'input>;


pub type NormalClassDeclarationContext<'input> = BaseParserRuleContext<'input,NormalClassDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct NormalClassDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for NormalClassDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for NormalClassDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_normalClassDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_normalClassDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NormalClassDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_normalClassDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_normalClassDeclaration }
}
antlr_rust::tid!{NormalClassDeclarationContextExt<'a>}

impl<'input> NormalClassDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NormalClassDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NormalClassDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NormalClassDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<NormalClassDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classModifier_all(&self) ->  Vec<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classModifier(&self, i: usize) -> Option<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn superclass(&self) -> Option<Rc<SuperclassContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn superinterfaces(&self) -> Option<Rc<SuperinterfacesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NormalClassDeclarationContextAttrs<'input> for NormalClassDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn normalClassDeclaration(&mut self,)
	-> Result<Rc<NormalClassDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NormalClassDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_normalClassDeclaration);
        let mut _localctx: Rc<NormalClassDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(908);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==ABSTRACT || _la==FINAL || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (PRIVATE - 37)) | (1usize << (PROTECTED - 37)) | (1usize << (PUBLIC - 37)) | (1usize << (STATIC - 37)) | (1usize << (STRICTFP - 37)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule classModifier*/
				recog.base.set_state(905);
				recog.classModifier()?;

				}
				}
				recog.base.set_state(910);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(911);
			recog.base.match_token(CLASS,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(912);
			recog.identifier()?;

			recog.base.set_state(914);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeParameters*/
				recog.base.set_state(913);
				recog.typeParameters()?;

				}
			}

			recog.base.set_state(917);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXTENDS {
				{
				/*InvokeRule superclass*/
				recog.base.set_state(916);
				recog.superclass()?;

				}
			}

			recog.base.set_state(920);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==IMPLEMENTS {
				{
				/*InvokeRule superinterfaces*/
				recog.base.set_state(919);
				recog.superinterfaces()?;

				}
			}

			/*InvokeRule classBody*/
			recog.base.set_state(922);
			recog.classBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classModifier ----------------
pub type ClassModifierContextAll<'input> = ClassModifierContext<'input>;


pub type ClassModifierContext<'input> = BaseParserRuleContext<'input,ClassModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ClassModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classModifier }
}
antlr_rust::tid!{ClassModifierContextExt<'a>}

impl<'input> ClassModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token STRICTFP
/// Returns `None` if there is no child corresponding to token STRICTFP
fn STRICTFP(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STRICTFP, 0)
}

}

impl<'input> ClassModifierContextAttrs<'input> for ClassModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classModifier(&mut self,)
	-> Result<Rc<ClassModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_classModifier);
        let mut _localctx: Rc<ClassModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(932);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(924);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(925);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PROTECTED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(926);
					recog.base.match_token(PROTECTED,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(927);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

			 ABSTRACT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(928);
					recog.base.match_token(ABSTRACT,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(929);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 FINAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(930);
					recog.base.match_token(FINAL,&mut recog.err_handler)?;

					}
				}

			 STRICTFP 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(931);
					recog.base.match_token(STRICTFP,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameters ----------------
pub type TypeParametersContextAll<'input> = TypeParametersContext<'input>;


pub type TypeParametersContext<'input> = BaseParserRuleContext<'input,TypeParametersContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeParametersContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeParametersContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameters(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeParameters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameters }
}
antlr_rust::tid!{TypeParametersContextExt<'a>}

impl<'input> TypeParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParametersContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeParametersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LT
/// Returns `None` if there is no child corresponding to token LT
fn LT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LT, 0)
}
fn typeParameterList(&self) -> Option<Rc<TypeParameterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token GT
/// Returns `None` if there is no child corresponding to token GT
fn GT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(GT, 0)
}

}

impl<'input> TypeParametersContextAttrs<'input> for TypeParametersContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameters(&mut self,)
	-> Result<Rc<TypeParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_typeParameters);
        let mut _localctx: Rc<TypeParametersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(934);
			recog.base.match_token(LT,&mut recog.err_handler)?;

			/*InvokeRule typeParameterList*/
			recog.base.set_state(935);
			recog.typeParameterList()?;

			recog.base.set_state(936);
			recog.base.match_token(GT,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameterList ----------------
pub type TypeParameterListContextAll<'input> = TypeParameterListContext<'input>;


pub type TypeParameterListContext<'input> = BaseParserRuleContext<'input,TypeParameterListContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeParameterListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeParameterListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameterList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeParameterList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeParameterListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameterList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameterList }
}
antlr_rust::tid!{TypeParameterListContextExt<'a>}

impl<'input> TypeParameterListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeParameterListContextExt<'input>>{

fn typeParameter_all(&self) ->  Vec<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeParameter(&self, i: usize) -> Option<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TypeParameterListContextAttrs<'input> for TypeParameterListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameterList(&mut self,)
	-> Result<Rc<TypeParameterListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_typeParameterList);
        let mut _localctx: Rc<TypeParameterListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule typeParameter*/
			recog.base.set_state(938);
			recog.typeParameter()?;

			recog.base.set_state(943);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(939);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule typeParameter*/
				recog.base.set_state(940);
				recog.typeParameter()?;

				}
				}
				recog.base.set_state(945);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- superclass ----------------
pub type SuperclassContextAll<'input> = SuperclassContext<'input>;


pub type SuperclassContext<'input> = BaseParserRuleContext<'input,SuperclassContextExt<'input>>;

#[derive(Clone)]
pub struct SuperclassContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SuperclassContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SuperclassContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_superclass(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_superclass(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SuperclassContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_superclass }
	//fn type_rule_index() -> usize where Self: Sized { RULE_superclass }
}
antlr_rust::tid!{SuperclassContextExt<'a>}

impl<'input> SuperclassContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SuperclassContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SuperclassContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SuperclassContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SuperclassContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXTENDS
/// Returns `None` if there is no child corresponding to token EXTENDS
fn EXTENDS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(EXTENDS, 0)
}
fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SuperclassContextAttrs<'input> for SuperclassContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn superclass(&mut self,)
	-> Result<Rc<SuperclassContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SuperclassContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_superclass);
        let mut _localctx: Rc<SuperclassContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(946);
			recog.base.match_token(EXTENDS,&mut recog.err_handler)?;

			/*InvokeRule classType*/
			recog.base.set_state(947);
			recog.classType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- superinterfaces ----------------
pub type SuperinterfacesContextAll<'input> = SuperinterfacesContext<'input>;


pub type SuperinterfacesContext<'input> = BaseParserRuleContext<'input,SuperinterfacesContextExt<'input>>;

#[derive(Clone)]
pub struct SuperinterfacesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SuperinterfacesContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SuperinterfacesContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_superinterfaces(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_superinterfaces(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SuperinterfacesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_superinterfaces }
	//fn type_rule_index() -> usize where Self: Sized { RULE_superinterfaces }
}
antlr_rust::tid!{SuperinterfacesContextExt<'a>}

impl<'input> SuperinterfacesContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SuperinterfacesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SuperinterfacesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SuperinterfacesContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SuperinterfacesContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPLEMENTS
/// Returns `None` if there is no child corresponding to token IMPLEMENTS
fn IMPLEMENTS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(IMPLEMENTS, 0)
}
fn interfaceTypeList(&self) -> Option<Rc<InterfaceTypeListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SuperinterfacesContextAttrs<'input> for SuperinterfacesContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn superinterfaces(&mut self,)
	-> Result<Rc<SuperinterfacesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SuperinterfacesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_superinterfaces);
        let mut _localctx: Rc<SuperinterfacesContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(949);
			recog.base.match_token(IMPLEMENTS,&mut recog.err_handler)?;

			/*InvokeRule interfaceTypeList*/
			recog.base.set_state(950);
			recog.interfaceTypeList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceTypeList ----------------
pub type InterfaceTypeListContextAll<'input> = InterfaceTypeListContext<'input>;


pub type InterfaceTypeListContext<'input> = BaseParserRuleContext<'input,InterfaceTypeListContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceTypeListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InterfaceTypeListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InterfaceTypeListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceTypeList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_interfaceTypeList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InterfaceTypeListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceTypeList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceTypeList }
}
antlr_rust::tid!{InterfaceTypeListContextExt<'a>}

impl<'input> InterfaceTypeListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceTypeListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceTypeListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceTypeListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InterfaceTypeListContextExt<'input>>{

fn interfaceType_all(&self) ->  Vec<Rc<InterfaceTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceType(&self, i: usize) -> Option<Rc<InterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> InterfaceTypeListContextAttrs<'input> for InterfaceTypeListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceTypeList(&mut self,)
	-> Result<Rc<InterfaceTypeListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceTypeListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_interfaceTypeList);
        let mut _localctx: Rc<InterfaceTypeListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule interfaceType*/
			recog.base.set_state(952);
			recog.interfaceType()?;

			recog.base.set_state(957);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(953);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule interfaceType*/
				recog.base.set_state(954);
				recog.interfaceType()?;

				}
				}
				recog.base.set_state(959);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classBody ----------------
pub type ClassBodyContextAll<'input> = ClassBodyContext<'input>;


pub type ClassBodyContext<'input> = BaseParserRuleContext<'input,ClassBodyContextExt<'input>>;

#[derive(Clone)]
pub struct ClassBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classBody(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classBody }
}
antlr_rust::tid!{ClassBodyContextExt<'a>}

impl<'input> ClassBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassBodyContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn classBodyDeclaration_all(&self) ->  Vec<Rc<ClassBodyDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classBodyDeclaration(&self, i: usize) -> Option<Rc<ClassBodyDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ClassBodyContextAttrs<'input> for ClassBodyContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classBody(&mut self,)
	-> Result<Rc<ClassBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_classBody);
        let mut _localctx: Rc<ClassBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(960);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(964);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABSTRACT) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << DOUBLE) | (1usize << ENUM) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << INT) | (1usize << INTERFACE) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (NATIVE - 32)) | (1usize << (OPEN - 32)) | (1usize << (OPERNS - 32)) | (1usize << (PRIVATE - 32)) | (1usize << (PROTECTED - 32)) | (1usize << (PROVIDES - 32)) | (1usize << (PUBLIC - 32)) | (1usize << (REQUIRES - 32)) | (1usize << (SHORT - 32)) | (1usize << (STATIC - 32)) | (1usize << (STRICTFP - 32)) | (1usize << (SYNCHRONIZED - 32)) | (1usize << (TO - 32)) | (1usize << (TRANSIENT - 32)) | (1usize << (USES - 32)) | (1usize << (VOID - 32)) | (1usize << (VOLATILE - 32)) | (1usize << (WITH - 32)))) != 0) || ((((_la - 70)) & !0x3f) == 0 && ((1usize << (_la - 70)) & ((1usize << (LBRACE - 70)) | (1usize << (SEMI - 70)) | (1usize << (AT - 70)) | (1usize << (LT - 70)))) != 0) || _la==Identifier {
				{
				{
				/*InvokeRule classBodyDeclaration*/
				recog.base.set_state(961);
				recog.classBodyDeclaration()?;

				}
				}
				recog.base.set_state(966);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(967);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classBodyDeclaration ----------------
pub type ClassBodyDeclarationContextAll<'input> = ClassBodyDeclarationContext<'input>;


pub type ClassBodyDeclarationContext<'input> = BaseParserRuleContext<'input,ClassBodyDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ClassBodyDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassBodyDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassBodyDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classBodyDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classBodyDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassBodyDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classBodyDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classBodyDeclaration }
}
antlr_rust::tid!{ClassBodyDeclarationContextExt<'a>}

impl<'input> ClassBodyDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassBodyDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassBodyDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassBodyDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassBodyDeclarationContextExt<'input>>{

fn classMemberDeclaration(&self) -> Option<Rc<ClassMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceInitializer(&self) -> Option<Rc<InstanceInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn staticInitializer(&self) -> Option<Rc<StaticInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constructorDeclaration(&self) -> Option<Rc<ConstructorDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassBodyDeclarationContextAttrs<'input> for ClassBodyDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classBodyDeclaration(&mut self,)
	-> Result<Rc<ClassBodyDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassBodyDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_classBodyDeclaration);
        let mut _localctx: Rc<ClassBodyDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(973);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(64,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classMemberDeclaration*/
					recog.base.set_state(969);
					recog.classMemberDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule instanceInitializer*/
					recog.base.set_state(970);
					recog.instanceInitializer()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule staticInitializer*/
					recog.base.set_state(971);
					recog.staticInitializer()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule constructorDeclaration*/
					recog.base.set_state(972);
					recog.constructorDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classMemberDeclaration ----------------
pub type ClassMemberDeclarationContextAll<'input> = ClassMemberDeclarationContext<'input>;


pub type ClassMemberDeclarationContext<'input> = BaseParserRuleContext<'input,ClassMemberDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ClassMemberDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassMemberDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassMemberDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classMemberDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classMemberDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassMemberDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classMemberDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classMemberDeclaration }
}
antlr_rust::tid!{ClassMemberDeclarationContextExt<'a>}

impl<'input> ClassMemberDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassMemberDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassMemberDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassMemberDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassMemberDeclarationContextExt<'input>>{

fn fieldDeclaration(&self) -> Option<Rc<FieldDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodDeclaration(&self) -> Option<Rc<MethodDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceDeclaration(&self) -> Option<Rc<InterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> ClassMemberDeclarationContextAttrs<'input> for ClassMemberDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classMemberDeclaration(&mut self,)
	-> Result<Rc<ClassMemberDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassMemberDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 112, RULE_classMemberDeclaration);
        let mut _localctx: Rc<ClassMemberDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(980);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(65,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule fieldDeclaration*/
					recog.base.set_state(975);
					recog.fieldDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule methodDeclaration*/
					recog.base.set_state(976);
					recog.methodDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(977);
					recog.classDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule interfaceDeclaration*/
					recog.base.set_state(978);
					recog.interfaceDeclaration()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(979);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldDeclaration ----------------
pub type FieldDeclarationContextAll<'input> = FieldDeclarationContext<'input>;


pub type FieldDeclarationContext<'input> = BaseParserRuleContext<'input,FieldDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct FieldDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for FieldDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for FieldDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_fieldDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldDeclaration }
}
antlr_rust::tid!{FieldDeclarationContextExt<'a>}

impl<'input> FieldDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<FieldDeclarationContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorList(&self) -> Option<Rc<VariableDeclaratorListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn fieldModifier_all(&self) ->  Vec<Rc<FieldModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn fieldModifier(&self, i: usize) -> Option<Rc<FieldModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> FieldDeclarationContextAttrs<'input> for FieldDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldDeclaration(&mut self,)
	-> Result<Rc<FieldDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 114, RULE_fieldDeclaration);
        let mut _localctx: Rc<FieldDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(985);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 19)) & !0x3f) == 0 && ((1usize << (_la - 19)) & ((1usize << (FINAL - 19)) | (1usize << (PRIVATE - 19)) | (1usize << (PROTECTED - 19)) | (1usize << (PUBLIC - 19)) | (1usize << (STATIC - 19)))) != 0) || ((((_la - 53)) & !0x3f) == 0 && ((1usize << (_la - 53)) & ((1usize << (TRANSIENT - 53)) | (1usize << (VOLATILE - 53)) | (1usize << (AT - 53)))) != 0) {
				{
				{
				/*InvokeRule fieldModifier*/
				recog.base.set_state(982);
				recog.fieldModifier()?;

				}
				}
				recog.base.set_state(987);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(988);
			recog.unannType()?;

			/*InvokeRule variableDeclaratorList*/
			recog.base.set_state(989);
			recog.variableDeclaratorList()?;

			recog.base.set_state(990);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldModifier ----------------
pub type FieldModifierContextAll<'input> = FieldModifierContext<'input>;


pub type FieldModifierContext<'input> = BaseParserRuleContext<'input,FieldModifierContextExt<'input>>;

#[derive(Clone)]
pub struct FieldModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for FieldModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for FieldModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_fieldModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldModifier }
}
antlr_rust::tid!{FieldModifierContextExt<'a>}

impl<'input> FieldModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<FieldModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token TRANSIENT
/// Returns `None` if there is no child corresponding to token TRANSIENT
fn TRANSIENT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(TRANSIENT, 0)
}
/// Retrieves first TerminalNode corresponding to token VOLATILE
/// Returns `None` if there is no child corresponding to token VOLATILE
fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(VOLATILE, 0)
}

}

impl<'input> FieldModifierContextAttrs<'input> for FieldModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldModifier(&mut self,)
	-> Result<Rc<FieldModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 116, RULE_fieldModifier);
        let mut _localctx: Rc<FieldModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1000);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(992);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(993);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PROTECTED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(994);
					recog.base.match_token(PROTECTED,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(995);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(996);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 FINAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(997);
					recog.base.match_token(FINAL,&mut recog.err_handler)?;

					}
				}

			 TRANSIENT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(998);
					recog.base.match_token(TRANSIENT,&mut recog.err_handler)?;

					}
				}

			 VOLATILE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(999);
					recog.base.match_token(VOLATILE,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableDeclaratorList ----------------
pub type VariableDeclaratorListContextAll<'input> = VariableDeclaratorListContext<'input>;


pub type VariableDeclaratorListContext<'input> = BaseParserRuleContext<'input,VariableDeclaratorListContextExt<'input>>;

#[derive(Clone)]
pub struct VariableDeclaratorListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for VariableDeclaratorListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for VariableDeclaratorListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableDeclaratorList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_variableDeclaratorList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for VariableDeclaratorListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableDeclaratorList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableDeclaratorList }
}
antlr_rust::tid!{VariableDeclaratorListContextExt<'a>}

impl<'input> VariableDeclaratorListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableDeclaratorListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableDeclaratorListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableDeclaratorListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<VariableDeclaratorListContextExt<'input>>{

fn variableDeclarator_all(&self) ->  Vec<Rc<VariableDeclaratorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableDeclarator(&self, i: usize) -> Option<Rc<VariableDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> VariableDeclaratorListContextAttrs<'input> for VariableDeclaratorListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableDeclaratorList(&mut self,)
	-> Result<Rc<VariableDeclaratorListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableDeclaratorListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 118, RULE_variableDeclaratorList);
        let mut _localctx: Rc<VariableDeclaratorListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule variableDeclarator*/
			recog.base.set_state(1002);
			recog.variableDeclarator()?;

			recog.base.set_state(1007);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(1003);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule variableDeclarator*/
				recog.base.set_state(1004);
				recog.variableDeclarator()?;

				}
				}
				recog.base.set_state(1009);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableDeclarator ----------------
pub type VariableDeclaratorContextAll<'input> = VariableDeclaratorContext<'input>;


pub type VariableDeclaratorContext<'input> = BaseParserRuleContext<'input,VariableDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct VariableDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for VariableDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for VariableDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableDeclarator(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_variableDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for VariableDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableDeclarator }
}
antlr_rust::tid!{VariableDeclaratorContextExt<'a>}

impl<'input> VariableDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableDeclaratorContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<VariableDeclaratorContextExt<'input>>{

fn variableDeclaratorId(&self) -> Option<Rc<VariableDeclaratorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGN
/// Returns `None` if there is no child corresponding to token ASSIGN
fn ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ASSIGN, 0)
}
fn variableInitializer(&self) -> Option<Rc<VariableInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VariableDeclaratorContextAttrs<'input> for VariableDeclaratorContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableDeclarator(&mut self,)
	-> Result<Rc<VariableDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_variableDeclarator);
        let mut _localctx: Rc<VariableDeclaratorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule variableDeclaratorId*/
			recog.base.set_state(1010);
			recog.variableDeclaratorId()?;

			recog.base.set_state(1013);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ASSIGN {
				{
				recog.base.set_state(1011);
				recog.base.match_token(ASSIGN,&mut recog.err_handler)?;

				/*InvokeRule variableInitializer*/
				recog.base.set_state(1012);
				recog.variableInitializer()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableDeclaratorId ----------------
pub type VariableDeclaratorIdContextAll<'input> = VariableDeclaratorIdContext<'input>;


pub type VariableDeclaratorIdContext<'input> = BaseParserRuleContext<'input,VariableDeclaratorIdContextExt<'input>>;

#[derive(Clone)]
pub struct VariableDeclaratorIdContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for VariableDeclaratorIdContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for VariableDeclaratorIdContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableDeclaratorId(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_variableDeclaratorId(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for VariableDeclaratorIdContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableDeclaratorId }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableDeclaratorId }
}
antlr_rust::tid!{VariableDeclaratorIdContextExt<'a>}

impl<'input> VariableDeclaratorIdContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableDeclaratorIdContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableDeclaratorIdContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableDeclaratorIdContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<VariableDeclaratorIdContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VariableDeclaratorIdContextAttrs<'input> for VariableDeclaratorIdContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableDeclaratorId(&mut self,)
	-> Result<Rc<VariableDeclaratorIdContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableDeclaratorIdContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_variableDeclaratorId);
        let mut _localctx: Rc<VariableDeclaratorIdContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1015);
			recog.identifier()?;

			recog.base.set_state(1017);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LBRACK || _la==AT {
				{
				/*InvokeRule dims*/
				recog.base.set_state(1016);
				recog.dims()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableInitializer ----------------
pub type VariableInitializerContextAll<'input> = VariableInitializerContext<'input>;


pub type VariableInitializerContext<'input> = BaseParserRuleContext<'input,VariableInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct VariableInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for VariableInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for VariableInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableInitializer(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_variableInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for VariableInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableInitializer }
}
antlr_rust::tid!{VariableInitializerContextExt<'a>}

impl<'input> VariableInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableInitializerContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<VariableInitializerContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayInitializer(&self) -> Option<Rc<ArrayInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VariableInitializerContextAttrs<'input> for VariableInitializerContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableInitializer(&mut self,)
	-> Result<Rc<VariableInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_variableInitializer);
        let mut _localctx: Rc<VariableInitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1021);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN | BYTE | CHAR | DOUBLE | EXPORTS | FLOAT | INT | LONG | MODULE |
			 NEW | OPEN | OPERNS | PROVIDES | REQUIRES | SHORT | SUPER | THIS | TO |
			 USES | VOID | WITH | IntegerLiteral | FloatingPointLiteral | BooleanLiteral |
			 CharacterLiteral | StringLiteral | NullLiteral | LPAREN | AT | BANG |
			 TILDE | INC | DEC | ADD | SUB | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expression*/
					recog.base.set_state(1019);
					recog.expression()?;

					}
				}

			 LBRACE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule arrayInitializer*/
					recog.base.set_state(1020);
					recog.arrayInitializer()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannType ----------------
pub type UnannTypeContextAll<'input> = UnannTypeContext<'input>;


pub type UnannTypeContext<'input> = BaseParserRuleContext<'input,UnannTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannType }
}
antlr_rust::tid!{UnannTypeContextExt<'a>}

impl<'input> UnannTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannTypeContextExt<'input>>{

fn unannPrimitiveType(&self) -> Option<Rc<UnannPrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannReferenceType(&self) -> Option<Rc<UnannReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannTypeContextAttrs<'input> for UnannTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannType(&mut self,)
	-> Result<Rc<UnannTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_unannType);
        let mut _localctx: Rc<UnannTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1025);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(72,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unannPrimitiveType*/
					recog.base.set_state(1023);
					recog.unannPrimitiveType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule unannReferenceType*/
					recog.base.set_state(1024);
					recog.unannReferenceType()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannPrimitiveType ----------------
pub type UnannPrimitiveTypeContextAll<'input> = UnannPrimitiveTypeContext<'input>;


pub type UnannPrimitiveTypeContext<'input> = BaseParserRuleContext<'input,UnannPrimitiveTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannPrimitiveTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannPrimitiveTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannPrimitiveTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannPrimitiveType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannPrimitiveType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannPrimitiveTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannPrimitiveType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannPrimitiveType }
}
antlr_rust::tid!{UnannPrimitiveTypeContextExt<'a>}

impl<'input> UnannPrimitiveTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannPrimitiveTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannPrimitiveTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannPrimitiveTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannPrimitiveTypeContextExt<'input>>{

fn numericType(&self) -> Option<Rc<NumericTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BOOLEAN
/// Returns `None` if there is no child corresponding to token BOOLEAN
fn BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(BOOLEAN, 0)
}

}

impl<'input> UnannPrimitiveTypeContextAttrs<'input> for UnannPrimitiveTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannPrimitiveType(&mut self,)
	-> Result<Rc<UnannPrimitiveTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannPrimitiveTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_unannPrimitiveType);
        let mut _localctx: Rc<UnannPrimitiveTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1029);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule numericType*/
					recog.base.set_state(1027);
					recog.numericType()?;

					}
				}

			 BOOLEAN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1028);
					recog.base.match_token(BOOLEAN,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannReferenceType ----------------
pub type UnannReferenceTypeContextAll<'input> = UnannReferenceTypeContext<'input>;


pub type UnannReferenceTypeContext<'input> = BaseParserRuleContext<'input,UnannReferenceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannReferenceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannReferenceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannReferenceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannReferenceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannReferenceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannReferenceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannReferenceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannReferenceType }
}
antlr_rust::tid!{UnannReferenceTypeContextExt<'a>}

impl<'input> UnannReferenceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannReferenceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannReferenceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannReferenceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannReferenceTypeContextExt<'input>>{

fn unannClassOrInterfaceType(&self) -> Option<Rc<UnannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannTypeVariable(&self) -> Option<Rc<UnannTypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannArrayType(&self) -> Option<Rc<UnannArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannReferenceTypeContextAttrs<'input> for UnannReferenceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannReferenceType(&mut self,)
	-> Result<Rc<UnannReferenceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannReferenceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_unannReferenceType);
        let mut _localctx: Rc<UnannReferenceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1034);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(74,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unannClassOrInterfaceType*/
					recog.base.set_state(1031);
					recog.unannClassOrInterfaceType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule unannTypeVariable*/
					recog.base.set_state(1032);
					recog.unannTypeVariable()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule unannArrayType*/
					recog.base.set_state(1033);
					recog.unannArrayType()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannClassOrInterfaceType ----------------
pub type UnannClassOrInterfaceTypeContextAll<'input> = UnannClassOrInterfaceTypeContext<'input>;


pub type UnannClassOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,UnannClassOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannClassOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannClassOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannClassOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannClassOrInterfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannClassOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannClassOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannClassOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannClassOrInterfaceType }
}
antlr_rust::tid!{UnannClassOrInterfaceTypeContextExt<'a>}

impl<'input> UnannClassOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannClassOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannClassOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannClassOrInterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannClassOrInterfaceTypeContextExt<'input>>{

fn unannClassType_lfno_unannClassOrInterfaceType(&self) -> Option<Rc<UnannClassType_lfno_unannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannInterfaceType_lfno_unannClassOrInterfaceType(&self) -> Option<Rc<UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannClassType_lf_unannClassOrInterfaceType_all(&self) ->  Vec<Rc<UnannClassType_lf_unannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn unannClassType_lf_unannClassOrInterfaceType(&self, i: usize) -> Option<Rc<UnannClassType_lf_unannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn unannInterfaceType_lf_unannClassOrInterfaceType_all(&self) ->  Vec<Rc<UnannInterfaceType_lf_unannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn unannInterfaceType_lf_unannClassOrInterfaceType(&self, i: usize) -> Option<Rc<UnannInterfaceType_lf_unannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> UnannClassOrInterfaceTypeContextAttrs<'input> for UnannClassOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannClassOrInterfaceType(&mut self,)
	-> Result<Rc<UnannClassOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannClassOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_unannClassOrInterfaceType);
        let mut _localctx: Rc<UnannClassOrInterfaceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1038);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(75,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule unannClassType_lfno_unannClassOrInterfaceType*/
					recog.base.set_state(1036);
					recog.unannClassType_lfno_unannClassOrInterfaceType()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule unannInterfaceType_lfno_unannClassOrInterfaceType*/
					recog.base.set_state(1037);
					recog.unannInterfaceType_lfno_unannClassOrInterfaceType()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1044);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(77,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					recog.base.set_state(1042);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(76,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule unannClassType_lf_unannClassOrInterfaceType*/
							recog.base.set_state(1040);
							recog.unannClassType_lf_unannClassOrInterfaceType()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule unannInterfaceType_lf_unannClassOrInterfaceType*/
							recog.base.set_state(1041);
							recog.unannInterfaceType_lf_unannClassOrInterfaceType()?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(1046);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(77,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannClassType ----------------
pub type UnannClassTypeContextAll<'input> = UnannClassTypeContext<'input>;


pub type UnannClassTypeContext<'input> = BaseParserRuleContext<'input,UnannClassTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannClassTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannClassTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannClassTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannClassType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannClassType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannClassTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannClassType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannClassType }
}
antlr_rust::tid!{UnannClassTypeContextExt<'a>}

impl<'input> UnannClassTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannClassTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannClassTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannClassTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannClassTypeContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannClassOrInterfaceType(&self) -> Option<Rc<UnannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> UnannClassTypeContextAttrs<'input> for UnannClassTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannClassType(&mut self,)
	-> Result<Rc<UnannClassTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannClassTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_unannClassType);
        let mut _localctx: Rc<UnannClassTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1063);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(81,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule identifier*/
					recog.base.set_state(1047);
					recog.identifier()?;

					recog.base.set_state(1049);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(1048);
						recog.typeArguments()?;

						}
					}

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule unannClassOrInterfaceType*/
					recog.base.set_state(1051);
					recog.unannClassOrInterfaceType()?;

					recog.base.set_state(1052);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1056);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(1053);
						recog.annotation()?;

						}
						}
						recog.base.set_state(1058);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule identifier*/
					recog.base.set_state(1059);
					recog.identifier()?;

					recog.base.set_state(1061);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(1060);
						recog.typeArguments()?;

						}
					}

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannClassType_lf_unannClassOrInterfaceType ----------------
pub type UnannClassType_lf_unannClassOrInterfaceTypeContextAll<'input> = UnannClassType_lf_unannClassOrInterfaceTypeContext<'input>;


pub type UnannClassType_lf_unannClassOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,UnannClassType_lf_unannClassOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannClassType_lf_unannClassOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannClassType_lf_unannClassOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannClassType_lf_unannClassOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannClassType_lf_unannClassOrInterfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannClassType_lf_unannClassOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannClassType_lf_unannClassOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannClassType_lf_unannClassOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannClassType_lf_unannClassOrInterfaceType }
}
antlr_rust::tid!{UnannClassType_lf_unannClassOrInterfaceTypeContextExt<'a>}

impl<'input> UnannClassType_lf_unannClassOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannClassType_lf_unannClassOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannClassType_lf_unannClassOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannClassType_lf_unannClassOrInterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannClassType_lf_unannClassOrInterfaceTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannClassType_lf_unannClassOrInterfaceTypeContextAttrs<'input> for UnannClassType_lf_unannClassOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannClassType_lf_unannClassOrInterfaceType(&mut self,)
	-> Result<Rc<UnannClassType_lf_unannClassOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannClassType_lf_unannClassOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_unannClassType_lf_unannClassOrInterfaceType);
        let mut _localctx: Rc<UnannClassType_lf_unannClassOrInterfaceTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1065);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(1069);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(1066);
				recog.annotation()?;

				}
				}
				recog.base.set_state(1071);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule identifier*/
			recog.base.set_state(1072);
			recog.identifier()?;

			recog.base.set_state(1074);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeArguments*/
				recog.base.set_state(1073);
				recog.typeArguments()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannClassType_lfno_unannClassOrInterfaceType ----------------
pub type UnannClassType_lfno_unannClassOrInterfaceTypeContextAll<'input> = UnannClassType_lfno_unannClassOrInterfaceTypeContext<'input>;


pub type UnannClassType_lfno_unannClassOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,UnannClassType_lfno_unannClassOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannClassType_lfno_unannClassOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannClassType_lfno_unannClassOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannClassType_lfno_unannClassOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannClassType_lfno_unannClassOrInterfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannClassType_lfno_unannClassOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannClassType_lfno_unannClassOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannClassType_lfno_unannClassOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannClassType_lfno_unannClassOrInterfaceType }
}
antlr_rust::tid!{UnannClassType_lfno_unannClassOrInterfaceTypeContextExt<'a>}

impl<'input> UnannClassType_lfno_unannClassOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannClassType_lfno_unannClassOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannClassType_lfno_unannClassOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannClassType_lfno_unannClassOrInterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannClassType_lfno_unannClassOrInterfaceTypeContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannClassType_lfno_unannClassOrInterfaceTypeContextAttrs<'input> for UnannClassType_lfno_unannClassOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannClassType_lfno_unannClassOrInterfaceType(&mut self,)
	-> Result<Rc<UnannClassType_lfno_unannClassOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannClassType_lfno_unannClassOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_unannClassType_lfno_unannClassOrInterfaceType);
        let mut _localctx: Rc<UnannClassType_lfno_unannClassOrInterfaceTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1076);
			recog.identifier()?;

			recog.base.set_state(1078);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeArguments*/
				recog.base.set_state(1077);
				recog.typeArguments()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannInterfaceType ----------------
pub type UnannInterfaceTypeContextAll<'input> = UnannInterfaceTypeContext<'input>;


pub type UnannInterfaceTypeContext<'input> = BaseParserRuleContext<'input,UnannInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannInterfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannInterfaceType }
}
antlr_rust::tid!{UnannInterfaceTypeContextExt<'a>}

impl<'input> UnannInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannInterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannInterfaceTypeContextExt<'input>>{

fn unannClassType(&self) -> Option<Rc<UnannClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannInterfaceTypeContextAttrs<'input> for UnannInterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannInterfaceType(&mut self,)
	-> Result<Rc<UnannInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_unannInterfaceType);
        let mut _localctx: Rc<UnannInterfaceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule unannClassType*/
			recog.base.set_state(1080);
			recog.unannClassType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannInterfaceType_lf_unannClassOrInterfaceType ----------------
pub type UnannInterfaceType_lf_unannClassOrInterfaceTypeContextAll<'input> = UnannInterfaceType_lf_unannClassOrInterfaceTypeContext<'input>;


pub type UnannInterfaceType_lf_unannClassOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,UnannInterfaceType_lf_unannClassOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannInterfaceType_lf_unannClassOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannInterfaceType_lf_unannClassOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannInterfaceType_lf_unannClassOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannInterfaceType_lf_unannClassOrInterfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannInterfaceType_lf_unannClassOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannInterfaceType_lf_unannClassOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannInterfaceType_lf_unannClassOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannInterfaceType_lf_unannClassOrInterfaceType }
}
antlr_rust::tid!{UnannInterfaceType_lf_unannClassOrInterfaceTypeContextExt<'a>}

impl<'input> UnannInterfaceType_lf_unannClassOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannInterfaceType_lf_unannClassOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannInterfaceType_lf_unannClassOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannInterfaceType_lf_unannClassOrInterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannInterfaceType_lf_unannClassOrInterfaceTypeContextExt<'input>>{

fn unannClassType_lf_unannClassOrInterfaceType(&self) -> Option<Rc<UnannClassType_lf_unannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannInterfaceType_lf_unannClassOrInterfaceTypeContextAttrs<'input> for UnannInterfaceType_lf_unannClassOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannInterfaceType_lf_unannClassOrInterfaceType(&mut self,)
	-> Result<Rc<UnannInterfaceType_lf_unannClassOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannInterfaceType_lf_unannClassOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_unannInterfaceType_lf_unannClassOrInterfaceType);
        let mut _localctx: Rc<UnannInterfaceType_lf_unannClassOrInterfaceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule unannClassType_lf_unannClassOrInterfaceType*/
			recog.base.set_state(1082);
			recog.unannClassType_lf_unannClassOrInterfaceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannInterfaceType_lfno_unannClassOrInterfaceType ----------------
pub type UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextAll<'input> = UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext<'input>;


pub type UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext<'input> = BaseParserRuleContext<'input,UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannInterfaceType_lfno_unannClassOrInterfaceType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannInterfaceType_lfno_unannClassOrInterfaceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannInterfaceType_lfno_unannClassOrInterfaceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannInterfaceType_lfno_unannClassOrInterfaceType }
}
antlr_rust::tid!{UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextExt<'a>}

impl<'input> UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextExt<'input>>{

fn unannClassType_lfno_unannClassOrInterfaceType(&self) -> Option<Rc<UnannClassType_lfno_unannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextAttrs<'input> for UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannInterfaceType_lfno_unannClassOrInterfaceType(&mut self,)
	-> Result<Rc<UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_unannInterfaceType_lfno_unannClassOrInterfaceType);
        let mut _localctx: Rc<UnannInterfaceType_lfno_unannClassOrInterfaceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule unannClassType_lfno_unannClassOrInterfaceType*/
			recog.base.set_state(1084);
			recog.unannClassType_lfno_unannClassOrInterfaceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannTypeVariable ----------------
pub type UnannTypeVariableContextAll<'input> = UnannTypeVariableContext<'input>;


pub type UnannTypeVariableContext<'input> = BaseParserRuleContext<'input,UnannTypeVariableContextExt<'input>>;

#[derive(Clone)]
pub struct UnannTypeVariableContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannTypeVariableContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannTypeVariableContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannTypeVariable(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannTypeVariable(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannTypeVariableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannTypeVariable }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannTypeVariable }
}
antlr_rust::tid!{UnannTypeVariableContextExt<'a>}

impl<'input> UnannTypeVariableContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannTypeVariableContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannTypeVariableContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannTypeVariableContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannTypeVariableContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannTypeVariableContextAttrs<'input> for UnannTypeVariableContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannTypeVariable(&mut self,)
	-> Result<Rc<UnannTypeVariableContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannTypeVariableContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_unannTypeVariable);
        let mut _localctx: Rc<UnannTypeVariableContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1086);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unannArrayType ----------------
pub type UnannArrayTypeContextAll<'input> = UnannArrayTypeContext<'input>;


pub type UnannArrayTypeContext<'input> = BaseParserRuleContext<'input,UnannArrayTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UnannArrayTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnannArrayTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnannArrayTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unannArrayType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unannArrayType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnannArrayTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unannArrayType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unannArrayType }
}
antlr_rust::tid!{UnannArrayTypeContextExt<'a>}

impl<'input> UnannArrayTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnannArrayTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnannArrayTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnannArrayTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnannArrayTypeContextExt<'input>>{

fn unannPrimitiveType(&self) -> Option<Rc<UnannPrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannClassOrInterfaceType(&self) -> Option<Rc<UnannClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unannTypeVariable(&self) -> Option<Rc<UnannTypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnannArrayTypeContextAttrs<'input> for UnannArrayTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unannArrayType(&mut self,)
	-> Result<Rc<UnannArrayTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnannArrayTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_unannArrayType);
        let mut _localctx: Rc<UnannArrayTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1097);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(85,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unannPrimitiveType*/
					recog.base.set_state(1088);
					recog.unannPrimitiveType()?;

					/*InvokeRule dims*/
					recog.base.set_state(1089);
					recog.dims()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule unannClassOrInterfaceType*/
					recog.base.set_state(1091);
					recog.unannClassOrInterfaceType()?;

					/*InvokeRule dims*/
					recog.base.set_state(1092);
					recog.dims()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule unannTypeVariable*/
					recog.base.set_state(1094);
					recog.unannTypeVariable()?;

					/*InvokeRule dims*/
					recog.base.set_state(1095);
					recog.dims()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodDeclaration ----------------
pub type MethodDeclarationContextAll<'input> = MethodDeclarationContext<'input>;


pub type MethodDeclarationContext<'input> = BaseParserRuleContext<'input,MethodDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct MethodDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodDeclaration }
}
antlr_rust::tid!{MethodDeclarationContextExt<'a>}

impl<'input> MethodDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodDeclarationContextExt<'input>>{

fn methodHeader(&self) -> Option<Rc<MethodHeaderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodBody(&self) -> Option<Rc<MethodBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodModifier_all(&self) ->  Vec<Rc<MethodModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn methodModifier(&self, i: usize) -> Option<Rc<MethodModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MethodDeclarationContextAttrs<'input> for MethodDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodDeclaration(&mut self,)
	-> Result<Rc<MethodDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_methodDeclaration);
        let mut _localctx: Rc<MethodDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1102);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==ABSTRACT || _la==FINAL || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (NATIVE - 32)) | (1usize << (PRIVATE - 32)) | (1usize << (PROTECTED - 32)) | (1usize << (PUBLIC - 32)) | (1usize << (STATIC - 32)) | (1usize << (STRICTFP - 32)) | (1usize << (SYNCHRONIZED - 32)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule methodModifier*/
				recog.base.set_state(1099);
				recog.methodModifier()?;

				}
				}
				recog.base.set_state(1104);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule methodHeader*/
			recog.base.set_state(1105);
			recog.methodHeader()?;

			/*InvokeRule methodBody*/
			recog.base.set_state(1106);
			recog.methodBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodModifier ----------------
pub type MethodModifierContextAll<'input> = MethodModifierContext<'input>;


pub type MethodModifierContext<'input> = BaseParserRuleContext<'input,MethodModifierContextExt<'input>>;

#[derive(Clone)]
pub struct MethodModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodModifier }
}
antlr_rust::tid!{MethodModifierContextExt<'a>}

impl<'input> MethodModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token SYNCHRONIZED
/// Returns `None` if there is no child corresponding to token SYNCHRONIZED
fn SYNCHRONIZED(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SYNCHRONIZED, 0)
}
/// Retrieves first TerminalNode corresponding to token NATIVE
/// Returns `None` if there is no child corresponding to token NATIVE
fn NATIVE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(NATIVE, 0)
}
/// Retrieves first TerminalNode corresponding to token STRICTFP
/// Returns `None` if there is no child corresponding to token STRICTFP
fn STRICTFP(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STRICTFP, 0)
}

}

impl<'input> MethodModifierContextAttrs<'input> for MethodModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodModifier(&mut self,)
	-> Result<Rc<MethodModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_methodModifier);
        let mut _localctx: Rc<MethodModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1118);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1108);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1109);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PROTECTED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1110);
					recog.base.match_token(PROTECTED,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1111);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

			 ABSTRACT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1112);
					recog.base.match_token(ABSTRACT,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(1113);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 FINAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(1114);
					recog.base.match_token(FINAL,&mut recog.err_handler)?;

					}
				}

			 SYNCHRONIZED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(1115);
					recog.base.match_token(SYNCHRONIZED,&mut recog.err_handler)?;

					}
				}

			 NATIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					recog.base.set_state(1116);
					recog.base.match_token(NATIVE,&mut recog.err_handler)?;

					}
				}

			 STRICTFP 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					recog.base.set_state(1117);
					recog.base.match_token(STRICTFP,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodHeader ----------------
pub type MethodHeaderContextAll<'input> = MethodHeaderContext<'input>;


pub type MethodHeaderContext<'input> = BaseParserRuleContext<'input,MethodHeaderContextExt<'input>>;

#[derive(Clone)]
pub struct MethodHeaderContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodHeaderContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodHeaderContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodHeader(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodHeader(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodHeaderContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodHeader }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodHeader }
}
antlr_rust::tid!{MethodHeaderContextExt<'a>}

impl<'input> MethodHeaderContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodHeaderContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodHeaderContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodHeaderContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodHeaderContextExt<'input>>{

fn result(&self) -> Option<Rc<ResultContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodDeclarator(&self) -> Option<Rc<MethodDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn throws_(&self) -> Option<Rc<Throws_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MethodHeaderContextAttrs<'input> for MethodHeaderContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodHeader(&mut self,)
	-> Result<Rc<MethodHeaderContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodHeaderContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_methodHeader);
        let mut _localctx: Rc<MethodHeaderContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1137);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN | BYTE | CHAR | DOUBLE | EXPORTS | FLOAT | INT | LONG | MODULE |
			 OPEN | OPERNS | PROVIDES | REQUIRES | SHORT | TO | USES | VOID | WITH |
			 Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule result*/
					recog.base.set_state(1120);
					recog.result()?;

					/*InvokeRule methodDeclarator*/
					recog.base.set_state(1121);
					recog.methodDeclarator()?;

					recog.base.set_state(1123);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==THROWS {
						{
						/*InvokeRule throws_*/
						recog.base.set_state(1122);
						recog.throws_()?;

						}
					}

					}
				}

			 LT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeParameters*/
					recog.base.set_state(1125);
					recog.typeParameters()?;

					recog.base.set_state(1129);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(1126);
						recog.annotation()?;

						}
						}
						recog.base.set_state(1131);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule result*/
					recog.base.set_state(1132);
					recog.result()?;

					/*InvokeRule methodDeclarator*/
					recog.base.set_state(1133);
					recog.methodDeclarator()?;

					recog.base.set_state(1135);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==THROWS {
						{
						/*InvokeRule throws_*/
						recog.base.set_state(1134);
						recog.throws_()?;

						}
					}

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- result ----------------
pub type ResultContextAll<'input> = ResultContext<'input>;


pub type ResultContext<'input> = BaseParserRuleContext<'input,ResultContextExt<'input>>;

#[derive(Clone)]
pub struct ResultContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ResultContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ResultContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_result(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_result(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ResultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_result }
	//fn type_rule_index() -> usize where Self: Sized { RULE_result }
}
antlr_rust::tid!{ResultContextExt<'a>}

impl<'input> ResultContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ResultContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ResultContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ResultContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ResultContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token VOID
/// Returns `None` if there is no child corresponding to token VOID
fn VOID(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(VOID, 0)
}

}

impl<'input> ResultContextAttrs<'input> for ResultContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn result(&mut self,)
	-> Result<Rc<ResultContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ResultContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_result);
        let mut _localctx: Rc<ResultContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1141);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN | BYTE | CHAR | DOUBLE | EXPORTS | FLOAT | INT | LONG | MODULE |
			 OPEN | OPERNS | PROVIDES | REQUIRES | SHORT | TO | USES | WITH | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule unannType*/
					recog.base.set_state(1139);
					recog.unannType()?;

					}
				}

			 VOID 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1140);
					recog.base.match_token(VOID,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodDeclarator ----------------
pub type MethodDeclaratorContextAll<'input> = MethodDeclaratorContext<'input>;


pub type MethodDeclaratorContext<'input> = BaseParserRuleContext<'input,MethodDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct MethodDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodDeclarator(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodDeclarator }
}
antlr_rust::tid!{MethodDeclaratorContextExt<'a>}

impl<'input> MethodDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodDeclaratorContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodDeclaratorContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn formalParameterList(&self) -> Option<Rc<FormalParameterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodDeclaratorContextAttrs<'input> for MethodDeclaratorContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodDeclarator(&mut self,)
	-> Result<Rc<MethodDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_methodDeclarator);
        let mut _localctx: Rc<MethodDeclaratorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1143);
			recog.identifier()?;

			recog.base.set_state(1144);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1146);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 34)) & !0x3f) == 0 && ((1usize << (_la - 34)) & ((1usize << (OPEN - 34)) | (1usize << (OPERNS - 34)) | (1usize << (PROVIDES - 34)) | (1usize << (REQUIRES - 34)) | (1usize << (SHORT - 34)) | (1usize << (TO - 34)) | (1usize << (USES - 34)) | (1usize << (WITH - 34)))) != 0) || _la==AT || _la==Identifier {
				{
				/*InvokeRule formalParameterList*/
				recog.base.set_state(1145);
				recog.formalParameterList()?;

				}
			}

			recog.base.set_state(1148);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1150);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LBRACK || _la==AT {
				{
				/*InvokeRule dims*/
				recog.base.set_state(1149);
				recog.dims()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- formalParameterList ----------------
pub type FormalParameterListContextAll<'input> = FormalParameterListContext<'input>;


pub type FormalParameterListContext<'input> = BaseParserRuleContext<'input,FormalParameterListContextExt<'input>>;

#[derive(Clone)]
pub struct FormalParameterListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for FormalParameterListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for FormalParameterListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_formalParameterList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_formalParameterList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FormalParameterListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_formalParameterList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_formalParameterList }
}
antlr_rust::tid!{FormalParameterListContextExt<'a>}

impl<'input> FormalParameterListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FormalParameterListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FormalParameterListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FormalParameterListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<FormalParameterListContextExt<'input>>{

fn formalParameters(&self) -> Option<Rc<FormalParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn lastFormalParameter(&self) -> Option<Rc<LastFormalParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn receiverParameter(&self) -> Option<Rc<ReceiverParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FormalParameterListContextAttrs<'input> for FormalParameterListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn formalParameterList(&mut self,)
	-> Result<Rc<FormalParameterListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FormalParameterListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_formalParameterList);
        let mut _localctx: Rc<FormalParameterListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1158);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(95,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule formalParameters*/
					recog.base.set_state(1152);
					recog.formalParameters()?;

					recog.base.set_state(1153);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule lastFormalParameter*/
					recog.base.set_state(1154);
					recog.lastFormalParameter()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule lastFormalParameter*/
					recog.base.set_state(1156);
					recog.lastFormalParameter()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule receiverParameter*/
					recog.base.set_state(1157);
					recog.receiverParameter()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- formalParameters ----------------
pub type FormalParametersContextAll<'input> = FormalParametersContext<'input>;


pub type FormalParametersContext<'input> = BaseParserRuleContext<'input,FormalParametersContextExt<'input>>;

#[derive(Clone)]
pub struct FormalParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for FormalParametersContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for FormalParametersContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_formalParameters(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_formalParameters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FormalParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_formalParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_formalParameters }
}
antlr_rust::tid!{FormalParametersContextExt<'a>}

impl<'input> FormalParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FormalParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FormalParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FormalParametersContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<FormalParametersContextExt<'input>>{

fn formalParameter_all(&self) ->  Vec<Rc<FormalParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn formalParameter(&self, i: usize) -> Option<Rc<FormalParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn receiverParameter(&self) -> Option<Rc<ReceiverParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FormalParametersContextAttrs<'input> for FormalParametersContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn formalParameters(&mut self,)
	-> Result<Rc<FormalParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FormalParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_formalParameters);
        let mut _localctx: Rc<FormalParametersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(1176);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(98,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule formalParameter*/
					recog.base.set_state(1160);
					recog.formalParameter()?;

					recog.base.set_state(1165);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(96,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1161);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule formalParameter*/
							recog.base.set_state(1162);
							recog.formalParameter()?;

							}
							} 
						}
						recog.base.set_state(1167);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(96,&mut recog.base)?;
					}
					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule receiverParameter*/
					recog.base.set_state(1168);
					recog.receiverParameter()?;

					recog.base.set_state(1173);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(97,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1169);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule formalParameter*/
							recog.base.set_state(1170);
							recog.formalParameter()?;

							}
							} 
						}
						recog.base.set_state(1175);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(97,&mut recog.base)?;
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- formalParameter ----------------
pub type FormalParameterContextAll<'input> = FormalParameterContext<'input>;


pub type FormalParameterContext<'input> = BaseParserRuleContext<'input,FormalParameterContextExt<'input>>;

#[derive(Clone)]
pub struct FormalParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for FormalParameterContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for FormalParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_formalParameter(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_formalParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FormalParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_formalParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_formalParameter }
}
antlr_rust::tid!{FormalParameterContextExt<'a>}

impl<'input> FormalParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FormalParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FormalParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FormalParameterContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<FormalParameterContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorId(&self) -> Option<Rc<VariableDeclaratorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> FormalParameterContextAttrs<'input> for FormalParameterContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn formalParameter(&mut self,)
	-> Result<Rc<FormalParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FormalParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_formalParameter);
        let mut _localctx: Rc<FormalParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1181);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==FINAL || _la==AT {
				{
				{
				/*InvokeRule variableModifier*/
				recog.base.set_state(1178);
				recog.variableModifier()?;

				}
				}
				recog.base.set_state(1183);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1184);
			recog.unannType()?;

			/*InvokeRule variableDeclaratorId*/
			recog.base.set_state(1185);
			recog.variableDeclaratorId()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableModifier ----------------
pub type VariableModifierContextAll<'input> = VariableModifierContext<'input>;


pub type VariableModifierContext<'input> = BaseParserRuleContext<'input,VariableModifierContextExt<'input>>;

#[derive(Clone)]
pub struct VariableModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for VariableModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for VariableModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_variableModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for VariableModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableModifier }
}
antlr_rust::tid!{VariableModifierContextExt<'a>}

impl<'input> VariableModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<VariableModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}

}

impl<'input> VariableModifierContextAttrs<'input> for VariableModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableModifier(&mut self,)
	-> Result<Rc<VariableModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_variableModifier);
        let mut _localctx: Rc<VariableModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1189);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1187);
					recog.annotation()?;

					}
				}

			 FINAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1188);
					recog.base.match_token(FINAL,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lastFormalParameter ----------------
pub type LastFormalParameterContextAll<'input> = LastFormalParameterContext<'input>;


pub type LastFormalParameterContext<'input> = BaseParserRuleContext<'input,LastFormalParameterContextExt<'input>>;

#[derive(Clone)]
pub struct LastFormalParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for LastFormalParameterContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for LastFormalParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lastFormalParameter(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_lastFormalParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LastFormalParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lastFormalParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lastFormalParameter }
}
antlr_rust::tid!{LastFormalParameterContextExt<'a>}

impl<'input> LastFormalParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LastFormalParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LastFormalParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LastFormalParameterContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<LastFormalParameterContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ELLIPSIS
/// Returns `None` if there is no child corresponding to token ELLIPSIS
fn ELLIPSIS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ELLIPSIS, 0)
}
fn variableDeclaratorId(&self) -> Option<Rc<VariableDeclaratorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn formalParameter(&self) -> Option<Rc<FormalParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LastFormalParameterContextAttrs<'input> for LastFormalParameterContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lastFormalParameter(&mut self,)
	-> Result<Rc<LastFormalParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LastFormalParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_lastFormalParameter);
        let mut _localctx: Rc<LastFormalParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1208);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(103,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1194);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==FINAL || _la==AT {
						{
						{
						/*InvokeRule variableModifier*/
						recog.base.set_state(1191);
						recog.variableModifier()?;

						}
						}
						recog.base.set_state(1196);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule unannType*/
					recog.base.set_state(1197);
					recog.unannType()?;

					recog.base.set_state(1201);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(1198);
						recog.annotation()?;

						}
						}
						recog.base.set_state(1203);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1204);
					recog.base.match_token(ELLIPSIS,&mut recog.err_handler)?;

					/*InvokeRule variableDeclaratorId*/
					recog.base.set_state(1205);
					recog.variableDeclaratorId()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule formalParameter*/
					recog.base.set_state(1207);
					recog.formalParameter()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- receiverParameter ----------------
pub type ReceiverParameterContextAll<'input> = ReceiverParameterContext<'input>;


pub type ReceiverParameterContext<'input> = BaseParserRuleContext<'input,ReceiverParameterContextExt<'input>>;

#[derive(Clone)]
pub struct ReceiverParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ReceiverParameterContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ReceiverParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_receiverParameter(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_receiverParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ReceiverParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_receiverParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_receiverParameter }
}
antlr_rust::tid!{ReceiverParameterContextExt<'a>}

impl<'input> ReceiverParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReceiverParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReceiverParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReceiverParameterContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ReceiverParameterContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> ReceiverParameterContextAttrs<'input> for ReceiverParameterContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn receiverParameter(&mut self,)
	-> Result<Rc<ReceiverParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReceiverParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_receiverParameter);
        let mut _localctx: Rc<ReceiverParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1213);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(1210);
				recog.annotation()?;

				}
				}
				recog.base.set_state(1215);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1216);
			recog.unannType()?;

			recog.base.set_state(1220);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXPORTS || _la==MODULE || ((((_la - 34)) & !0x3f) == 0 && ((1usize << (_la - 34)) & ((1usize << (OPEN - 34)) | (1usize << (OPERNS - 34)) | (1usize << (PROVIDES - 34)) | (1usize << (REQUIRES - 34)) | (1usize << (TO - 34)) | (1usize << (USES - 34)) | (1usize << (WITH - 34)))) != 0) || _la==Identifier {
				{
				/*InvokeRule identifier*/
				recog.base.set_state(1217);
				recog.identifier()?;

				recog.base.set_state(1218);
				recog.base.match_token(DOT,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1222);
			recog.base.match_token(THIS,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- throws_ ----------------
pub type Throws_ContextAll<'input> = Throws_Context<'input>;


pub type Throws_Context<'input> = BaseParserRuleContext<'input,Throws_ContextExt<'input>>;

#[derive(Clone)]
pub struct Throws_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for Throws_Context<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for Throws_Context<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_throws_(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_throws_(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for Throws_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_throws_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_throws_ }
}
antlr_rust::tid!{Throws_ContextExt<'a>}

impl<'input> Throws_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Throws_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Throws_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Throws_ContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<Throws_ContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token THROWS
/// Returns `None` if there is no child corresponding to token THROWS
fn THROWS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(THROWS, 0)
}
fn exceptionTypeList(&self) -> Option<Rc<ExceptionTypeListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Throws_ContextAttrs<'input> for Throws_Context<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn throws_(&mut self,)
	-> Result<Rc<Throws_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Throws_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_throws_);
        let mut _localctx: Rc<Throws_ContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1224);
			recog.base.match_token(THROWS,&mut recog.err_handler)?;

			/*InvokeRule exceptionTypeList*/
			recog.base.set_state(1225);
			recog.exceptionTypeList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- exceptionTypeList ----------------
pub type ExceptionTypeListContextAll<'input> = ExceptionTypeListContext<'input>;


pub type ExceptionTypeListContext<'input> = BaseParserRuleContext<'input,ExceptionTypeListContextExt<'input>>;

#[derive(Clone)]
pub struct ExceptionTypeListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ExceptionTypeListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ExceptionTypeListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_exceptionTypeList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_exceptionTypeList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExceptionTypeListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exceptionTypeList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exceptionTypeList }
}
antlr_rust::tid!{ExceptionTypeListContextExt<'a>}

impl<'input> ExceptionTypeListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExceptionTypeListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExceptionTypeListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExceptionTypeListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ExceptionTypeListContextExt<'input>>{

fn exceptionType_all(&self) ->  Vec<Rc<ExceptionTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn exceptionType(&self, i: usize) -> Option<Rc<ExceptionTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ExceptionTypeListContextAttrs<'input> for ExceptionTypeListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn exceptionTypeList(&mut self,)
	-> Result<Rc<ExceptionTypeListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExceptionTypeListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_exceptionTypeList);
        let mut _localctx: Rc<ExceptionTypeListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule exceptionType*/
			recog.base.set_state(1227);
			recog.exceptionType()?;

			recog.base.set_state(1232);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(1228);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule exceptionType*/
				recog.base.set_state(1229);
				recog.exceptionType()?;

				}
				}
				recog.base.set_state(1234);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- exceptionType ----------------
pub type ExceptionTypeContextAll<'input> = ExceptionTypeContext<'input>;


pub type ExceptionTypeContext<'input> = BaseParserRuleContext<'input,ExceptionTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ExceptionTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ExceptionTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ExceptionTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_exceptionType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_exceptionType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExceptionTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exceptionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exceptionType }
}
antlr_rust::tid!{ExceptionTypeContextExt<'a>}

impl<'input> ExceptionTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExceptionTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExceptionTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExceptionTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ExceptionTypeContextExt<'input>>{

fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeVariable(&self) -> Option<Rc<TypeVariableContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExceptionTypeContextAttrs<'input> for ExceptionTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn exceptionType(&mut self,)
	-> Result<Rc<ExceptionTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExceptionTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_exceptionType);
        let mut _localctx: Rc<ExceptionTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1237);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(107,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classType*/
					recog.base.set_state(1235);
					recog.classType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeVariable*/
					recog.base.set_state(1236);
					recog.typeVariable()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodBody ----------------
pub type MethodBodyContextAll<'input> = MethodBodyContext<'input>;


pub type MethodBodyContext<'input> = BaseParserRuleContext<'input,MethodBodyContextExt<'input>>;

#[derive(Clone)]
pub struct MethodBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodBody(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodBody }
}
antlr_rust::tid!{MethodBodyContextExt<'a>}

impl<'input> MethodBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodBodyContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodBodyContextExt<'input>>{

fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> MethodBodyContextAttrs<'input> for MethodBodyContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodBody(&mut self,)
	-> Result<Rc<MethodBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_methodBody);
        let mut _localctx: Rc<MethodBodyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1241);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LBRACE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule block*/
					recog.base.set_state(1239);
					recog.block()?;

					}
				}

			 SEMI 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1240);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- instanceInitializer ----------------
pub type InstanceInitializerContextAll<'input> = InstanceInitializerContext<'input>;


pub type InstanceInitializerContext<'input> = BaseParserRuleContext<'input,InstanceInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct InstanceInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InstanceInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InstanceInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_instanceInitializer(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_instanceInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InstanceInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_instanceInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_instanceInitializer }
}
antlr_rust::tid!{InstanceInitializerContextExt<'a>}

impl<'input> InstanceInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InstanceInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InstanceInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InstanceInitializerContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InstanceInitializerContextExt<'input>>{

fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InstanceInitializerContextAttrs<'input> for InstanceInitializerContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn instanceInitializer(&mut self,)
	-> Result<Rc<InstanceInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InstanceInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_instanceInitializer);
        let mut _localctx: Rc<InstanceInitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule block*/
			recog.base.set_state(1243);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- staticInitializer ----------------
pub type StaticInitializerContextAll<'input> = StaticInitializerContext<'input>;


pub type StaticInitializerContext<'input> = BaseParserRuleContext<'input,StaticInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct StaticInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for StaticInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for StaticInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_staticInitializer(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_staticInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StaticInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_staticInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_staticInitializer }
}
antlr_rust::tid!{StaticInitializerContextExt<'a>}

impl<'input> StaticInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StaticInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StaticInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StaticInitializerContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<StaticInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StaticInitializerContextAttrs<'input> for StaticInitializerContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn staticInitializer(&mut self,)
	-> Result<Rc<StaticInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StaticInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_staticInitializer);
        let mut _localctx: Rc<StaticInitializerContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1245);
			recog.base.match_token(STATIC,&mut recog.err_handler)?;

			/*InvokeRule block*/
			recog.base.set_state(1246);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorDeclaration ----------------
pub type ConstructorDeclarationContextAll<'input> = ConstructorDeclarationContext<'input>;


pub type ConstructorDeclarationContext<'input> = BaseParserRuleContext<'input,ConstructorDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ConstructorDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ConstructorDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constructorDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_constructorDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstructorDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorDeclaration }
}
antlr_rust::tid!{ConstructorDeclarationContextExt<'a>}

impl<'input> ConstructorDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ConstructorDeclarationContextExt<'input>>{

fn constructorDeclarator(&self) -> Option<Rc<ConstructorDeclaratorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constructorBody(&self) -> Option<Rc<ConstructorBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constructorModifier_all(&self) ->  Vec<Rc<ConstructorModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constructorModifier(&self, i: usize) -> Option<Rc<ConstructorModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn throws_(&self) -> Option<Rc<Throws_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstructorDeclarationContextAttrs<'input> for ConstructorDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorDeclaration(&mut self,)
	-> Result<Rc<ConstructorDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_constructorDeclaration);
        let mut _localctx: Rc<ConstructorDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1251);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (PRIVATE - 37)) | (1usize << (PROTECTED - 37)) | (1usize << (PUBLIC - 37)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule constructorModifier*/
				recog.base.set_state(1248);
				recog.constructorModifier()?;

				}
				}
				recog.base.set_state(1253);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule constructorDeclarator*/
			recog.base.set_state(1254);
			recog.constructorDeclarator()?;

			recog.base.set_state(1256);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==THROWS {
				{
				/*InvokeRule throws_*/
				recog.base.set_state(1255);
				recog.throws_()?;

				}
			}

			/*InvokeRule constructorBody*/
			recog.base.set_state(1258);
			recog.constructorBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorModifier ----------------
pub type ConstructorModifierContextAll<'input> = ConstructorModifierContext<'input>;


pub type ConstructorModifierContext<'input> = BaseParserRuleContext<'input,ConstructorModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ConstructorModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ConstructorModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constructorModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_constructorModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstructorModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorModifier }
}
antlr_rust::tid!{ConstructorModifierContextExt<'a>}

impl<'input> ConstructorModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ConstructorModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}

}

impl<'input> ConstructorModifierContextAttrs<'input> for ConstructorModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorModifier(&mut self,)
	-> Result<Rc<ConstructorModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_constructorModifier);
        let mut _localctx: Rc<ConstructorModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1264);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1260);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1261);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PROTECTED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1262);
					recog.base.match_token(PROTECTED,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1263);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorDeclarator ----------------
pub type ConstructorDeclaratorContextAll<'input> = ConstructorDeclaratorContext<'input>;


pub type ConstructorDeclaratorContext<'input> = BaseParserRuleContext<'input,ConstructorDeclaratorContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorDeclaratorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ConstructorDeclaratorContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ConstructorDeclaratorContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constructorDeclarator(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_constructorDeclarator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstructorDeclaratorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorDeclarator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorDeclarator }
}
antlr_rust::tid!{ConstructorDeclaratorContextExt<'a>}

impl<'input> ConstructorDeclaratorContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorDeclaratorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorDeclaratorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorDeclaratorContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ConstructorDeclaratorContextExt<'input>>{

fn simpleTypeName(&self) -> Option<Rc<SimpleTypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn formalParameterList(&self) -> Option<Rc<FormalParameterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstructorDeclaratorContextAttrs<'input> for ConstructorDeclaratorContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorDeclarator(&mut self,)
	-> Result<Rc<ConstructorDeclaratorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorDeclaratorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_constructorDeclarator);
        let mut _localctx: Rc<ConstructorDeclaratorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1267);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeParameters*/
				recog.base.set_state(1266);
				recog.typeParameters()?;

				}
			}

			/*InvokeRule simpleTypeName*/
			recog.base.set_state(1269);
			recog.simpleTypeName()?;

			recog.base.set_state(1270);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1272);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 34)) & !0x3f) == 0 && ((1usize << (_la - 34)) & ((1usize << (OPEN - 34)) | (1usize << (OPERNS - 34)) | (1usize << (PROVIDES - 34)) | (1usize << (REQUIRES - 34)) | (1usize << (SHORT - 34)) | (1usize << (TO - 34)) | (1usize << (USES - 34)) | (1usize << (WITH - 34)))) != 0) || _la==AT || _la==Identifier {
				{
				/*InvokeRule formalParameterList*/
				recog.base.set_state(1271);
				recog.formalParameterList()?;

				}
			}

			recog.base.set_state(1274);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleTypeName ----------------
pub type SimpleTypeNameContextAll<'input> = SimpleTypeNameContext<'input>;


pub type SimpleTypeNameContext<'input> = BaseParserRuleContext<'input,SimpleTypeNameContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleTypeNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SimpleTypeNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SimpleTypeNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_simpleTypeName(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_simpleTypeName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SimpleTypeNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleTypeName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleTypeName }
}
antlr_rust::tid!{SimpleTypeNameContextExt<'a>}

impl<'input> SimpleTypeNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleTypeNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleTypeNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleTypeNameContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SimpleTypeNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SimpleTypeNameContextAttrs<'input> for SimpleTypeNameContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleTypeName(&mut self,)
	-> Result<Rc<SimpleTypeNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleTypeNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_simpleTypeName);
        let mut _localctx: Rc<SimpleTypeNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1276);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorBody ----------------
pub type ConstructorBodyContextAll<'input> = ConstructorBodyContext<'input>;


pub type ConstructorBodyContext<'input> = BaseParserRuleContext<'input,ConstructorBodyContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ConstructorBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ConstructorBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constructorBody(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_constructorBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstructorBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorBody }
}
antlr_rust::tid!{ConstructorBodyContextExt<'a>}

impl<'input> ConstructorBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorBodyContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ConstructorBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn explicitConstructorInvocation(&self) -> Option<Rc<ExplicitConstructorInvocationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn blockStatements(&self) -> Option<Rc<BlockStatementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstructorBodyContextAttrs<'input> for ConstructorBodyContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorBody(&mut self,)
	-> Result<Rc<ConstructorBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_constructorBody);
        let mut _localctx: Rc<ConstructorBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1278);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1280);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(114,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule explicitConstructorInvocation*/
					recog.base.set_state(1279);
					recog.explicitConstructorInvocation()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1283);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABSTRACT) | (1usize << ASSERT) | (1usize << BOOLEAN) | (1usize << BREAK) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << CONTINUE) | (1usize << DO) | (1usize << DOUBLE) | (1usize << ENUM) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << FOR) | (1usize << IF) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (RETURN - 33)) | (1usize << (SHORT - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)) | (1usize << (SUPER - 33)) | (1usize << (SWITCH - 33)) | (1usize << (SYNCHRONIZED - 33)) | (1usize << (THIS - 33)) | (1usize << (THROW - 33)) | (1usize << (TO - 33)) | (1usize << (TRY - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WHILE - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (LBRACE - 65)) | (1usize << (SEMI - 65)) | (1usize << (AT - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)))) != 0) || _la==Identifier {
				{
				/*InvokeRule blockStatements*/
				recog.base.set_state(1282);
				recog.blockStatements()?;

				}
			}

			recog.base.set_state(1285);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- explicitConstructorInvocation ----------------
pub type ExplicitConstructorInvocationContextAll<'input> = ExplicitConstructorInvocationContext<'input>;


pub type ExplicitConstructorInvocationContext<'input> = BaseParserRuleContext<'input,ExplicitConstructorInvocationContextExt<'input>>;

#[derive(Clone)]
pub struct ExplicitConstructorInvocationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ExplicitConstructorInvocationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ExplicitConstructorInvocationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_explicitConstructorInvocation(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_explicitConstructorInvocation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExplicitConstructorInvocationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_explicitConstructorInvocation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_explicitConstructorInvocation }
}
antlr_rust::tid!{ExplicitConstructorInvocationContextExt<'a>}

impl<'input> ExplicitConstructorInvocationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExplicitConstructorInvocationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExplicitConstructorInvocationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExplicitConstructorInvocationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ExplicitConstructorInvocationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExplicitConstructorInvocationContextAttrs<'input> for ExplicitConstructorInvocationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn explicitConstructorInvocation(&mut self,)
	-> Result<Rc<ExplicitConstructorInvocationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExplicitConstructorInvocationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_explicitConstructorInvocation);
        let mut _localctx: Rc<ExplicitConstructorInvocationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1333);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(124,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1288);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(1287);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(1290);
					recog.base.match_token(THIS,&mut recog.err_handler)?;

					recog.base.set_state(1291);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1293);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(1292);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(1295);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1296);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1298);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(1297);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(1300);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(1301);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1303);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(1302);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(1305);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1306);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(1307);
					recog.expressionName()?;

					recog.base.set_state(1308);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1310);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(1309);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(1312);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(1313);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1315);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(1314);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(1317);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1318);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule primary*/
					recog.base.set_state(1320);
					recog.primary()?;

					recog.base.set_state(1321);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1323);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(1322);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(1325);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(1326);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1328);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(1327);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(1330);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1331);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumDeclaration ----------------
pub type EnumDeclarationContextAll<'input> = EnumDeclarationContext<'input>;


pub type EnumDeclarationContext<'input> = BaseParserRuleContext<'input,EnumDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct EnumDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for EnumDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for EnumDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_enumDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumDeclaration }
}
antlr_rust::tid!{EnumDeclarationContextExt<'a>}

impl<'input> EnumDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<EnumDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ENUM
/// Returns `None` if there is no child corresponding to token ENUM
fn ENUM(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ENUM, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enumBody(&self) -> Option<Rc<EnumBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classModifier_all(&self) ->  Vec<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classModifier(&self, i: usize) -> Option<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn superinterfaces(&self) -> Option<Rc<SuperinterfacesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumDeclarationContextAttrs<'input> for EnumDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumDeclaration(&mut self,)
	-> Result<Rc<EnumDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_enumDeclaration);
        let mut _localctx: Rc<EnumDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1338);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==ABSTRACT || _la==FINAL || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (PRIVATE - 37)) | (1usize << (PROTECTED - 37)) | (1usize << (PUBLIC - 37)) | (1usize << (STATIC - 37)) | (1usize << (STRICTFP - 37)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule classModifier*/
				recog.base.set_state(1335);
				recog.classModifier()?;

				}
				}
				recog.base.set_state(1340);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1341);
			recog.base.match_token(ENUM,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(1342);
			recog.identifier()?;

			recog.base.set_state(1344);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==IMPLEMENTS {
				{
				/*InvokeRule superinterfaces*/
				recog.base.set_state(1343);
				recog.superinterfaces()?;

				}
			}

			/*InvokeRule enumBody*/
			recog.base.set_state(1346);
			recog.enumBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumBody ----------------
pub type EnumBodyContextAll<'input> = EnumBodyContext<'input>;


pub type EnumBodyContext<'input> = BaseParserRuleContext<'input,EnumBodyContextExt<'input>>;

#[derive(Clone)]
pub struct EnumBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for EnumBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for EnumBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumBody(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_enumBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumBody }
}
antlr_rust::tid!{EnumBodyContextExt<'a>}

impl<'input> EnumBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumBodyContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<EnumBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn enumConstantList(&self) -> Option<Rc<EnumConstantListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn enumBodyDeclarations(&self) -> Option<Rc<EnumBodyDeclarationsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumBodyContextAttrs<'input> for EnumBodyContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumBody(&mut self,)
	-> Result<Rc<EnumBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_enumBody);
        let mut _localctx: Rc<EnumBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1348);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1350);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 17)) & !0x3f) == 0 && ((1usize << (_la - 17)) & ((1usize << (EXPORTS - 17)) | (1usize << (MODULE - 17)) | (1usize << (OPEN - 17)) | (1usize << (OPERNS - 17)) | (1usize << (PROVIDES - 17)) | (1usize << (REQUIRES - 17)))) != 0) || ((((_la - 52)) & !0x3f) == 0 && ((1usize << (_la - 52)) & ((1usize << (TO - 52)) | (1usize << (USES - 52)) | (1usize << (WITH - 52)) | (1usize << (AT - 52)))) != 0) || _la==Identifier {
				{
				/*InvokeRule enumConstantList*/
				recog.base.set_state(1349);
				recog.enumConstantList()?;

				}
			}

			recog.base.set_state(1353);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(1352);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1356);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==SEMI {
				{
				/*InvokeRule enumBodyDeclarations*/
				recog.base.set_state(1355);
				recog.enumBodyDeclarations()?;

				}
			}

			recog.base.set_state(1358);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumConstantList ----------------
pub type EnumConstantListContextAll<'input> = EnumConstantListContext<'input>;


pub type EnumConstantListContext<'input> = BaseParserRuleContext<'input,EnumConstantListContextExt<'input>>;

#[derive(Clone)]
pub struct EnumConstantListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for EnumConstantListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for EnumConstantListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumConstantList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_enumConstantList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumConstantListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumConstantList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumConstantList }
}
antlr_rust::tid!{EnumConstantListContextExt<'a>}

impl<'input> EnumConstantListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumConstantListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumConstantListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumConstantListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<EnumConstantListContextExt<'input>>{

fn enumConstant_all(&self) ->  Vec<Rc<EnumConstantContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn enumConstant(&self, i: usize) -> Option<Rc<EnumConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> EnumConstantListContextAttrs<'input> for EnumConstantListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumConstantList(&mut self,)
	-> Result<Rc<EnumConstantListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumConstantListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_enumConstantList);
        let mut _localctx: Rc<EnumConstantListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule enumConstant*/
			recog.base.set_state(1360);
			recog.enumConstant()?;

			recog.base.set_state(1365);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(130,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1361);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule enumConstant*/
					recog.base.set_state(1362);
					recog.enumConstant()?;

					}
					} 
				}
				recog.base.set_state(1367);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(130,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumConstant ----------------
pub type EnumConstantContextAll<'input> = EnumConstantContext<'input>;


pub type EnumConstantContext<'input> = BaseParserRuleContext<'input,EnumConstantContextExt<'input>>;

#[derive(Clone)]
pub struct EnumConstantContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for EnumConstantContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for EnumConstantContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumConstant(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_enumConstant(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumConstantContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumConstant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumConstant }
}
antlr_rust::tid!{EnumConstantContextExt<'a>}

impl<'input> EnumConstantContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumConstantContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumConstantContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumConstantContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<EnumConstantContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enumConstantModifier_all(&self) ->  Vec<Rc<EnumConstantModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn enumConstantModifier(&self, i: usize) -> Option<Rc<EnumConstantModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumConstantContextAttrs<'input> for EnumConstantContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumConstant(&mut self,)
	-> Result<Rc<EnumConstantContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumConstantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_enumConstant);
        let mut _localctx: Rc<EnumConstantContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1371);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule enumConstantModifier*/
				recog.base.set_state(1368);
				recog.enumConstantModifier()?;

				}
				}
				recog.base.set_state(1373);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule identifier*/
			recog.base.set_state(1374);
			recog.identifier()?;

			recog.base.set_state(1380);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LPAREN {
				{
				recog.base.set_state(1375);
				recog.base.match_token(LPAREN,&mut recog.err_handler)?;

				recog.base.set_state(1377);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
					{
					/*InvokeRule argumentList*/
					recog.base.set_state(1376);
					recog.argumentList()?;

					}
				}

				recog.base.set_state(1379);
				recog.base.match_token(RPAREN,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1383);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LBRACE {
				{
				/*InvokeRule classBody*/
				recog.base.set_state(1382);
				recog.classBody()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumConstantModifier ----------------
pub type EnumConstantModifierContextAll<'input> = EnumConstantModifierContext<'input>;


pub type EnumConstantModifierContext<'input> = BaseParserRuleContext<'input,EnumConstantModifierContextExt<'input>>;

#[derive(Clone)]
pub struct EnumConstantModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for EnumConstantModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for EnumConstantModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumConstantModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_enumConstantModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumConstantModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumConstantModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumConstantModifier }
}
antlr_rust::tid!{EnumConstantModifierContextExt<'a>}

impl<'input> EnumConstantModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumConstantModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumConstantModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumConstantModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<EnumConstantModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumConstantModifierContextAttrs<'input> for EnumConstantModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumConstantModifier(&mut self,)
	-> Result<Rc<EnumConstantModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumConstantModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_enumConstantModifier);
        let mut _localctx: Rc<EnumConstantModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule annotation*/
			recog.base.set_state(1385);
			recog.annotation()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumBodyDeclarations ----------------
pub type EnumBodyDeclarationsContextAll<'input> = EnumBodyDeclarationsContext<'input>;


pub type EnumBodyDeclarationsContext<'input> = BaseParserRuleContext<'input,EnumBodyDeclarationsContextExt<'input>>;

#[derive(Clone)]
pub struct EnumBodyDeclarationsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for EnumBodyDeclarationsContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for EnumBodyDeclarationsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumBodyDeclarations(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_enumBodyDeclarations(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumBodyDeclarationsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumBodyDeclarations }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumBodyDeclarations }
}
antlr_rust::tid!{EnumBodyDeclarationsContextExt<'a>}

impl<'input> EnumBodyDeclarationsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumBodyDeclarationsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumBodyDeclarationsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumBodyDeclarationsContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<EnumBodyDeclarationsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn classBodyDeclaration_all(&self) ->  Vec<Rc<ClassBodyDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classBodyDeclaration(&self, i: usize) -> Option<Rc<ClassBodyDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> EnumBodyDeclarationsContextAttrs<'input> for EnumBodyDeclarationsContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumBodyDeclarations(&mut self,)
	-> Result<Rc<EnumBodyDeclarationsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumBodyDeclarationsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_enumBodyDeclarations);
        let mut _localctx: Rc<EnumBodyDeclarationsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1387);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			recog.base.set_state(1391);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABSTRACT) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << DOUBLE) | (1usize << ENUM) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << INT) | (1usize << INTERFACE) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (NATIVE - 32)) | (1usize << (OPEN - 32)) | (1usize << (OPERNS - 32)) | (1usize << (PRIVATE - 32)) | (1usize << (PROTECTED - 32)) | (1usize << (PROVIDES - 32)) | (1usize << (PUBLIC - 32)) | (1usize << (REQUIRES - 32)) | (1usize << (SHORT - 32)) | (1usize << (STATIC - 32)) | (1usize << (STRICTFP - 32)) | (1usize << (SYNCHRONIZED - 32)) | (1usize << (TO - 32)) | (1usize << (TRANSIENT - 32)) | (1usize << (USES - 32)) | (1usize << (VOID - 32)) | (1usize << (VOLATILE - 32)) | (1usize << (WITH - 32)))) != 0) || ((((_la - 70)) & !0x3f) == 0 && ((1usize << (_la - 70)) & ((1usize << (LBRACE - 70)) | (1usize << (SEMI - 70)) | (1usize << (AT - 70)) | (1usize << (LT - 70)))) != 0) || _la==Identifier {
				{
				{
				/*InvokeRule classBodyDeclaration*/
				recog.base.set_state(1388);
				recog.classBodyDeclaration()?;

				}
				}
				recog.base.set_state(1393);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceDeclaration ----------------
pub type InterfaceDeclarationContextAll<'input> = InterfaceDeclarationContext<'input>;


pub type InterfaceDeclarationContext<'input> = BaseParserRuleContext<'input,InterfaceDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InterfaceDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InterfaceDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_interfaceDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InterfaceDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceDeclaration }
}
antlr_rust::tid!{InterfaceDeclarationContextExt<'a>}

impl<'input> InterfaceDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InterfaceDeclarationContextExt<'input>>{

fn normalInterfaceDeclaration(&self) -> Option<Rc<NormalInterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotationTypeDeclaration(&self) -> Option<Rc<AnnotationTypeDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InterfaceDeclarationContextAttrs<'input> for InterfaceDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceDeclaration(&mut self,)
	-> Result<Rc<InterfaceDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_interfaceDeclaration);
        let mut _localctx: Rc<InterfaceDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1396);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(136,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule normalInterfaceDeclaration*/
					recog.base.set_state(1394);
					recog.normalInterfaceDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule annotationTypeDeclaration*/
					recog.base.set_state(1395);
					recog.annotationTypeDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- normalInterfaceDeclaration ----------------
pub type NormalInterfaceDeclarationContextAll<'input> = NormalInterfaceDeclarationContext<'input>;


pub type NormalInterfaceDeclarationContext<'input> = BaseParserRuleContext<'input,NormalInterfaceDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct NormalInterfaceDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for NormalInterfaceDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for NormalInterfaceDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_normalInterfaceDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_normalInterfaceDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NormalInterfaceDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_normalInterfaceDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_normalInterfaceDeclaration }
}
antlr_rust::tid!{NormalInterfaceDeclarationContextExt<'a>}

impl<'input> NormalInterfaceDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NormalInterfaceDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NormalInterfaceDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NormalInterfaceDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<NormalInterfaceDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INTERFACE
/// Returns `None` if there is no child corresponding to token INTERFACE
fn INTERFACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(INTERFACE, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceBody(&self) -> Option<Rc<InterfaceBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceModifier_all(&self) ->  Vec<Rc<InterfaceModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceModifier(&self, i: usize) -> Option<Rc<InterfaceModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn extendsInterfaces(&self) -> Option<Rc<ExtendsInterfacesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NormalInterfaceDeclarationContextAttrs<'input> for NormalInterfaceDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn normalInterfaceDeclaration(&mut self,)
	-> Result<Rc<NormalInterfaceDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NormalInterfaceDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_normalInterfaceDeclaration);
        let mut _localctx: Rc<NormalInterfaceDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1401);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==ABSTRACT || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (PRIVATE - 37)) | (1usize << (PROTECTED - 37)) | (1usize << (PUBLIC - 37)) | (1usize << (STATIC - 37)) | (1usize << (STRICTFP - 37)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule interfaceModifier*/
				recog.base.set_state(1398);
				recog.interfaceModifier()?;

				}
				}
				recog.base.set_state(1403);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1404);
			recog.base.match_token(INTERFACE,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(1405);
			recog.identifier()?;

			recog.base.set_state(1407);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeParameters*/
				recog.base.set_state(1406);
				recog.typeParameters()?;

				}
			}

			recog.base.set_state(1410);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXTENDS {
				{
				/*InvokeRule extendsInterfaces*/
				recog.base.set_state(1409);
				recog.extendsInterfaces()?;

				}
			}

			/*InvokeRule interfaceBody*/
			recog.base.set_state(1412);
			recog.interfaceBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceModifier ----------------
pub type InterfaceModifierContextAll<'input> = InterfaceModifierContext<'input>;


pub type InterfaceModifierContext<'input> = BaseParserRuleContext<'input,InterfaceModifierContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InterfaceModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InterfaceModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_interfaceModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InterfaceModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceModifier }
}
antlr_rust::tid!{InterfaceModifierContextExt<'a>}

impl<'input> InterfaceModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InterfaceModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token STRICTFP
/// Returns `None` if there is no child corresponding to token STRICTFP
fn STRICTFP(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STRICTFP, 0)
}

}

impl<'input> InterfaceModifierContextAttrs<'input> for InterfaceModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceModifier(&mut self,)
	-> Result<Rc<InterfaceModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_interfaceModifier);
        let mut _localctx: Rc<InterfaceModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1421);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1414);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1415);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PROTECTED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1416);
					recog.base.match_token(PROTECTED,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1417);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

			 ABSTRACT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1418);
					recog.base.match_token(ABSTRACT,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(1419);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 STRICTFP 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(1420);
					recog.base.match_token(STRICTFP,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- extendsInterfaces ----------------
pub type ExtendsInterfacesContextAll<'input> = ExtendsInterfacesContext<'input>;


pub type ExtendsInterfacesContext<'input> = BaseParserRuleContext<'input,ExtendsInterfacesContextExt<'input>>;

#[derive(Clone)]
pub struct ExtendsInterfacesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ExtendsInterfacesContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ExtendsInterfacesContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_extendsInterfaces(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_extendsInterfaces(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExtendsInterfacesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_extendsInterfaces }
	//fn type_rule_index() -> usize where Self: Sized { RULE_extendsInterfaces }
}
antlr_rust::tid!{ExtendsInterfacesContextExt<'a>}

impl<'input> ExtendsInterfacesContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExtendsInterfacesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExtendsInterfacesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExtendsInterfacesContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ExtendsInterfacesContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXTENDS
/// Returns `None` if there is no child corresponding to token EXTENDS
fn EXTENDS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(EXTENDS, 0)
}
fn interfaceTypeList(&self) -> Option<Rc<InterfaceTypeListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExtendsInterfacesContextAttrs<'input> for ExtendsInterfacesContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn extendsInterfaces(&mut self,)
	-> Result<Rc<ExtendsInterfacesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExtendsInterfacesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_extendsInterfaces);
        let mut _localctx: Rc<ExtendsInterfacesContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1423);
			recog.base.match_token(EXTENDS,&mut recog.err_handler)?;

			/*InvokeRule interfaceTypeList*/
			recog.base.set_state(1424);
			recog.interfaceTypeList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceBody ----------------
pub type InterfaceBodyContextAll<'input> = InterfaceBodyContext<'input>;


pub type InterfaceBodyContext<'input> = BaseParserRuleContext<'input,InterfaceBodyContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InterfaceBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InterfaceBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceBody(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_interfaceBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InterfaceBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceBody }
}
antlr_rust::tid!{InterfaceBodyContextExt<'a>}

impl<'input> InterfaceBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceBodyContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InterfaceBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn interfaceMemberDeclaration_all(&self) ->  Vec<Rc<InterfaceMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceMemberDeclaration(&self, i: usize) -> Option<Rc<InterfaceMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> InterfaceBodyContextAttrs<'input> for InterfaceBodyContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceBody(&mut self,)
	-> Result<Rc<InterfaceBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_interfaceBody);
        let mut _localctx: Rc<InterfaceBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1426);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1430);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABSTRACT) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << DEFAULT) | (1usize << DOUBLE) | (1usize << ENUM) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << INT) | (1usize << INTERFACE) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 34)) & !0x3f) == 0 && ((1usize << (_la - 34)) & ((1usize << (OPEN - 34)) | (1usize << (OPERNS - 34)) | (1usize << (PRIVATE - 34)) | (1usize << (PROTECTED - 34)) | (1usize << (PROVIDES - 34)) | (1usize << (PUBLIC - 34)) | (1usize << (REQUIRES - 34)) | (1usize << (SHORT - 34)) | (1usize << (STATIC - 34)) | (1usize << (STRICTFP - 34)) | (1usize << (TO - 34)) | (1usize << (USES - 34)) | (1usize << (VOID - 34)) | (1usize << (WITH - 34)))) != 0) || ((((_la - 74)) & !0x3f) == 0 && ((1usize << (_la - 74)) & ((1usize << (SEMI - 74)) | (1usize << (AT - 74)) | (1usize << (LT - 74)))) != 0) || _la==Identifier {
				{
				{
				/*InvokeRule interfaceMemberDeclaration*/
				recog.base.set_state(1427);
				recog.interfaceMemberDeclaration()?;

				}
				}
				recog.base.set_state(1432);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1433);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceMemberDeclaration ----------------
pub type InterfaceMemberDeclarationContextAll<'input> = InterfaceMemberDeclarationContext<'input>;


pub type InterfaceMemberDeclarationContext<'input> = BaseParserRuleContext<'input,InterfaceMemberDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceMemberDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InterfaceMemberDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InterfaceMemberDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceMemberDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_interfaceMemberDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InterfaceMemberDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceMemberDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceMemberDeclaration }
}
antlr_rust::tid!{InterfaceMemberDeclarationContextExt<'a>}

impl<'input> InterfaceMemberDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceMemberDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceMemberDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceMemberDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InterfaceMemberDeclarationContextExt<'input>>{

fn constantDeclaration(&self) -> Option<Rc<ConstantDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceMethodDeclaration(&self) -> Option<Rc<InterfaceMethodDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceDeclaration(&self) -> Option<Rc<InterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> InterfaceMemberDeclarationContextAttrs<'input> for InterfaceMemberDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceMemberDeclaration(&mut self,)
	-> Result<Rc<InterfaceMemberDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceMemberDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_interfaceMemberDeclaration);
        let mut _localctx: Rc<InterfaceMemberDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1440);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(142,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule constantDeclaration*/
					recog.base.set_state(1435);
					recog.constantDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule interfaceMethodDeclaration*/
					recog.base.set_state(1436);
					recog.interfaceMethodDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(1437);
					recog.classDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule interfaceDeclaration*/
					recog.base.set_state(1438);
					recog.interfaceDeclaration()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1439);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constantDeclaration ----------------
pub type ConstantDeclarationContextAll<'input> = ConstantDeclarationContext<'input>;


pub type ConstantDeclarationContext<'input> = BaseParserRuleContext<'input,ConstantDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ConstantDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ConstantDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ConstantDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constantDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_constantDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstantDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constantDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constantDeclaration }
}
antlr_rust::tid!{ConstantDeclarationContextExt<'a>}

impl<'input> ConstantDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstantDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstantDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstantDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ConstantDeclarationContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorList(&self) -> Option<Rc<VariableDeclaratorListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn constantModifier_all(&self) ->  Vec<Rc<ConstantModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn constantModifier(&self, i: usize) -> Option<Rc<ConstantModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ConstantDeclarationContextAttrs<'input> for ConstantDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constantDeclaration(&mut self,)
	-> Result<Rc<ConstantDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstantDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_constantDeclaration);
        let mut _localctx: Rc<ConstantDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1445);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 19)) & !0x3f) == 0 && ((1usize << (_la - 19)) & ((1usize << (FINAL - 19)) | (1usize << (PUBLIC - 19)) | (1usize << (STATIC - 19)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule constantModifier*/
				recog.base.set_state(1442);
				recog.constantModifier()?;

				}
				}
				recog.base.set_state(1447);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1448);
			recog.unannType()?;

			/*InvokeRule variableDeclaratorList*/
			recog.base.set_state(1449);
			recog.variableDeclaratorList()?;

			recog.base.set_state(1450);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constantModifier ----------------
pub type ConstantModifierContextAll<'input> = ConstantModifierContext<'input>;


pub type ConstantModifierContext<'input> = BaseParserRuleContext<'input,ConstantModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ConstantModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ConstantModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ConstantModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constantModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_constantModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstantModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constantModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constantModifier }
}
antlr_rust::tid!{ConstantModifierContextExt<'a>}

impl<'input> ConstantModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstantModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstantModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstantModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ConstantModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}

}

impl<'input> ConstantModifierContextAttrs<'input> for ConstantModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constantModifier(&mut self,)
	-> Result<Rc<ConstantModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstantModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_constantModifier);
        let mut _localctx: Rc<ConstantModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1456);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1452);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1453);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1454);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 FINAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1455);
					recog.base.match_token(FINAL,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceMethodDeclaration ----------------
pub type InterfaceMethodDeclarationContextAll<'input> = InterfaceMethodDeclarationContext<'input>;


pub type InterfaceMethodDeclarationContext<'input> = BaseParserRuleContext<'input,InterfaceMethodDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceMethodDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InterfaceMethodDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InterfaceMethodDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceMethodDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_interfaceMethodDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InterfaceMethodDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceMethodDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceMethodDeclaration }
}
antlr_rust::tid!{InterfaceMethodDeclarationContextExt<'a>}

impl<'input> InterfaceMethodDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceMethodDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceMethodDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceMethodDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InterfaceMethodDeclarationContextExt<'input>>{

fn methodHeader(&self) -> Option<Rc<MethodHeaderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodBody(&self) -> Option<Rc<MethodBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceMethodModifier_all(&self) ->  Vec<Rc<InterfaceMethodModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceMethodModifier(&self, i: usize) -> Option<Rc<InterfaceMethodModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> InterfaceMethodDeclarationContextAttrs<'input> for InterfaceMethodDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceMethodDeclaration(&mut self,)
	-> Result<Rc<InterfaceMethodDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceMethodDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_interfaceMethodDeclaration);
        let mut _localctx: Rc<InterfaceMethodDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1461);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==ABSTRACT || _la==DEFAULT || ((((_la - 37)) & !0x3f) == 0 && ((1usize << (_la - 37)) & ((1usize << (PRIVATE - 37)) | (1usize << (PUBLIC - 37)) | (1usize << (STATIC - 37)) | (1usize << (STRICTFP - 37)))) != 0) || _la==AT {
				{
				{
				/*InvokeRule interfaceMethodModifier*/
				recog.base.set_state(1458);
				recog.interfaceMethodModifier()?;

				}
				}
				recog.base.set_state(1463);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule methodHeader*/
			recog.base.set_state(1464);
			recog.methodHeader()?;

			/*InvokeRule methodBody*/
			recog.base.set_state(1465);
			recog.methodBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interfaceMethodModifier ----------------
pub type InterfaceMethodModifierContextAll<'input> = InterfaceMethodModifierContext<'input>;


pub type InterfaceMethodModifierContext<'input> = BaseParserRuleContext<'input,InterfaceMethodModifierContextExt<'input>>;

#[derive(Clone)]
pub struct InterfaceMethodModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InterfaceMethodModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InterfaceMethodModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interfaceMethodModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_interfaceMethodModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InterfaceMethodModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interfaceMethodModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interfaceMethodModifier }
}
antlr_rust::tid!{InterfaceMethodModifierContextExt<'a>}

impl<'input> InterfaceMethodModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InterfaceMethodModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InterfaceMethodModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InterfaceMethodModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InterfaceMethodModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token STRICTFP
/// Returns `None` if there is no child corresponding to token STRICTFP
fn STRICTFP(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(STRICTFP, 0)
}

}

impl<'input> InterfaceMethodModifierContextAttrs<'input> for InterfaceMethodModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interfaceMethodModifier(&mut self,)
	-> Result<Rc<InterfaceMethodModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InterfaceMethodModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_interfaceMethodModifier);
        let mut _localctx: Rc<InterfaceMethodModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1474);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1467);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1468);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 PRIVATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1469);
					recog.base.match_token(PRIVATE,&mut recog.err_handler)?;

					}
				}

			 ABSTRACT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(1470);
					recog.base.match_token(ABSTRACT,&mut recog.err_handler)?;

					}
				}

			 DEFAULT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1471);
					recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

					}
				}

			 STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(1472);
					recog.base.match_token(STATIC,&mut recog.err_handler)?;

					}
				}

			 STRICTFP 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(1473);
					recog.base.match_token(STRICTFP,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationTypeDeclaration ----------------
pub type AnnotationTypeDeclarationContextAll<'input> = AnnotationTypeDeclarationContext<'input>;


pub type AnnotationTypeDeclarationContext<'input> = BaseParserRuleContext<'input,AnnotationTypeDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationTypeDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AnnotationTypeDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AnnotationTypeDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationTypeDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_annotationTypeDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationTypeDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationTypeDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationTypeDeclaration }
}
antlr_rust::tid!{AnnotationTypeDeclarationContextExt<'a>}

impl<'input> AnnotationTypeDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationTypeDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationTypeDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationTypeDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AnnotationTypeDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AT
/// Returns `None` if there is no child corresponding to token AT
fn AT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(AT, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERFACE
/// Returns `None` if there is no child corresponding to token INTERFACE
fn INTERFACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(INTERFACE, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotationTypeBody(&self) -> Option<Rc<AnnotationTypeBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceModifier_all(&self) ->  Vec<Rc<InterfaceModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn interfaceModifier(&self, i: usize) -> Option<Rc<InterfaceModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AnnotationTypeDeclarationContextAttrs<'input> for AnnotationTypeDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationTypeDeclaration(&mut self,)
	-> Result<Rc<AnnotationTypeDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationTypeDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_annotationTypeDeclaration);
        let mut _localctx: Rc<AnnotationTypeDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1479);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(147,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule interfaceModifier*/
					recog.base.set_state(1476);
					recog.interfaceModifier()?;

					}
					} 
				}
				recog.base.set_state(1481);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(147,&mut recog.base)?;
			}
			recog.base.set_state(1482);
			recog.base.match_token(AT,&mut recog.err_handler)?;

			recog.base.set_state(1483);
			recog.base.match_token(INTERFACE,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(1484);
			recog.identifier()?;

			/*InvokeRule annotationTypeBody*/
			recog.base.set_state(1485);
			recog.annotationTypeBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationTypeBody ----------------
pub type AnnotationTypeBodyContextAll<'input> = AnnotationTypeBodyContext<'input>;


pub type AnnotationTypeBodyContext<'input> = BaseParserRuleContext<'input,AnnotationTypeBodyContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationTypeBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AnnotationTypeBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AnnotationTypeBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationTypeBody(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_annotationTypeBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationTypeBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationTypeBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationTypeBody }
}
antlr_rust::tid!{AnnotationTypeBodyContextExt<'a>}

impl<'input> AnnotationTypeBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationTypeBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationTypeBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationTypeBodyContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AnnotationTypeBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn annotationTypeMemberDeclaration_all(&self) ->  Vec<Rc<AnnotationTypeMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotationTypeMemberDeclaration(&self, i: usize) -> Option<Rc<AnnotationTypeMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AnnotationTypeBodyContextAttrs<'input> for AnnotationTypeBodyContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationTypeBody(&mut self,)
	-> Result<Rc<AnnotationTypeBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationTypeBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_annotationTypeBody);
        let mut _localctx: Rc<AnnotationTypeBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1487);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1491);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABSTRACT) | (1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << DOUBLE) | (1usize << ENUM) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << INT) | (1usize << INTERFACE) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 34)) & !0x3f) == 0 && ((1usize << (_la - 34)) & ((1usize << (OPEN - 34)) | (1usize << (OPERNS - 34)) | (1usize << (PRIVATE - 34)) | (1usize << (PROTECTED - 34)) | (1usize << (PROVIDES - 34)) | (1usize << (PUBLIC - 34)) | (1usize << (REQUIRES - 34)) | (1usize << (SHORT - 34)) | (1usize << (STATIC - 34)) | (1usize << (STRICTFP - 34)) | (1usize << (TO - 34)) | (1usize << (USES - 34)) | (1usize << (WITH - 34)))) != 0) || _la==SEMI || _la==AT || _la==Identifier {
				{
				{
				/*InvokeRule annotationTypeMemberDeclaration*/
				recog.base.set_state(1488);
				recog.annotationTypeMemberDeclaration()?;

				}
				}
				recog.base.set_state(1493);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1494);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationTypeMemberDeclaration ----------------
pub type AnnotationTypeMemberDeclarationContextAll<'input> = AnnotationTypeMemberDeclarationContext<'input>;


pub type AnnotationTypeMemberDeclarationContext<'input> = BaseParserRuleContext<'input,AnnotationTypeMemberDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationTypeMemberDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AnnotationTypeMemberDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AnnotationTypeMemberDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationTypeMemberDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_annotationTypeMemberDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationTypeMemberDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationTypeMemberDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationTypeMemberDeclaration }
}
antlr_rust::tid!{AnnotationTypeMemberDeclarationContextExt<'a>}

impl<'input> AnnotationTypeMemberDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationTypeMemberDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationTypeMemberDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationTypeMemberDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AnnotationTypeMemberDeclarationContextExt<'input>>{

fn annotationTypeElementDeclaration(&self) -> Option<Rc<AnnotationTypeElementDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constantDeclaration(&self) -> Option<Rc<ConstantDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn interfaceDeclaration(&self) -> Option<Rc<InterfaceDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> AnnotationTypeMemberDeclarationContextAttrs<'input> for AnnotationTypeMemberDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationTypeMemberDeclaration(&mut self,)
	-> Result<Rc<AnnotationTypeMemberDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationTypeMemberDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_annotationTypeMemberDeclaration);
        let mut _localctx: Rc<AnnotationTypeMemberDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1501);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(149,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotationTypeElementDeclaration*/
					recog.base.set_state(1496);
					recog.annotationTypeElementDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule constantDeclaration*/
					recog.base.set_state(1497);
					recog.constantDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(1498);
					recog.classDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule interfaceDeclaration*/
					recog.base.set_state(1499);
					recog.interfaceDeclaration()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1500);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationTypeElementDeclaration ----------------
pub type AnnotationTypeElementDeclarationContextAll<'input> = AnnotationTypeElementDeclarationContext<'input>;


pub type AnnotationTypeElementDeclarationContext<'input> = BaseParserRuleContext<'input,AnnotationTypeElementDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationTypeElementDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AnnotationTypeElementDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AnnotationTypeElementDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationTypeElementDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_annotationTypeElementDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationTypeElementDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationTypeElementDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationTypeElementDeclaration }
}
antlr_rust::tid!{AnnotationTypeElementDeclarationContextExt<'a>}

impl<'input> AnnotationTypeElementDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationTypeElementDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationTypeElementDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationTypeElementDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AnnotationTypeElementDeclarationContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn annotationTypeElementModifier_all(&self) ->  Vec<Rc<AnnotationTypeElementModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotationTypeElementModifier(&self, i: usize) -> Option<Rc<AnnotationTypeElementModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn defaultValue(&self) -> Option<Rc<DefaultValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AnnotationTypeElementDeclarationContextAttrs<'input> for AnnotationTypeElementDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationTypeElementDeclaration(&mut self,)
	-> Result<Rc<AnnotationTypeElementDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationTypeElementDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_annotationTypeElementDeclaration);
        let mut _localctx: Rc<AnnotationTypeElementDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1506);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==ABSTRACT || _la==PUBLIC || _la==AT {
				{
				{
				/*InvokeRule annotationTypeElementModifier*/
				recog.base.set_state(1503);
				recog.annotationTypeElementModifier()?;

				}
				}
				recog.base.set_state(1508);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1509);
			recog.unannType()?;

			/*InvokeRule identifier*/
			recog.base.set_state(1510);
			recog.identifier()?;

			recog.base.set_state(1511);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1512);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1514);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LBRACK || _la==AT {
				{
				/*InvokeRule dims*/
				recog.base.set_state(1513);
				recog.dims()?;

				}
			}

			recog.base.set_state(1517);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==DEFAULT {
				{
				/*InvokeRule defaultValue*/
				recog.base.set_state(1516);
				recog.defaultValue()?;

				}
			}

			recog.base.set_state(1519);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationTypeElementModifier ----------------
pub type AnnotationTypeElementModifierContextAll<'input> = AnnotationTypeElementModifierContext<'input>;


pub type AnnotationTypeElementModifierContext<'input> = BaseParserRuleContext<'input,AnnotationTypeElementModifierContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationTypeElementModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AnnotationTypeElementModifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AnnotationTypeElementModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationTypeElementModifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_annotationTypeElementModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationTypeElementModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationTypeElementModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationTypeElementModifier }
}
antlr_rust::tid!{AnnotationTypeElementModifierContextExt<'a>}

impl<'input> AnnotationTypeElementModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationTypeElementModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationTypeElementModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationTypeElementModifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AnnotationTypeElementModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}

}

impl<'input> AnnotationTypeElementModifierContextAttrs<'input> for AnnotationTypeElementModifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationTypeElementModifier(&mut self,)
	-> Result<Rc<AnnotationTypeElementModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationTypeElementModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_annotationTypeElementModifier);
        let mut _localctx: Rc<AnnotationTypeElementModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1524);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1521);
					recog.annotation()?;

					}
				}

			 PUBLIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1522);
					recog.base.match_token(PUBLIC,&mut recog.err_handler)?;

					}
				}

			 ABSTRACT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1523);
					recog.base.match_token(ABSTRACT,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- defaultValue ----------------
pub type DefaultValueContextAll<'input> = DefaultValueContext<'input>;


pub type DefaultValueContext<'input> = BaseParserRuleContext<'input,DefaultValueContextExt<'input>>;

#[derive(Clone)]
pub struct DefaultValueContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for DefaultValueContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for DefaultValueContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_defaultValue(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_defaultValue(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DefaultValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_defaultValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_defaultValue }
}
antlr_rust::tid!{DefaultValueContextExt<'a>}

impl<'input> DefaultValueContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DefaultValueContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DefaultValueContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DefaultValueContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<DefaultValueContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}
fn elementValue(&self) -> Option<Rc<ElementValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DefaultValueContextAttrs<'input> for DefaultValueContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn defaultValue(&mut self,)
	-> Result<Rc<DefaultValueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DefaultValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_defaultValue);
        let mut _localctx: Rc<DefaultValueContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1526);
			recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

			/*InvokeRule elementValue*/
			recog.base.set_state(1527);
			recog.elementValue()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotation ----------------
pub type AnnotationContextAll<'input> = AnnotationContext<'input>;


pub type AnnotationContext<'input> = BaseParserRuleContext<'input,AnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotation(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_annotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotation }
}
antlr_rust::tid!{AnnotationContextExt<'a>}

impl<'input> AnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AnnotationContextExt<'input>>{

fn normalAnnotation(&self) -> Option<Rc<NormalAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn markerAnnotation(&self) -> Option<Rc<MarkerAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn singleElementAnnotation(&self) -> Option<Rc<SingleElementAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AnnotationContextAttrs<'input> for AnnotationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotation(&mut self,)
	-> Result<Rc<AnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 240, RULE_annotation);
        let mut _localctx: Rc<AnnotationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1532);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(154,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule normalAnnotation*/
					recog.base.set_state(1529);
					recog.normalAnnotation()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule markerAnnotation*/
					recog.base.set_state(1530);
					recog.markerAnnotation()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule singleElementAnnotation*/
					recog.base.set_state(1531);
					recog.singleElementAnnotation()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- normalAnnotation ----------------
pub type NormalAnnotationContextAll<'input> = NormalAnnotationContext<'input>;


pub type NormalAnnotationContext<'input> = BaseParserRuleContext<'input,NormalAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct NormalAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for NormalAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for NormalAnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_normalAnnotation(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_normalAnnotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NormalAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_normalAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_normalAnnotation }
}
antlr_rust::tid!{NormalAnnotationContextExt<'a>}

impl<'input> NormalAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NormalAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NormalAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NormalAnnotationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<NormalAnnotationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AT
/// Returns `None` if there is no child corresponding to token AT
fn AT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(AT, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn elementValuePairList(&self) -> Option<Rc<ElementValuePairListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NormalAnnotationContextAttrs<'input> for NormalAnnotationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn normalAnnotation(&mut self,)
	-> Result<Rc<NormalAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NormalAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 242, RULE_normalAnnotation);
        let mut _localctx: Rc<NormalAnnotationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1534);
			recog.base.match_token(AT,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(1535);
			recog.typeName()?;

			recog.base.set_state(1536);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1538);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXPORTS || _la==MODULE || ((((_la - 34)) & !0x3f) == 0 && ((1usize << (_la - 34)) & ((1usize << (OPEN - 34)) | (1usize << (OPERNS - 34)) | (1usize << (PROVIDES - 34)) | (1usize << (REQUIRES - 34)) | (1usize << (TO - 34)) | (1usize << (USES - 34)) | (1usize << (WITH - 34)))) != 0) || _la==Identifier {
				{
				/*InvokeRule elementValuePairList*/
				recog.base.set_state(1537);
				recog.elementValuePairList()?;

				}
			}

			recog.base.set_state(1540);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elementValuePairList ----------------
pub type ElementValuePairListContextAll<'input> = ElementValuePairListContext<'input>;


pub type ElementValuePairListContext<'input> = BaseParserRuleContext<'input,ElementValuePairListContextExt<'input>>;

#[derive(Clone)]
pub struct ElementValuePairListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ElementValuePairListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ElementValuePairListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elementValuePairList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_elementValuePairList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ElementValuePairListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elementValuePairList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elementValuePairList }
}
antlr_rust::tid!{ElementValuePairListContextExt<'a>}

impl<'input> ElementValuePairListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElementValuePairListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElementValuePairListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElementValuePairListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ElementValuePairListContextExt<'input>>{

fn elementValuePair_all(&self) ->  Vec<Rc<ElementValuePairContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn elementValuePair(&self, i: usize) -> Option<Rc<ElementValuePairContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ElementValuePairListContextAttrs<'input> for ElementValuePairListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elementValuePairList(&mut self,)
	-> Result<Rc<ElementValuePairListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElementValuePairListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 244, RULE_elementValuePairList);
        let mut _localctx: Rc<ElementValuePairListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule elementValuePair*/
			recog.base.set_state(1542);
			recog.elementValuePair()?;

			recog.base.set_state(1547);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(1543);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule elementValuePair*/
				recog.base.set_state(1544);
				recog.elementValuePair()?;

				}
				}
				recog.base.set_state(1549);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elementValuePair ----------------
pub type ElementValuePairContextAll<'input> = ElementValuePairContext<'input>;


pub type ElementValuePairContext<'input> = BaseParserRuleContext<'input,ElementValuePairContextExt<'input>>;

#[derive(Clone)]
pub struct ElementValuePairContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ElementValuePairContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ElementValuePairContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elementValuePair(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_elementValuePair(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ElementValuePairContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elementValuePair }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elementValuePair }
}
antlr_rust::tid!{ElementValuePairContextExt<'a>}

impl<'input> ElementValuePairContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElementValuePairContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElementValuePairContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElementValuePairContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ElementValuePairContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGN
/// Returns `None` if there is no child corresponding to token ASSIGN
fn ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ASSIGN, 0)
}
fn elementValue(&self) -> Option<Rc<ElementValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ElementValuePairContextAttrs<'input> for ElementValuePairContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elementValuePair(&mut self,)
	-> Result<Rc<ElementValuePairContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElementValuePairContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 246, RULE_elementValuePair);
        let mut _localctx: Rc<ElementValuePairContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1550);
			recog.identifier()?;

			recog.base.set_state(1551);
			recog.base.match_token(ASSIGN,&mut recog.err_handler)?;

			/*InvokeRule elementValue*/
			recog.base.set_state(1552);
			recog.elementValue()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elementValue ----------------
pub type ElementValueContextAll<'input> = ElementValueContext<'input>;


pub type ElementValueContext<'input> = BaseParserRuleContext<'input,ElementValueContextExt<'input>>;

#[derive(Clone)]
pub struct ElementValueContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ElementValueContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ElementValueContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elementValue(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_elementValue(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ElementValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elementValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elementValue }
}
antlr_rust::tid!{ElementValueContextExt<'a>}

impl<'input> ElementValueContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElementValueContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElementValueContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElementValueContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ElementValueContextExt<'input>>{

fn conditionalExpression(&self) -> Option<Rc<ConditionalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn elementValueArrayInitializer(&self) -> Option<Rc<ElementValueArrayInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ElementValueContextAttrs<'input> for ElementValueContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elementValue(&mut self,)
	-> Result<Rc<ElementValueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElementValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 248, RULE_elementValue);
        let mut _localctx: Rc<ElementValueContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1557);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(157,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule conditionalExpression*/
					recog.base.set_state(1554);
					recog.conditionalExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule elementValueArrayInitializer*/
					recog.base.set_state(1555);
					recog.elementValueArrayInitializer()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1556);
					recog.annotation()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elementValueArrayInitializer ----------------
pub type ElementValueArrayInitializerContextAll<'input> = ElementValueArrayInitializerContext<'input>;


pub type ElementValueArrayInitializerContext<'input> = BaseParserRuleContext<'input,ElementValueArrayInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct ElementValueArrayInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ElementValueArrayInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ElementValueArrayInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elementValueArrayInitializer(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_elementValueArrayInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ElementValueArrayInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elementValueArrayInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elementValueArrayInitializer }
}
antlr_rust::tid!{ElementValueArrayInitializerContextExt<'a>}

impl<'input> ElementValueArrayInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElementValueArrayInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElementValueArrayInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElementValueArrayInitializerContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ElementValueArrayInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn elementValueList(&self) -> Option<Rc<ElementValueListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}

}

impl<'input> ElementValueArrayInitializerContextAttrs<'input> for ElementValueArrayInitializerContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elementValueArrayInitializer(&mut self,)
	-> Result<Rc<ElementValueArrayInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElementValueArrayInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 250, RULE_elementValueArrayInitializer);
        let mut _localctx: Rc<ElementValueArrayInitializerContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1559);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1561);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (LBRACE - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
				{
				/*InvokeRule elementValueList*/
				recog.base.set_state(1560);
				recog.elementValueList()?;

				}
			}

			recog.base.set_state(1564);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(1563);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1566);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elementValueList ----------------
pub type ElementValueListContextAll<'input> = ElementValueListContext<'input>;


pub type ElementValueListContext<'input> = BaseParserRuleContext<'input,ElementValueListContextExt<'input>>;

#[derive(Clone)]
pub struct ElementValueListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ElementValueListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ElementValueListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elementValueList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_elementValueList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ElementValueListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elementValueList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elementValueList }
}
antlr_rust::tid!{ElementValueListContextExt<'a>}

impl<'input> ElementValueListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElementValueListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElementValueListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElementValueListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ElementValueListContextExt<'input>>{

fn elementValue_all(&self) ->  Vec<Rc<ElementValueContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn elementValue(&self, i: usize) -> Option<Rc<ElementValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ElementValueListContextAttrs<'input> for ElementValueListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elementValueList(&mut self,)
	-> Result<Rc<ElementValueListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElementValueListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 252, RULE_elementValueList);
        let mut _localctx: Rc<ElementValueListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule elementValue*/
			recog.base.set_state(1568);
			recog.elementValue()?;

			recog.base.set_state(1573);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(160,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1569);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule elementValue*/
					recog.base.set_state(1570);
					recog.elementValue()?;

					}
					} 
				}
				recog.base.set_state(1575);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(160,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- markerAnnotation ----------------
pub type MarkerAnnotationContextAll<'input> = MarkerAnnotationContext<'input>;


pub type MarkerAnnotationContext<'input> = BaseParserRuleContext<'input,MarkerAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct MarkerAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MarkerAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MarkerAnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_markerAnnotation(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_markerAnnotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MarkerAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_markerAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_markerAnnotation }
}
antlr_rust::tid!{MarkerAnnotationContextExt<'a>}

impl<'input> MarkerAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MarkerAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MarkerAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MarkerAnnotationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MarkerAnnotationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AT
/// Returns `None` if there is no child corresponding to token AT
fn AT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(AT, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MarkerAnnotationContextAttrs<'input> for MarkerAnnotationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn markerAnnotation(&mut self,)
	-> Result<Rc<MarkerAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MarkerAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 254, RULE_markerAnnotation);
        let mut _localctx: Rc<MarkerAnnotationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1576);
			recog.base.match_token(AT,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(1577);
			recog.typeName()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- singleElementAnnotation ----------------
pub type SingleElementAnnotationContextAll<'input> = SingleElementAnnotationContext<'input>;


pub type SingleElementAnnotationContext<'input> = BaseParserRuleContext<'input,SingleElementAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct SingleElementAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SingleElementAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SingleElementAnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_singleElementAnnotation(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_singleElementAnnotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SingleElementAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_singleElementAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_singleElementAnnotation }
}
antlr_rust::tid!{SingleElementAnnotationContextExt<'a>}

impl<'input> SingleElementAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SingleElementAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SingleElementAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SingleElementAnnotationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SingleElementAnnotationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AT
/// Returns `None` if there is no child corresponding to token AT
fn AT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(AT, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn elementValue(&self) -> Option<Rc<ElementValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}

}

impl<'input> SingleElementAnnotationContextAttrs<'input> for SingleElementAnnotationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn singleElementAnnotation(&mut self,)
	-> Result<Rc<SingleElementAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SingleElementAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 256, RULE_singleElementAnnotation);
        let mut _localctx: Rc<SingleElementAnnotationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1579);
			recog.base.match_token(AT,&mut recog.err_handler)?;

			/*InvokeRule typeName*/
			recog.base.set_state(1580);
			recog.typeName()?;

			recog.base.set_state(1581);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule elementValue*/
			recog.base.set_state(1582);
			recog.elementValue()?;

			recog.base.set_state(1583);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayInitializer ----------------
pub type ArrayInitializerContextAll<'input> = ArrayInitializerContext<'input>;


pub type ArrayInitializerContext<'input> = BaseParserRuleContext<'input,ArrayInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ArrayInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ArrayInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayInitializer(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_arrayInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayInitializer }
}
antlr_rust::tid!{ArrayInitializerContextExt<'a>}

impl<'input> ArrayInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayInitializerContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ArrayInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn variableInitializerList(&self) -> Option<Rc<VariableInitializerListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}

}

impl<'input> ArrayInitializerContextAttrs<'input> for ArrayInitializerContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayInitializer(&mut self,)
	-> Result<Rc<ArrayInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 258, RULE_arrayInitializer);
        let mut _localctx: Rc<ArrayInitializerContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1585);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1587);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (LBRACE - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
				{
				/*InvokeRule variableInitializerList*/
				recog.base.set_state(1586);
				recog.variableInitializerList()?;

				}
			}

			recog.base.set_state(1590);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(1589);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1592);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableInitializerList ----------------
pub type VariableInitializerListContextAll<'input> = VariableInitializerListContext<'input>;


pub type VariableInitializerListContext<'input> = BaseParserRuleContext<'input,VariableInitializerListContextExt<'input>>;

#[derive(Clone)]
pub struct VariableInitializerListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for VariableInitializerListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for VariableInitializerListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableInitializerList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_variableInitializerList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for VariableInitializerListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableInitializerList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableInitializerList }
}
antlr_rust::tid!{VariableInitializerListContextExt<'a>}

impl<'input> VariableInitializerListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableInitializerListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableInitializerListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableInitializerListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<VariableInitializerListContextExt<'input>>{

fn variableInitializer_all(&self) ->  Vec<Rc<VariableInitializerContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableInitializer(&self, i: usize) -> Option<Rc<VariableInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> VariableInitializerListContextAttrs<'input> for VariableInitializerListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableInitializerList(&mut self,)
	-> Result<Rc<VariableInitializerListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableInitializerListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 260, RULE_variableInitializerList);
        let mut _localctx: Rc<VariableInitializerListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule variableInitializer*/
			recog.base.set_state(1594);
			recog.variableInitializer()?;

			recog.base.set_state(1599);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(163,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1595);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule variableInitializer*/
					recog.base.set_state(1596);
					recog.variableInitializer()?;

					}
					} 
				}
				recog.base.set_state(1601);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(163,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- block ----------------
pub type BlockContextAll<'input> = BlockContext<'input>;


pub type BlockContext<'input> = BaseParserRuleContext<'input,BlockContextExt<'input>>;

#[derive(Clone)]
pub struct BlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for BlockContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for BlockContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_block(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_block(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_block }
	//fn type_rule_index() -> usize where Self: Sized { RULE_block }
}
antlr_rust::tid!{BlockContextExt<'a>}

impl<'input> BlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BlockContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<BlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn blockStatements(&self) -> Option<Rc<BlockStatementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BlockContextAttrs<'input> for BlockContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn block(&mut self,)
	-> Result<Rc<BlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 262, RULE_block);
        let mut _localctx: Rc<BlockContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1602);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1604);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABSTRACT) | (1usize << ASSERT) | (1usize << BOOLEAN) | (1usize << BREAK) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << CONTINUE) | (1usize << DO) | (1usize << DOUBLE) | (1usize << ENUM) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << FOR) | (1usize << IF) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (RETURN - 33)) | (1usize << (SHORT - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)) | (1usize << (SUPER - 33)) | (1usize << (SWITCH - 33)) | (1usize << (SYNCHRONIZED - 33)) | (1usize << (THIS - 33)) | (1usize << (THROW - 33)) | (1usize << (TO - 33)) | (1usize << (TRY - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WHILE - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (LBRACE - 65)) | (1usize << (SEMI - 65)) | (1usize << (AT - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)))) != 0) || _la==Identifier {
				{
				/*InvokeRule blockStatements*/
				recog.base.set_state(1603);
				recog.blockStatements()?;

				}
			}

			recog.base.set_state(1606);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- blockStatements ----------------
pub type BlockStatementsContextAll<'input> = BlockStatementsContext<'input>;


pub type BlockStatementsContext<'input> = BaseParserRuleContext<'input,BlockStatementsContextExt<'input>>;

#[derive(Clone)]
pub struct BlockStatementsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for BlockStatementsContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for BlockStatementsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_blockStatements(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_blockStatements(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BlockStatementsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_blockStatements }
	//fn type_rule_index() -> usize where Self: Sized { RULE_blockStatements }
}
antlr_rust::tid!{BlockStatementsContextExt<'a>}

impl<'input> BlockStatementsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BlockStatementsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BlockStatementsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BlockStatementsContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<BlockStatementsContextExt<'input>>{

fn blockStatement_all(&self) ->  Vec<Rc<BlockStatementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn blockStatement(&self, i: usize) -> Option<Rc<BlockStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> BlockStatementsContextAttrs<'input> for BlockStatementsContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn blockStatements(&mut self,)
	-> Result<Rc<BlockStatementsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BlockStatementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 264, RULE_blockStatements);
        let mut _localctx: Rc<BlockStatementsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1609); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule blockStatement*/
				recog.base.set_state(1608);
				recog.blockStatement()?;

				}
				}
				recog.base.set_state(1611); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABSTRACT) | (1usize << ASSERT) | (1usize << BOOLEAN) | (1usize << BREAK) | (1usize << BYTE) | (1usize << CHAR) | (1usize << CLASS) | (1usize << CONTINUE) | (1usize << DO) | (1usize << DOUBLE) | (1usize << ENUM) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << FOR) | (1usize << IF) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PRIVATE - 33)) | (1usize << (PROTECTED - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (PUBLIC - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (RETURN - 33)) | (1usize << (SHORT - 33)) | (1usize << (STATIC - 33)) | (1usize << (STRICTFP - 33)) | (1usize << (SUPER - 33)) | (1usize << (SWITCH - 33)) | (1usize << (SYNCHRONIZED - 33)) | (1usize << (THIS - 33)) | (1usize << (THROW - 33)) | (1usize << (TO - 33)) | (1usize << (TRY - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WHILE - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (LBRACE - 65)) | (1usize << (SEMI - 65)) | (1usize << (AT - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)))) != 0) || _la==Identifier) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- blockStatement ----------------
pub type BlockStatementContextAll<'input> = BlockStatementContext<'input>;


pub type BlockStatementContext<'input> = BaseParserRuleContext<'input,BlockStatementContextExt<'input>>;

#[derive(Clone)]
pub struct BlockStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for BlockStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for BlockStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_blockStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_blockStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BlockStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_blockStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_blockStatement }
}
antlr_rust::tid!{BlockStatementContextExt<'a>}

impl<'input> BlockStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BlockStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BlockStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BlockStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<BlockStatementContextExt<'input>>{

fn localVariableDeclarationStatement(&self) -> Option<Rc<LocalVariableDeclarationStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BlockStatementContextAttrs<'input> for BlockStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn blockStatement(&mut self,)
	-> Result<Rc<BlockStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BlockStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 266, RULE_blockStatement);
        let mut _localctx: Rc<BlockStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1616);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(166,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule localVariableDeclarationStatement*/
					recog.base.set_state(1613);
					recog.localVariableDeclarationStatement()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(1614);
					recog.classDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule statement*/
					recog.base.set_state(1615);
					recog.statement()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localVariableDeclarationStatement ----------------
pub type LocalVariableDeclarationStatementContextAll<'input> = LocalVariableDeclarationStatementContext<'input>;


pub type LocalVariableDeclarationStatementContext<'input> = BaseParserRuleContext<'input,LocalVariableDeclarationStatementContextExt<'input>>;

#[derive(Clone)]
pub struct LocalVariableDeclarationStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for LocalVariableDeclarationStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for LocalVariableDeclarationStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localVariableDeclarationStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_localVariableDeclarationStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LocalVariableDeclarationStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localVariableDeclarationStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localVariableDeclarationStatement }
}
antlr_rust::tid!{LocalVariableDeclarationStatementContextExt<'a>}

impl<'input> LocalVariableDeclarationStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalVariableDeclarationStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalVariableDeclarationStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalVariableDeclarationStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<LocalVariableDeclarationStatementContextExt<'input>>{

fn localVariableDeclaration(&self) -> Option<Rc<LocalVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> LocalVariableDeclarationStatementContextAttrs<'input> for LocalVariableDeclarationStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localVariableDeclarationStatement(&mut self,)
	-> Result<Rc<LocalVariableDeclarationStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalVariableDeclarationStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 268, RULE_localVariableDeclarationStatement);
        let mut _localctx: Rc<LocalVariableDeclarationStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule localVariableDeclaration*/
			recog.base.set_state(1618);
			recog.localVariableDeclaration()?;

			recog.base.set_state(1619);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localVariableDeclaration ----------------
pub type LocalVariableDeclarationContextAll<'input> = LocalVariableDeclarationContext<'input>;


pub type LocalVariableDeclarationContext<'input> = BaseParserRuleContext<'input,LocalVariableDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct LocalVariableDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for LocalVariableDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for LocalVariableDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localVariableDeclaration(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_localVariableDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LocalVariableDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localVariableDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localVariableDeclaration }
}
antlr_rust::tid!{LocalVariableDeclarationContextExt<'a>}

impl<'input> LocalVariableDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalVariableDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalVariableDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalVariableDeclarationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<LocalVariableDeclarationContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorList(&self) -> Option<Rc<VariableDeclaratorListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> LocalVariableDeclarationContextAttrs<'input> for LocalVariableDeclarationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localVariableDeclaration(&mut self,)
	-> Result<Rc<LocalVariableDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalVariableDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 270, RULE_localVariableDeclaration);
        let mut _localctx: Rc<LocalVariableDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1624);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==FINAL || _la==AT {
				{
				{
				/*InvokeRule variableModifier*/
				recog.base.set_state(1621);
				recog.variableModifier()?;

				}
				}
				recog.base.set_state(1626);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1627);
			recog.unannType()?;

			/*InvokeRule variableDeclaratorList*/
			recog.base.set_state(1628);
			recog.variableDeclaratorList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statement ----------------
pub type StatementContextAll<'input> = StatementContext<'input>;


pub type StatementContext<'input> = BaseParserRuleContext<'input,StatementContextExt<'input>>;

#[derive(Clone)]
pub struct StatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for StatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for StatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_statement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}
antlr_rust::tid!{StatementContextExt<'a>}

impl<'input> StatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<StatementContextExt<'input>>{

fn statementWithoutTrailingSubstatement(&self) -> Option<Rc<StatementWithoutTrailingSubstatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn labeledStatement(&self) -> Option<Rc<LabeledStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifThenStatement(&self) -> Option<Rc<IfThenStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifThenElseStatement(&self) -> Option<Rc<IfThenElseStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whileStatement(&self) -> Option<Rc<WhileStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forStatement(&self) -> Option<Rc<ForStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StatementContextAttrs<'input> for StatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statement(&mut self,)
	-> Result<Rc<StatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 272, RULE_statement);
        let mut _localctx: Rc<StatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1636);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(168,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule statementWithoutTrailingSubstatement*/
					recog.base.set_state(1630);
					recog.statementWithoutTrailingSubstatement()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule labeledStatement*/
					recog.base.set_state(1631);
					recog.labeledStatement()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule ifThenStatement*/
					recog.base.set_state(1632);
					recog.ifThenStatement()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule ifThenElseStatement*/
					recog.base.set_state(1633);
					recog.ifThenElseStatement()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule whileStatement*/
					recog.base.set_state(1634);
					recog.whileStatement()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule forStatement*/
					recog.base.set_state(1635);
					recog.forStatement()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statementNoShortIf ----------------
pub type StatementNoShortIfContextAll<'input> = StatementNoShortIfContext<'input>;


pub type StatementNoShortIfContext<'input> = BaseParserRuleContext<'input,StatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct StatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for StatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for StatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statementNoShortIf(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_statementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statementNoShortIf }
}
antlr_rust::tid!{StatementNoShortIfContextExt<'a>}

impl<'input> StatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementNoShortIfContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<StatementNoShortIfContextExt<'input>>{

fn statementWithoutTrailingSubstatement(&self) -> Option<Rc<StatementWithoutTrailingSubstatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn labeledStatementNoShortIf(&self) -> Option<Rc<LabeledStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifThenElseStatementNoShortIf(&self) -> Option<Rc<IfThenElseStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whileStatementNoShortIf(&self) -> Option<Rc<WhileStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forStatementNoShortIf(&self) -> Option<Rc<ForStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StatementNoShortIfContextAttrs<'input> for StatementNoShortIfContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statementNoShortIf(&mut self,)
	-> Result<Rc<StatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 274, RULE_statementNoShortIf);
        let mut _localctx: Rc<StatementNoShortIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1643);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(169,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule statementWithoutTrailingSubstatement*/
					recog.base.set_state(1638);
					recog.statementWithoutTrailingSubstatement()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule labeledStatementNoShortIf*/
					recog.base.set_state(1639);
					recog.labeledStatementNoShortIf()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule ifThenElseStatementNoShortIf*/
					recog.base.set_state(1640);
					recog.ifThenElseStatementNoShortIf()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule whileStatementNoShortIf*/
					recog.base.set_state(1641);
					recog.whileStatementNoShortIf()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule forStatementNoShortIf*/
					recog.base.set_state(1642);
					recog.forStatementNoShortIf()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statementWithoutTrailingSubstatement ----------------
pub type StatementWithoutTrailingSubstatementContextAll<'input> = StatementWithoutTrailingSubstatementContext<'input>;


pub type StatementWithoutTrailingSubstatementContext<'input> = BaseParserRuleContext<'input,StatementWithoutTrailingSubstatementContextExt<'input>>;

#[derive(Clone)]
pub struct StatementWithoutTrailingSubstatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for StatementWithoutTrailingSubstatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for StatementWithoutTrailingSubstatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statementWithoutTrailingSubstatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_statementWithoutTrailingSubstatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StatementWithoutTrailingSubstatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statementWithoutTrailingSubstatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statementWithoutTrailingSubstatement }
}
antlr_rust::tid!{StatementWithoutTrailingSubstatementContextExt<'a>}

impl<'input> StatementWithoutTrailingSubstatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementWithoutTrailingSubstatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementWithoutTrailingSubstatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementWithoutTrailingSubstatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<StatementWithoutTrailingSubstatementContextExt<'input>>{

fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn emptyStatement_(&self) -> Option<Rc<EmptyStatement_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionStatement(&self) -> Option<Rc<ExpressionStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assertStatement(&self) -> Option<Rc<AssertStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn switchStatement(&self) -> Option<Rc<SwitchStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn doStatement(&self) -> Option<Rc<DoStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn breakStatement(&self) -> Option<Rc<BreakStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn continueStatement(&self) -> Option<Rc<ContinueStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn returnStatement(&self) -> Option<Rc<ReturnStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn synchronizedStatement(&self) -> Option<Rc<SynchronizedStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn throwStatement(&self) -> Option<Rc<ThrowStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tryStatement(&self) -> Option<Rc<TryStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StatementWithoutTrailingSubstatementContextAttrs<'input> for StatementWithoutTrailingSubstatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statementWithoutTrailingSubstatement(&mut self,)
	-> Result<Rc<StatementWithoutTrailingSubstatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementWithoutTrailingSubstatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 276, RULE_statementWithoutTrailingSubstatement);
        let mut _localctx: Rc<StatementWithoutTrailingSubstatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1657);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LBRACE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule block*/
					recog.base.set_state(1645);
					recog.block()?;

					}
				}

			 SEMI 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule emptyStatement_*/
					recog.base.set_state(1646);
					recog.emptyStatement_()?;

					}
				}

			 BOOLEAN | BYTE | CHAR | DOUBLE | EXPORTS | FLOAT | INT | LONG | MODULE |
			 NEW | OPEN | OPERNS | PROVIDES | REQUIRES | SHORT | SUPER | THIS | TO |
			 USES | VOID | WITH | IntegerLiteral | FloatingPointLiteral | BooleanLiteral |
			 CharacterLiteral | StringLiteral | NullLiteral | LPAREN | AT | INC |
			 DEC | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule expressionStatement*/
					recog.base.set_state(1647);
					recog.expressionStatement()?;

					}
				}

			 ASSERT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule assertStatement*/
					recog.base.set_state(1648);
					recog.assertStatement()?;

					}
				}

			 SWITCH 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule switchStatement*/
					recog.base.set_state(1649);
					recog.switchStatement()?;

					}
				}

			 DO 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule doStatement*/
					recog.base.set_state(1650);
					recog.doStatement()?;

					}
				}

			 BREAK 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule breakStatement*/
					recog.base.set_state(1651);
					recog.breakStatement()?;

					}
				}

			 CONTINUE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule continueStatement*/
					recog.base.set_state(1652);
					recog.continueStatement()?;

					}
				}

			 RETURN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule returnStatement*/
					recog.base.set_state(1653);
					recog.returnStatement()?;

					}
				}

			 SYNCHRONIZED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule synchronizedStatement*/
					recog.base.set_state(1654);
					recog.synchronizedStatement()?;

					}
				}

			 THROW 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule throwStatement*/
					recog.base.set_state(1655);
					recog.throwStatement()?;

					}
				}

			 TRY 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule tryStatement*/
					recog.base.set_state(1656);
					recog.tryStatement()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- emptyStatement_ ----------------
pub type EmptyStatement_ContextAll<'input> = EmptyStatement_Context<'input>;


pub type EmptyStatement_Context<'input> = BaseParserRuleContext<'input,EmptyStatement_ContextExt<'input>>;

#[derive(Clone)]
pub struct EmptyStatement_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for EmptyStatement_Context<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for EmptyStatement_Context<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_emptyStatement_(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_emptyStatement_(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EmptyStatement_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_emptyStatement_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_emptyStatement_ }
}
antlr_rust::tid!{EmptyStatement_ContextExt<'a>}

impl<'input> EmptyStatement_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EmptyStatement_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EmptyStatement_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EmptyStatement_ContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<EmptyStatement_ContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> EmptyStatement_ContextAttrs<'input> for EmptyStatement_Context<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn emptyStatement_(&mut self,)
	-> Result<Rc<EmptyStatement_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EmptyStatement_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 278, RULE_emptyStatement_);
        let mut _localctx: Rc<EmptyStatement_ContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1659);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- labeledStatement ----------------
pub type LabeledStatementContextAll<'input> = LabeledStatementContext<'input>;


pub type LabeledStatementContext<'input> = BaseParserRuleContext<'input,LabeledStatementContextExt<'input>>;

#[derive(Clone)]
pub struct LabeledStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for LabeledStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for LabeledStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_labeledStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_labeledStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LabeledStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_labeledStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_labeledStatement }
}
antlr_rust::tid!{LabeledStatementContextExt<'a>}

impl<'input> LabeledStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LabeledStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LabeledStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LabeledStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<LabeledStatementContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LabeledStatementContextAttrs<'input> for LabeledStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn labeledStatement(&mut self,)
	-> Result<Rc<LabeledStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LabeledStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 280, RULE_labeledStatement);
        let mut _localctx: Rc<LabeledStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1661);
			recog.identifier()?;

			recog.base.set_state(1662);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1663);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- labeledStatementNoShortIf ----------------
pub type LabeledStatementNoShortIfContextAll<'input> = LabeledStatementNoShortIfContext<'input>;


pub type LabeledStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,LabeledStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct LabeledStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for LabeledStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for LabeledStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_labeledStatementNoShortIf(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_labeledStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LabeledStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_labeledStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_labeledStatementNoShortIf }
}
antlr_rust::tid!{LabeledStatementNoShortIfContextExt<'a>}

impl<'input> LabeledStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LabeledStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LabeledStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LabeledStatementNoShortIfContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<LabeledStatementNoShortIfContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn statementNoShortIf(&self) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LabeledStatementNoShortIfContextAttrs<'input> for LabeledStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn labeledStatementNoShortIf(&mut self,)
	-> Result<Rc<LabeledStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LabeledStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 282, RULE_labeledStatementNoShortIf);
        let mut _localctx: Rc<LabeledStatementNoShortIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1665);
			recog.identifier()?;

			recog.base.set_state(1666);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1667);
			recog.statementNoShortIf()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expressionStatement ----------------
pub type ExpressionStatementContextAll<'input> = ExpressionStatementContext<'input>;


pub type ExpressionStatementContext<'input> = BaseParserRuleContext<'input,ExpressionStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ExpressionStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ExpressionStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_expressionStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_expressionStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExpressionStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expressionStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expressionStatement }
}
antlr_rust::tid!{ExpressionStatementContextExt<'a>}

impl<'input> ExpressionStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ExpressionStatementContextExt<'input>>{

fn statementExpression(&self) -> Option<Rc<StatementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> ExpressionStatementContextAttrs<'input> for ExpressionStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expressionStatement(&mut self,)
	-> Result<Rc<ExpressionStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 284, RULE_expressionStatement);
        let mut _localctx: Rc<ExpressionStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule statementExpression*/
			recog.base.set_state(1669);
			recog.statementExpression()?;

			recog.base.set_state(1670);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statementExpression ----------------
pub type StatementExpressionContextAll<'input> = StatementExpressionContext<'input>;


pub type StatementExpressionContext<'input> = BaseParserRuleContext<'input,StatementExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct StatementExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for StatementExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for StatementExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statementExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_statementExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StatementExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statementExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statementExpression }
}
antlr_rust::tid!{StatementExpressionContextExt<'a>}

impl<'input> StatementExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<StatementExpressionContextExt<'input>>{

fn assignment(&self) -> Option<Rc<AssignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn preIncrementExpression(&self) -> Option<Rc<PreIncrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn preDecrementExpression(&self) -> Option<Rc<PreDecrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn postIncrementExpression(&self) -> Option<Rc<PostIncrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn postDecrementExpression(&self) -> Option<Rc<PostDecrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodInvocation(&self) -> Option<Rc<MethodInvocationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classInstanceCreationExpression(&self) -> Option<Rc<ClassInstanceCreationExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StatementExpressionContextAttrs<'input> for StatementExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statementExpression(&mut self,)
	-> Result<Rc<StatementExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 286, RULE_statementExpression);
        let mut _localctx: Rc<StatementExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1679);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(171,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule assignment*/
					recog.base.set_state(1672);
					recog.assignment()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule preIncrementExpression*/
					recog.base.set_state(1673);
					recog.preIncrementExpression()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule preDecrementExpression*/
					recog.base.set_state(1674);
					recog.preDecrementExpression()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule postIncrementExpression*/
					recog.base.set_state(1675);
					recog.postIncrementExpression()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule postDecrementExpression*/
					recog.base.set_state(1676);
					recog.postDecrementExpression()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule methodInvocation*/
					recog.base.set_state(1677);
					recog.methodInvocation()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule classInstanceCreationExpression*/
					recog.base.set_state(1678);
					recog.classInstanceCreationExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifThenStatement ----------------
pub type IfThenStatementContextAll<'input> = IfThenStatementContext<'input>;


pub type IfThenStatementContext<'input> = BaseParserRuleContext<'input,IfThenStatementContextExt<'input>>;

#[derive(Clone)]
pub struct IfThenStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for IfThenStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for IfThenStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifThenStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_ifThenStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfThenStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifThenStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifThenStatement }
}
antlr_rust::tid!{IfThenStatementContextExt<'a>}

impl<'input> IfThenStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfThenStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfThenStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfThenStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<IfThenStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IF
/// Returns `None` if there is no child corresponding to token IF
fn IF(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(IF, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfThenStatementContextAttrs<'input> for IfThenStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifThenStatement(&mut self,)
	-> Result<Rc<IfThenStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfThenStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 288, RULE_ifThenStatement);
        let mut _localctx: Rc<IfThenStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1681);
			recog.base.match_token(IF,&mut recog.err_handler)?;

			recog.base.set_state(1682);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1683);
			recog.expression()?;

			recog.base.set_state(1684);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1685);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifThenElseStatement ----------------
pub type IfThenElseStatementContextAll<'input> = IfThenElseStatementContext<'input>;


pub type IfThenElseStatementContext<'input> = BaseParserRuleContext<'input,IfThenElseStatementContextExt<'input>>;

#[derive(Clone)]
pub struct IfThenElseStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for IfThenElseStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for IfThenElseStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifThenElseStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_ifThenElseStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfThenElseStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifThenElseStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifThenElseStatement }
}
antlr_rust::tid!{IfThenElseStatementContextExt<'a>}

impl<'input> IfThenElseStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfThenElseStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfThenElseStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfThenElseStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<IfThenElseStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IF
/// Returns `None` if there is no child corresponding to token IF
fn IF(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(IF, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statementNoShortIf(&self) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ELSE
/// Returns `None` if there is no child corresponding to token ELSE
fn ELSE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ELSE, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfThenElseStatementContextAttrs<'input> for IfThenElseStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifThenElseStatement(&mut self,)
	-> Result<Rc<IfThenElseStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfThenElseStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 290, RULE_ifThenElseStatement);
        let mut _localctx: Rc<IfThenElseStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1687);
			recog.base.match_token(IF,&mut recog.err_handler)?;

			recog.base.set_state(1688);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1689);
			recog.expression()?;

			recog.base.set_state(1690);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1691);
			recog.statementNoShortIf()?;

			recog.base.set_state(1692);
			recog.base.match_token(ELSE,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1693);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifThenElseStatementNoShortIf ----------------
pub type IfThenElseStatementNoShortIfContextAll<'input> = IfThenElseStatementNoShortIfContext<'input>;


pub type IfThenElseStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,IfThenElseStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct IfThenElseStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for IfThenElseStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for IfThenElseStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifThenElseStatementNoShortIf(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_ifThenElseStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfThenElseStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifThenElseStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifThenElseStatementNoShortIf }
}
antlr_rust::tid!{IfThenElseStatementNoShortIfContextExt<'a>}

impl<'input> IfThenElseStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfThenElseStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfThenElseStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfThenElseStatementNoShortIfContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<IfThenElseStatementNoShortIfContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IF
/// Returns `None` if there is no child corresponding to token IF
fn IF(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(IF, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statementNoShortIf_all(&self) ->  Vec<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statementNoShortIf(&self, i: usize) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token ELSE
/// Returns `None` if there is no child corresponding to token ELSE
fn ELSE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ELSE, 0)
}

}

impl<'input> IfThenElseStatementNoShortIfContextAttrs<'input> for IfThenElseStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifThenElseStatementNoShortIf(&mut self,)
	-> Result<Rc<IfThenElseStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfThenElseStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 292, RULE_ifThenElseStatementNoShortIf);
        let mut _localctx: Rc<IfThenElseStatementNoShortIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1695);
			recog.base.match_token(IF,&mut recog.err_handler)?;

			recog.base.set_state(1696);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1697);
			recog.expression()?;

			recog.base.set_state(1698);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1699);
			recog.statementNoShortIf()?;

			recog.base.set_state(1700);
			recog.base.match_token(ELSE,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1701);
			recog.statementNoShortIf()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assertStatement ----------------
pub type AssertStatementContextAll<'input> = AssertStatementContext<'input>;


pub type AssertStatementContext<'input> = BaseParserRuleContext<'input,AssertStatementContextExt<'input>>;

#[derive(Clone)]
pub struct AssertStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AssertStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AssertStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assertStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_assertStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AssertStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assertStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assertStatement }
}
antlr_rust::tid!{AssertStatementContextExt<'a>}

impl<'input> AssertStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssertStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssertStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssertStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AssertStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ASSERT
/// Returns `None` if there is no child corresponding to token ASSERT
fn ASSERT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ASSERT, 0)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}

}

impl<'input> AssertStatementContextAttrs<'input> for AssertStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assertStatement(&mut self,)
	-> Result<Rc<AssertStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssertStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 294, RULE_assertStatement);
        let mut _localctx: Rc<AssertStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1713);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(172,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1703);
					recog.base.match_token(ASSERT,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1704);
					recog.expression()?;

					recog.base.set_state(1705);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1707);
					recog.base.match_token(ASSERT,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1708);
					recog.expression()?;

					recog.base.set_state(1709);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1710);
					recog.expression()?;

					recog.base.set_state(1711);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- switchStatement ----------------
pub type SwitchStatementContextAll<'input> = SwitchStatementContext<'input>;


pub type SwitchStatementContext<'input> = BaseParserRuleContext<'input,SwitchStatementContextExt<'input>>;

#[derive(Clone)]
pub struct SwitchStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SwitchStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SwitchStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_switchStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_switchStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SwitchStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_switchStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_switchStatement }
}
antlr_rust::tid!{SwitchStatementContextExt<'a>}

impl<'input> SwitchStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SwitchStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SwitchStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SwitchStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SwitchStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SWITCH
/// Returns `None` if there is no child corresponding to token SWITCH
fn SWITCH(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SWITCH, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn switchBlock(&self) -> Option<Rc<SwitchBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SwitchStatementContextAttrs<'input> for SwitchStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn switchStatement(&mut self,)
	-> Result<Rc<SwitchStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SwitchStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 296, RULE_switchStatement);
        let mut _localctx: Rc<SwitchStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1715);
			recog.base.match_token(SWITCH,&mut recog.err_handler)?;

			recog.base.set_state(1716);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1717);
			recog.expression()?;

			recog.base.set_state(1718);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule switchBlock*/
			recog.base.set_state(1719);
			recog.switchBlock()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- switchBlock ----------------
pub type SwitchBlockContextAll<'input> = SwitchBlockContext<'input>;


pub type SwitchBlockContext<'input> = BaseParserRuleContext<'input,SwitchBlockContextExt<'input>>;

#[derive(Clone)]
pub struct SwitchBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SwitchBlockContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SwitchBlockContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_switchBlock(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_switchBlock(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SwitchBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_switchBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_switchBlock }
}
antlr_rust::tid!{SwitchBlockContextExt<'a>}

impl<'input> SwitchBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SwitchBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SwitchBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SwitchBlockContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SwitchBlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn switchBlockStatementGroup_all(&self) ->  Vec<Rc<SwitchBlockStatementGroupContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn switchBlockStatementGroup(&self, i: usize) -> Option<Rc<SwitchBlockStatementGroupContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn switchLabel_all(&self) ->  Vec<Rc<SwitchLabelContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn switchLabel(&self, i: usize) -> Option<Rc<SwitchLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> SwitchBlockContextAttrs<'input> for SwitchBlockContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn switchBlock(&mut self,)
	-> Result<Rc<SwitchBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SwitchBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 298, RULE_switchBlock);
        let mut _localctx: Rc<SwitchBlockContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1721);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(1725);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(173,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule switchBlockStatementGroup*/
					recog.base.set_state(1722);
					recog.switchBlockStatementGroup()?;

					}
					} 
				}
				recog.base.set_state(1727);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(173,&mut recog.base)?;
			}
			recog.base.set_state(1731);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==CASE || _la==DEFAULT {
				{
				{
				/*InvokeRule switchLabel*/
				recog.base.set_state(1728);
				recog.switchLabel()?;

				}
				}
				recog.base.set_state(1733);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1734);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- switchBlockStatementGroup ----------------
pub type SwitchBlockStatementGroupContextAll<'input> = SwitchBlockStatementGroupContext<'input>;


pub type SwitchBlockStatementGroupContext<'input> = BaseParserRuleContext<'input,SwitchBlockStatementGroupContextExt<'input>>;

#[derive(Clone)]
pub struct SwitchBlockStatementGroupContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SwitchBlockStatementGroupContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SwitchBlockStatementGroupContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_switchBlockStatementGroup(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_switchBlockStatementGroup(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SwitchBlockStatementGroupContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_switchBlockStatementGroup }
	//fn type_rule_index() -> usize where Self: Sized { RULE_switchBlockStatementGroup }
}
antlr_rust::tid!{SwitchBlockStatementGroupContextExt<'a>}

impl<'input> SwitchBlockStatementGroupContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SwitchBlockStatementGroupContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SwitchBlockStatementGroupContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SwitchBlockStatementGroupContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SwitchBlockStatementGroupContextExt<'input>>{

fn switchLabels(&self) -> Option<Rc<SwitchLabelsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn blockStatements(&self) -> Option<Rc<BlockStatementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SwitchBlockStatementGroupContextAttrs<'input> for SwitchBlockStatementGroupContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn switchBlockStatementGroup(&mut self,)
	-> Result<Rc<SwitchBlockStatementGroupContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SwitchBlockStatementGroupContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 300, RULE_switchBlockStatementGroup);
        let mut _localctx: Rc<SwitchBlockStatementGroupContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule switchLabels*/
			recog.base.set_state(1736);
			recog.switchLabels()?;

			/*InvokeRule blockStatements*/
			recog.base.set_state(1737);
			recog.blockStatements()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- switchLabels ----------------
pub type SwitchLabelsContextAll<'input> = SwitchLabelsContext<'input>;


pub type SwitchLabelsContext<'input> = BaseParserRuleContext<'input,SwitchLabelsContextExt<'input>>;

#[derive(Clone)]
pub struct SwitchLabelsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SwitchLabelsContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SwitchLabelsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_switchLabels(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_switchLabels(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SwitchLabelsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_switchLabels }
	//fn type_rule_index() -> usize where Self: Sized { RULE_switchLabels }
}
antlr_rust::tid!{SwitchLabelsContextExt<'a>}

impl<'input> SwitchLabelsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SwitchLabelsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SwitchLabelsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SwitchLabelsContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SwitchLabelsContextExt<'input>>{

fn switchLabel_all(&self) ->  Vec<Rc<SwitchLabelContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn switchLabel(&self, i: usize) -> Option<Rc<SwitchLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> SwitchLabelsContextAttrs<'input> for SwitchLabelsContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn switchLabels(&mut self,)
	-> Result<Rc<SwitchLabelsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SwitchLabelsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 302, RULE_switchLabels);
        let mut _localctx: Rc<SwitchLabelsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1740); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule switchLabel*/
				recog.base.set_state(1739);
				recog.switchLabel()?;

				}
				}
				recog.base.set_state(1742); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !(_la==CASE || _la==DEFAULT) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- switchLabel ----------------
pub type SwitchLabelContextAll<'input> = SwitchLabelContext<'input>;


pub type SwitchLabelContext<'input> = BaseParserRuleContext<'input,SwitchLabelContextExt<'input>>;

#[derive(Clone)]
pub struct SwitchLabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SwitchLabelContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SwitchLabelContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_switchLabel(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_switchLabel(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SwitchLabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_switchLabel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_switchLabel }
}
antlr_rust::tid!{SwitchLabelContextExt<'a>}

impl<'input> SwitchLabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SwitchLabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SwitchLabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SwitchLabelContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SwitchLabelContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CASE
/// Returns `None` if there is no child corresponding to token CASE
fn CASE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(CASE, 0)
}
fn constantExpression(&self) -> Option<Rc<ConstantExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn enumConstantName(&self) -> Option<Rc<EnumConstantNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}

}

impl<'input> SwitchLabelContextAttrs<'input> for SwitchLabelContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn switchLabel(&mut self,)
	-> Result<Rc<SwitchLabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SwitchLabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 304, RULE_switchLabel);
        let mut _localctx: Rc<SwitchLabelContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1754);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(176,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1744);
					recog.base.match_token(CASE,&mut recog.err_handler)?;

					/*InvokeRule constantExpression*/
					recog.base.set_state(1745);
					recog.constantExpression()?;

					recog.base.set_state(1746);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1748);
					recog.base.match_token(CASE,&mut recog.err_handler)?;

					/*InvokeRule enumConstantName*/
					recog.base.set_state(1749);
					recog.enumConstantName()?;

					recog.base.set_state(1750);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1752);
					recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

					recog.base.set_state(1753);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumConstantName ----------------
pub type EnumConstantNameContextAll<'input> = EnumConstantNameContext<'input>;


pub type EnumConstantNameContext<'input> = BaseParserRuleContext<'input,EnumConstantNameContextExt<'input>>;

#[derive(Clone)]
pub struct EnumConstantNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for EnumConstantNameContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for EnumConstantNameContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumConstantName(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_enumConstantName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnumConstantNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumConstantName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumConstantName }
}
antlr_rust::tid!{EnumConstantNameContextExt<'a>}

impl<'input> EnumConstantNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumConstantNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumConstantNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumConstantNameContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<EnumConstantNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumConstantNameContextAttrs<'input> for EnumConstantNameContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumConstantName(&mut self,)
	-> Result<Rc<EnumConstantNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumConstantNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 306, RULE_enumConstantName);
        let mut _localctx: Rc<EnumConstantNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(1756);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whileStatement ----------------
pub type WhileStatementContextAll<'input> = WhileStatementContext<'input>;


pub type WhileStatementContext<'input> = BaseParserRuleContext<'input,WhileStatementContextExt<'input>>;

#[derive(Clone)]
pub struct WhileStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for WhileStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for WhileStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_whileStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_whileStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for WhileStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whileStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whileStatement }
}
antlr_rust::tid!{WhileStatementContextExt<'a>}

impl<'input> WhileStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhileStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhileStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhileStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<WhileStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WHILE
/// Returns `None` if there is no child corresponding to token WHILE
fn WHILE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(WHILE, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WhileStatementContextAttrs<'input> for WhileStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whileStatement(&mut self,)
	-> Result<Rc<WhileStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhileStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 308, RULE_whileStatement);
        let mut _localctx: Rc<WhileStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1758);
			recog.base.match_token(WHILE,&mut recog.err_handler)?;

			recog.base.set_state(1759);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1760);
			recog.expression()?;

			recog.base.set_state(1761);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1762);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whileStatementNoShortIf ----------------
pub type WhileStatementNoShortIfContextAll<'input> = WhileStatementNoShortIfContext<'input>;


pub type WhileStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,WhileStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct WhileStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for WhileStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for WhileStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_whileStatementNoShortIf(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_whileStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for WhileStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whileStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whileStatementNoShortIf }
}
antlr_rust::tid!{WhileStatementNoShortIfContextExt<'a>}

impl<'input> WhileStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhileStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhileStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhileStatementNoShortIfContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<WhileStatementNoShortIfContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WHILE
/// Returns `None` if there is no child corresponding to token WHILE
fn WHILE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(WHILE, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statementNoShortIf(&self) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WhileStatementNoShortIfContextAttrs<'input> for WhileStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whileStatementNoShortIf(&mut self,)
	-> Result<Rc<WhileStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhileStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 310, RULE_whileStatementNoShortIf);
        let mut _localctx: Rc<WhileStatementNoShortIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1764);
			recog.base.match_token(WHILE,&mut recog.err_handler)?;

			recog.base.set_state(1765);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1766);
			recog.expression()?;

			recog.base.set_state(1767);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1768);
			recog.statementNoShortIf()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- doStatement ----------------
pub type DoStatementContextAll<'input> = DoStatementContext<'input>;


pub type DoStatementContext<'input> = BaseParserRuleContext<'input,DoStatementContextExt<'input>>;

#[derive(Clone)]
pub struct DoStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for DoStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for DoStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_doStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_doStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DoStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_doStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_doStatement }
}
antlr_rust::tid!{DoStatementContextExt<'a>}

impl<'input> DoStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DoStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DoStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DoStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<DoStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DO
/// Returns `None` if there is no child corresponding to token DO
fn DO(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DO, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token WHILE
/// Returns `None` if there is no child corresponding to token WHILE
fn WHILE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(WHILE, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> DoStatementContextAttrs<'input> for DoStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn doStatement(&mut self,)
	-> Result<Rc<DoStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DoStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 312, RULE_doStatement);
        let mut _localctx: Rc<DoStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1770);
			recog.base.match_token(DO,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1771);
			recog.statement()?;

			recog.base.set_state(1772);
			recog.base.match_token(WHILE,&mut recog.err_handler)?;

			recog.base.set_state(1773);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1774);
			recog.expression()?;

			recog.base.set_state(1775);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1776);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forStatement ----------------
pub type ForStatementContextAll<'input> = ForStatementContext<'input>;


pub type ForStatementContext<'input> = BaseParserRuleContext<'input,ForStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ForStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ForStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ForStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_forStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ForStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forStatement }
}
antlr_rust::tid!{ForStatementContextExt<'a>}

impl<'input> ForStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ForStatementContextExt<'input>>{

fn basicForStatement(&self) -> Option<Rc<BasicForStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enhancedForStatement(&self) -> Option<Rc<EnhancedForStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForStatementContextAttrs<'input> for ForStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forStatement(&mut self,)
	-> Result<Rc<ForStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 314, RULE_forStatement);
        let mut _localctx: Rc<ForStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1780);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(177,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule basicForStatement*/
					recog.base.set_state(1778);
					recog.basicForStatement()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule enhancedForStatement*/
					recog.base.set_state(1779);
					recog.enhancedForStatement()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forStatementNoShortIf ----------------
pub type ForStatementNoShortIfContextAll<'input> = ForStatementNoShortIfContext<'input>;


pub type ForStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,ForStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct ForStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ForStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ForStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forStatementNoShortIf(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_forStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ForStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forStatementNoShortIf }
}
antlr_rust::tid!{ForStatementNoShortIfContextExt<'a>}

impl<'input> ForStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForStatementNoShortIfContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ForStatementNoShortIfContextExt<'input>>{

fn basicForStatementNoShortIf(&self) -> Option<Rc<BasicForStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enhancedForStatementNoShortIf(&self) -> Option<Rc<EnhancedForStatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForStatementNoShortIfContextAttrs<'input> for ForStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forStatementNoShortIf(&mut self,)
	-> Result<Rc<ForStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 316, RULE_forStatementNoShortIf);
        let mut _localctx: Rc<ForStatementNoShortIfContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1784);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(178,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule basicForStatementNoShortIf*/
					recog.base.set_state(1782);
					recog.basicForStatementNoShortIf()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule enhancedForStatementNoShortIf*/
					recog.base.set_state(1783);
					recog.enhancedForStatementNoShortIf()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- basicForStatement ----------------
pub type BasicForStatementContextAll<'input> = BasicForStatementContext<'input>;


pub type BasicForStatementContext<'input> = BaseParserRuleContext<'input,BasicForStatementContextExt<'input>>;

#[derive(Clone)]
pub struct BasicForStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for BasicForStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for BasicForStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_basicForStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_basicForStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BasicForStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_basicForStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_basicForStatement }
}
antlr_rust::tid!{BasicForStatementContextExt<'a>}

impl<'input> BasicForStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BasicForStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BasicForStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BasicForStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<BasicForStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token SEMI in current rule
fn SEMI_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SEMI, starting from 0.
/// Returns `None` if number of children corresponding to token SEMI is less or equal than `i`.
fn SEMI(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, i)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forInit(&self) -> Option<Rc<ForInitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forUpdate(&self) -> Option<Rc<ForUpdateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BasicForStatementContextAttrs<'input> for BasicForStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn basicForStatement(&mut self,)
	-> Result<Rc<BasicForStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BasicForStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 318, RULE_basicForStatement);
        let mut _localctx: Rc<BasicForStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1786);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			recog.base.set_state(1787);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1789);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)))) != 0) || _la==Identifier {
				{
				/*InvokeRule forInit*/
				recog.base.set_state(1788);
				recog.forInit()?;

				}
			}

			recog.base.set_state(1791);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			recog.base.set_state(1793);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
				{
				/*InvokeRule expression*/
				recog.base.set_state(1792);
				recog.expression()?;

				}
			}

			recog.base.set_state(1795);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			recog.base.set_state(1797);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)))) != 0) || _la==Identifier {
				{
				/*InvokeRule forUpdate*/
				recog.base.set_state(1796);
				recog.forUpdate()?;

				}
			}

			recog.base.set_state(1799);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1800);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- basicForStatementNoShortIf ----------------
pub type BasicForStatementNoShortIfContextAll<'input> = BasicForStatementNoShortIfContext<'input>;


pub type BasicForStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,BasicForStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct BasicForStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for BasicForStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for BasicForStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_basicForStatementNoShortIf(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_basicForStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BasicForStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_basicForStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_basicForStatementNoShortIf }
}
antlr_rust::tid!{BasicForStatementNoShortIfContextExt<'a>}

impl<'input> BasicForStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BasicForStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BasicForStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BasicForStatementNoShortIfContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<BasicForStatementNoShortIfContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token SEMI in current rule
fn SEMI_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SEMI, starting from 0.
/// Returns `None` if number of children corresponding to token SEMI is less or equal than `i`.
fn SEMI(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, i)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statementNoShortIf(&self) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forInit(&self) -> Option<Rc<ForInitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn forUpdate(&self) -> Option<Rc<ForUpdateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BasicForStatementNoShortIfContextAttrs<'input> for BasicForStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn basicForStatementNoShortIf(&mut self,)
	-> Result<Rc<BasicForStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BasicForStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 320, RULE_basicForStatementNoShortIf);
        let mut _localctx: Rc<BasicForStatementNoShortIfContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1802);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			recog.base.set_state(1803);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1805);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)))) != 0) || _la==Identifier {
				{
				/*InvokeRule forInit*/
				recog.base.set_state(1804);
				recog.forInit()?;

				}
			}

			recog.base.set_state(1807);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			recog.base.set_state(1809);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
				{
				/*InvokeRule expression*/
				recog.base.set_state(1808);
				recog.expression()?;

				}
			}

			recog.base.set_state(1811);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			recog.base.set_state(1813);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)))) != 0) || _la==Identifier {
				{
				/*InvokeRule forUpdate*/
				recog.base.set_state(1812);
				recog.forUpdate()?;

				}
			}

			recog.base.set_state(1815);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1816);
			recog.statementNoShortIf()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forInit ----------------
pub type ForInitContextAll<'input> = ForInitContext<'input>;


pub type ForInitContext<'input> = BaseParserRuleContext<'input,ForInitContextExt<'input>>;

#[derive(Clone)]
pub struct ForInitContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ForInitContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ForInitContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forInit(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_forInit(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ForInitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forInit }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forInit }
}
antlr_rust::tid!{ForInitContextExt<'a>}

impl<'input> ForInitContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForInitContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForInitContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForInitContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ForInitContextExt<'input>>{

fn statementExpressionList(&self) -> Option<Rc<StatementExpressionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn localVariableDeclaration(&self) -> Option<Rc<LocalVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForInitContextAttrs<'input> for ForInitContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forInit(&mut self,)
	-> Result<Rc<ForInitContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForInitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 322, RULE_forInit);
        let mut _localctx: Rc<ForInitContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1820);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(185,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule statementExpressionList*/
					recog.base.set_state(1818);
					recog.statementExpressionList()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule localVariableDeclaration*/
					recog.base.set_state(1819);
					recog.localVariableDeclaration()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forUpdate ----------------
pub type ForUpdateContextAll<'input> = ForUpdateContext<'input>;


pub type ForUpdateContext<'input> = BaseParserRuleContext<'input,ForUpdateContextExt<'input>>;

#[derive(Clone)]
pub struct ForUpdateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ForUpdateContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ForUpdateContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forUpdate(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_forUpdate(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ForUpdateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forUpdate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forUpdate }
}
antlr_rust::tid!{ForUpdateContextExt<'a>}

impl<'input> ForUpdateContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForUpdateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForUpdateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForUpdateContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ForUpdateContextExt<'input>>{

fn statementExpressionList(&self) -> Option<Rc<StatementExpressionListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForUpdateContextAttrs<'input> for ForUpdateContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forUpdate(&mut self,)
	-> Result<Rc<ForUpdateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForUpdateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 324, RULE_forUpdate);
        let mut _localctx: Rc<ForUpdateContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule statementExpressionList*/
			recog.base.set_state(1822);
			recog.statementExpressionList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statementExpressionList ----------------
pub type StatementExpressionListContextAll<'input> = StatementExpressionListContext<'input>;


pub type StatementExpressionListContext<'input> = BaseParserRuleContext<'input,StatementExpressionListContextExt<'input>>;

#[derive(Clone)]
pub struct StatementExpressionListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for StatementExpressionListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for StatementExpressionListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statementExpressionList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_statementExpressionList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StatementExpressionListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statementExpressionList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statementExpressionList }
}
antlr_rust::tid!{StatementExpressionListContextExt<'a>}

impl<'input> StatementExpressionListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementExpressionListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementExpressionListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementExpressionListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<StatementExpressionListContextExt<'input>>{

fn statementExpression_all(&self) ->  Vec<Rc<StatementExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statementExpression(&self, i: usize) -> Option<Rc<StatementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> StatementExpressionListContextAttrs<'input> for StatementExpressionListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statementExpressionList(&mut self,)
	-> Result<Rc<StatementExpressionListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementExpressionListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 326, RULE_statementExpressionList);
        let mut _localctx: Rc<StatementExpressionListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule statementExpression*/
			recog.base.set_state(1824);
			recog.statementExpression()?;

			recog.base.set_state(1829);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(1825);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule statementExpression*/
				recog.base.set_state(1826);
				recog.statementExpression()?;

				}
				}
				recog.base.set_state(1831);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enhancedForStatement ----------------
pub type EnhancedForStatementContextAll<'input> = EnhancedForStatementContext<'input>;


pub type EnhancedForStatementContext<'input> = BaseParserRuleContext<'input,EnhancedForStatementContextExt<'input>>;

#[derive(Clone)]
pub struct EnhancedForStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for EnhancedForStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for EnhancedForStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enhancedForStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_enhancedForStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnhancedForStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enhancedForStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enhancedForStatement }
}
antlr_rust::tid!{EnhancedForStatementContextExt<'a>}

impl<'input> EnhancedForStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnhancedForStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnhancedForStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnhancedForStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<EnhancedForStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorId(&self) -> Option<Rc<VariableDeclaratorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> EnhancedForStatementContextAttrs<'input> for EnhancedForStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enhancedForStatement(&mut self,)
	-> Result<Rc<EnhancedForStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnhancedForStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 328, RULE_enhancedForStatement);
        let mut _localctx: Rc<EnhancedForStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1832);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			recog.base.set_state(1833);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1837);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==FINAL || _la==AT {
				{
				{
				/*InvokeRule variableModifier*/
				recog.base.set_state(1834);
				recog.variableModifier()?;

				}
				}
				recog.base.set_state(1839);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1840);
			recog.unannType()?;

			/*InvokeRule variableDeclaratorId*/
			recog.base.set_state(1841);
			recog.variableDeclaratorId()?;

			recog.base.set_state(1842);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1843);
			recog.expression()?;

			recog.base.set_state(1844);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statement*/
			recog.base.set_state(1845);
			recog.statement()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enhancedForStatementNoShortIf ----------------
pub type EnhancedForStatementNoShortIfContextAll<'input> = EnhancedForStatementNoShortIfContext<'input>;


pub type EnhancedForStatementNoShortIfContext<'input> = BaseParserRuleContext<'input,EnhancedForStatementNoShortIfContextExt<'input>>;

#[derive(Clone)]
pub struct EnhancedForStatementNoShortIfContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for EnhancedForStatementNoShortIfContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for EnhancedForStatementNoShortIfContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enhancedForStatementNoShortIf(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_enhancedForStatementNoShortIf(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EnhancedForStatementNoShortIfContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enhancedForStatementNoShortIf }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enhancedForStatementNoShortIf }
}
antlr_rust::tid!{EnhancedForStatementNoShortIfContextExt<'a>}

impl<'input> EnhancedForStatementNoShortIfContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnhancedForStatementNoShortIfContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnhancedForStatementNoShortIfContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnhancedForStatementNoShortIfContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<EnhancedForStatementNoShortIfContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorId(&self) -> Option<Rc<VariableDeclaratorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn statementNoShortIf(&self) -> Option<Rc<StatementNoShortIfContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> EnhancedForStatementNoShortIfContextAttrs<'input> for EnhancedForStatementNoShortIfContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enhancedForStatementNoShortIf(&mut self,)
	-> Result<Rc<EnhancedForStatementNoShortIfContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnhancedForStatementNoShortIfContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 330, RULE_enhancedForStatementNoShortIf);
        let mut _localctx: Rc<EnhancedForStatementNoShortIfContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1847);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			recog.base.set_state(1848);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1852);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==FINAL || _la==AT {
				{
				{
				/*InvokeRule variableModifier*/
				recog.base.set_state(1849);
				recog.variableModifier()?;

				}
				}
				recog.base.set_state(1854);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule unannType*/
			recog.base.set_state(1855);
			recog.unannType()?;

			/*InvokeRule variableDeclaratorId*/
			recog.base.set_state(1856);
			recog.variableDeclaratorId()?;

			recog.base.set_state(1857);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1858);
			recog.expression()?;

			recog.base.set_state(1859);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule statementNoShortIf*/
			recog.base.set_state(1860);
			recog.statementNoShortIf()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- breakStatement ----------------
pub type BreakStatementContextAll<'input> = BreakStatementContext<'input>;


pub type BreakStatementContext<'input> = BaseParserRuleContext<'input,BreakStatementContextExt<'input>>;

#[derive(Clone)]
pub struct BreakStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for BreakStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for BreakStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_breakStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_breakStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BreakStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_breakStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_breakStatement }
}
antlr_rust::tid!{BreakStatementContextExt<'a>}

impl<'input> BreakStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BreakStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BreakStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BreakStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<BreakStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BREAK
/// Returns `None` if there is no child corresponding to token BREAK
fn BREAK(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(BREAK, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BreakStatementContextAttrs<'input> for BreakStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn breakStatement(&mut self,)
	-> Result<Rc<BreakStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BreakStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 332, RULE_breakStatement);
        let mut _localctx: Rc<BreakStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1862);
			recog.base.match_token(BREAK,&mut recog.err_handler)?;

			recog.base.set_state(1864);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXPORTS || _la==MODULE || ((((_la - 34)) & !0x3f) == 0 && ((1usize << (_la - 34)) & ((1usize << (OPEN - 34)) | (1usize << (OPERNS - 34)) | (1usize << (PROVIDES - 34)) | (1usize << (REQUIRES - 34)) | (1usize << (TO - 34)) | (1usize << (USES - 34)) | (1usize << (WITH - 34)))) != 0) || _la==Identifier {
				{
				/*InvokeRule identifier*/
				recog.base.set_state(1863);
				recog.identifier()?;

				}
			}

			recog.base.set_state(1866);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- continueStatement ----------------
pub type ContinueStatementContextAll<'input> = ContinueStatementContext<'input>;


pub type ContinueStatementContext<'input> = BaseParserRuleContext<'input,ContinueStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ContinueStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ContinueStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ContinueStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_continueStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_continueStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ContinueStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_continueStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_continueStatement }
}
antlr_rust::tid!{ContinueStatementContextExt<'a>}

impl<'input> ContinueStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ContinueStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ContinueStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ContinueStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ContinueStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CONTINUE
/// Returns `None` if there is no child corresponding to token CONTINUE
fn CONTINUE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(CONTINUE, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ContinueStatementContextAttrs<'input> for ContinueStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn continueStatement(&mut self,)
	-> Result<Rc<ContinueStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ContinueStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 334, RULE_continueStatement);
        let mut _localctx: Rc<ContinueStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1868);
			recog.base.match_token(CONTINUE,&mut recog.err_handler)?;

			recog.base.set_state(1870);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXPORTS || _la==MODULE || ((((_la - 34)) & !0x3f) == 0 && ((1usize << (_la - 34)) & ((1usize << (OPEN - 34)) | (1usize << (OPERNS - 34)) | (1usize << (PROVIDES - 34)) | (1usize << (REQUIRES - 34)) | (1usize << (TO - 34)) | (1usize << (USES - 34)) | (1usize << (WITH - 34)))) != 0) || _la==Identifier {
				{
				/*InvokeRule identifier*/
				recog.base.set_state(1869);
				recog.identifier()?;

				}
			}

			recog.base.set_state(1872);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- returnStatement ----------------
pub type ReturnStatementContextAll<'input> = ReturnStatementContext<'input>;


pub type ReturnStatementContext<'input> = BaseParserRuleContext<'input,ReturnStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ReturnStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ReturnStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ReturnStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_returnStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_returnStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ReturnStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_returnStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_returnStatement }
}
antlr_rust::tid!{ReturnStatementContextExt<'a>}

impl<'input> ReturnStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReturnStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReturnStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReturnStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ReturnStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token RETURN
/// Returns `None` if there is no child corresponding to token RETURN
fn RETURN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RETURN, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReturnStatementContextAttrs<'input> for ReturnStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn returnStatement(&mut self,)
	-> Result<Rc<ReturnStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReturnStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 336, RULE_returnStatement);
        let mut _localctx: Rc<ReturnStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1874);
			recog.base.match_token(RETURN,&mut recog.err_handler)?;

			recog.base.set_state(1876);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
				{
				/*InvokeRule expression*/
				recog.base.set_state(1875);
				recog.expression()?;

				}
			}

			recog.base.set_state(1878);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- throwStatement ----------------
pub type ThrowStatementContextAll<'input> = ThrowStatementContext<'input>;


pub type ThrowStatementContext<'input> = BaseParserRuleContext<'input,ThrowStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ThrowStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ThrowStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ThrowStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_throwStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_throwStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ThrowStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_throwStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_throwStatement }
}
antlr_rust::tid!{ThrowStatementContextExt<'a>}

impl<'input> ThrowStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ThrowStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ThrowStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ThrowStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ThrowStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token THROW
/// Returns `None` if there is no child corresponding to token THROW
fn THROW(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(THROW, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> ThrowStatementContextAttrs<'input> for ThrowStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn throwStatement(&mut self,)
	-> Result<Rc<ThrowStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ThrowStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 338, RULE_throwStatement);
        let mut _localctx: Rc<ThrowStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1880);
			recog.base.match_token(THROW,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1881);
			recog.expression()?;

			recog.base.set_state(1882);
			recog.base.match_token(SEMI,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- synchronizedStatement ----------------
pub type SynchronizedStatementContextAll<'input> = SynchronizedStatementContext<'input>;


pub type SynchronizedStatementContext<'input> = BaseParserRuleContext<'input,SynchronizedStatementContextExt<'input>>;

#[derive(Clone)]
pub struct SynchronizedStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for SynchronizedStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for SynchronizedStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_synchronizedStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_synchronizedStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SynchronizedStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_synchronizedStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_synchronizedStatement }
}
antlr_rust::tid!{SynchronizedStatementContextExt<'a>}

impl<'input> SynchronizedStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SynchronizedStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SynchronizedStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SynchronizedStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<SynchronizedStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SYNCHRONIZED
/// Returns `None` if there is no child corresponding to token SYNCHRONIZED
fn SYNCHRONIZED(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SYNCHRONIZED, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SynchronizedStatementContextAttrs<'input> for SynchronizedStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn synchronizedStatement(&mut self,)
	-> Result<Rc<SynchronizedStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SynchronizedStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 340, RULE_synchronizedStatement);
        let mut _localctx: Rc<SynchronizedStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1884);
			recog.base.match_token(SYNCHRONIZED,&mut recog.err_handler)?;

			recog.base.set_state(1885);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1886);
			recog.expression()?;

			recog.base.set_state(1887);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule block*/
			recog.base.set_state(1888);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tryStatement ----------------
pub type TryStatementContextAll<'input> = TryStatementContext<'input>;


pub type TryStatementContext<'input> = BaseParserRuleContext<'input,TryStatementContextExt<'input>>;

#[derive(Clone)]
pub struct TryStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TryStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TryStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tryStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_tryStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TryStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tryStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tryStatement }
}
antlr_rust::tid!{TryStatementContextExt<'a>}

impl<'input> TryStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TryStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TryStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TryStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TryStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TRY
/// Returns `None` if there is no child corresponding to token TRY
fn TRY(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(TRY, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn catches(&self) -> Option<Rc<CatchesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn finally_(&self) -> Option<Rc<Finally_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tryWithResourcesStatement(&self) -> Option<Rc<TryWithResourcesStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TryStatementContextAttrs<'input> for TryStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tryStatement(&mut self,)
	-> Result<Rc<TryStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TryStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 342, RULE_tryStatement);
        let mut _localctx: Rc<TryStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1902);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(193,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1890);
					recog.base.match_token(TRY,&mut recog.err_handler)?;

					/*InvokeRule block*/
					recog.base.set_state(1891);
					recog.block()?;

					/*InvokeRule catches*/
					recog.base.set_state(1892);
					recog.catches()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1894);
					recog.base.match_token(TRY,&mut recog.err_handler)?;

					/*InvokeRule block*/
					recog.base.set_state(1895);
					recog.block()?;

					recog.base.set_state(1897);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==CATCH {
						{
						/*InvokeRule catches*/
						recog.base.set_state(1896);
						recog.catches()?;

						}
					}

					/*InvokeRule finally_*/
					recog.base.set_state(1899);
					recog.finally_()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule tryWithResourcesStatement*/
					recog.base.set_state(1901);
					recog.tryWithResourcesStatement()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catches ----------------
pub type CatchesContextAll<'input> = CatchesContext<'input>;


pub type CatchesContext<'input> = BaseParserRuleContext<'input,CatchesContextExt<'input>>;

#[derive(Clone)]
pub struct CatchesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for CatchesContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for CatchesContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catches(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_catches(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CatchesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catches }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catches }
}
antlr_rust::tid!{CatchesContextExt<'a>}

impl<'input> CatchesContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchesContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<CatchesContextExt<'input>>{

fn catchClause_all(&self) ->  Vec<Rc<CatchClauseContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn catchClause(&self, i: usize) -> Option<Rc<CatchClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CatchesContextAttrs<'input> for CatchesContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catches(&mut self,)
	-> Result<Rc<CatchesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 344, RULE_catches);
        let mut _localctx: Rc<CatchesContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1905); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule catchClause*/
				recog.base.set_state(1904);
				recog.catchClause()?;

				}
				}
				recog.base.set_state(1907); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !(_la==CATCH) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchClause ----------------
pub type CatchClauseContextAll<'input> = CatchClauseContext<'input>;


pub type CatchClauseContext<'input> = BaseParserRuleContext<'input,CatchClauseContextExt<'input>>;

#[derive(Clone)]
pub struct CatchClauseContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for CatchClauseContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for CatchClauseContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchClause(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_catchClause(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CatchClauseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchClause }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchClause }
}
antlr_rust::tid!{CatchClauseContextExt<'a>}

impl<'input> CatchClauseContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchClauseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchClauseContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchClauseContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<CatchClauseContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CATCH
/// Returns `None` if there is no child corresponding to token CATCH
fn CATCH(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(CATCH, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn catchFormalParameter(&self) -> Option<Rc<CatchFormalParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CatchClauseContextAttrs<'input> for CatchClauseContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchClause(&mut self,)
	-> Result<Rc<CatchClauseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchClauseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 346, RULE_catchClause);
        let mut _localctx: Rc<CatchClauseContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1909);
			recog.base.match_token(CATCH,&mut recog.err_handler)?;

			recog.base.set_state(1910);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule catchFormalParameter*/
			recog.base.set_state(1911);
			recog.catchFormalParameter()?;

			recog.base.set_state(1912);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule block*/
			recog.base.set_state(1913);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchFormalParameter ----------------
pub type CatchFormalParameterContextAll<'input> = CatchFormalParameterContext<'input>;


pub type CatchFormalParameterContext<'input> = BaseParserRuleContext<'input,CatchFormalParameterContextExt<'input>>;

#[derive(Clone)]
pub struct CatchFormalParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for CatchFormalParameterContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for CatchFormalParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchFormalParameter(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_catchFormalParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CatchFormalParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchFormalParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchFormalParameter }
}
antlr_rust::tid!{CatchFormalParameterContextExt<'a>}

impl<'input> CatchFormalParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchFormalParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchFormalParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchFormalParameterContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<CatchFormalParameterContextExt<'input>>{

fn catchType(&self) -> Option<Rc<CatchTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorId(&self) -> Option<Rc<VariableDeclaratorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CatchFormalParameterContextAttrs<'input> for CatchFormalParameterContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchFormalParameter(&mut self,)
	-> Result<Rc<CatchFormalParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchFormalParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 348, RULE_catchFormalParameter);
        let mut _localctx: Rc<CatchFormalParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1918);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==FINAL || _la==AT {
				{
				{
				/*InvokeRule variableModifier*/
				recog.base.set_state(1915);
				recog.variableModifier()?;

				}
				}
				recog.base.set_state(1920);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule catchType*/
			recog.base.set_state(1921);
			recog.catchType()?;

			/*InvokeRule variableDeclaratorId*/
			recog.base.set_state(1922);
			recog.variableDeclaratorId()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchType ----------------
pub type CatchTypeContextAll<'input> = CatchTypeContext<'input>;


pub type CatchTypeContext<'input> = BaseParserRuleContext<'input,CatchTypeContextExt<'input>>;

#[derive(Clone)]
pub struct CatchTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for CatchTypeContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for CatchTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchType(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_catchType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CatchTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchType }
}
antlr_rust::tid!{CatchTypeContextExt<'a>}

impl<'input> CatchTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchTypeContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<CatchTypeContextExt<'input>>{

fn unannClassType(&self) -> Option<Rc<UnannClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token BITOR in current rule
fn BITOR_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token BITOR, starting from 0.
/// Returns `None` if number of children corresponding to token BITOR is less or equal than `i`.
fn BITOR(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(BITOR, i)
}
fn classType_all(&self) ->  Vec<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classType(&self, i: usize) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> CatchTypeContextAttrs<'input> for CatchTypeContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchType(&mut self,)
	-> Result<Rc<CatchTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 350, RULE_catchType);
        let mut _localctx: Rc<CatchTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule unannClassType*/
			recog.base.set_state(1924);
			recog.unannClassType()?;

			recog.base.set_state(1929);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==BITOR {
				{
				{
				recog.base.set_state(1925);
				recog.base.match_token(BITOR,&mut recog.err_handler)?;

				/*InvokeRule classType*/
				recog.base.set_state(1926);
				recog.classType()?;

				}
				}
				recog.base.set_state(1931);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- finally_ ----------------
pub type Finally_ContextAll<'input> = Finally_Context<'input>;


pub type Finally_Context<'input> = BaseParserRuleContext<'input,Finally_ContextExt<'input>>;

#[derive(Clone)]
pub struct Finally_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for Finally_Context<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for Finally_Context<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_finally_(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_finally_(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for Finally_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_finally_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_finally_ }
}
antlr_rust::tid!{Finally_ContextExt<'a>}

impl<'input> Finally_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Finally_ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Finally_ContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Finally_ContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<Finally_ContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FINALLY
/// Returns `None` if there is no child corresponding to token FINALLY
fn FINALLY(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(FINALLY, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Finally_ContextAttrs<'input> for Finally_Context<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn finally_(&mut self,)
	-> Result<Rc<Finally_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Finally_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 352, RULE_finally_);
        let mut _localctx: Rc<Finally_ContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1932);
			recog.base.match_token(FINALLY,&mut recog.err_handler)?;

			/*InvokeRule block*/
			recog.base.set_state(1933);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tryWithResourcesStatement ----------------
pub type TryWithResourcesStatementContextAll<'input> = TryWithResourcesStatementContext<'input>;


pub type TryWithResourcesStatementContext<'input> = BaseParserRuleContext<'input,TryWithResourcesStatementContextExt<'input>>;

#[derive(Clone)]
pub struct TryWithResourcesStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TryWithResourcesStatementContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TryWithResourcesStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tryWithResourcesStatement(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_tryWithResourcesStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TryWithResourcesStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tryWithResourcesStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tryWithResourcesStatement }
}
antlr_rust::tid!{TryWithResourcesStatementContextExt<'a>}

impl<'input> TryWithResourcesStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TryWithResourcesStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TryWithResourcesStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TryWithResourcesStatementContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TryWithResourcesStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TRY
/// Returns `None` if there is no child corresponding to token TRY
fn TRY(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(TRY, 0)
}
fn resourceSpecification(&self) -> Option<Rc<ResourceSpecificationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn catches(&self) -> Option<Rc<CatchesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn finally_(&self) -> Option<Rc<Finally_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TryWithResourcesStatementContextAttrs<'input> for TryWithResourcesStatementContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tryWithResourcesStatement(&mut self,)
	-> Result<Rc<TryWithResourcesStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TryWithResourcesStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 354, RULE_tryWithResourcesStatement);
        let mut _localctx: Rc<TryWithResourcesStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1935);
			recog.base.match_token(TRY,&mut recog.err_handler)?;

			/*InvokeRule resourceSpecification*/
			recog.base.set_state(1936);
			recog.resourceSpecification()?;

			/*InvokeRule block*/
			recog.base.set_state(1937);
			recog.block()?;

			recog.base.set_state(1939);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==CATCH {
				{
				/*InvokeRule catches*/
				recog.base.set_state(1938);
				recog.catches()?;

				}
			}

			recog.base.set_state(1942);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==FINALLY {
				{
				/*InvokeRule finally_*/
				recog.base.set_state(1941);
				recog.finally_()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- resourceSpecification ----------------
pub type ResourceSpecificationContextAll<'input> = ResourceSpecificationContext<'input>;


pub type ResourceSpecificationContext<'input> = BaseParserRuleContext<'input,ResourceSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct ResourceSpecificationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ResourceSpecificationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ResourceSpecificationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_resourceSpecification(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_resourceSpecification(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ResourceSpecificationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_resourceSpecification }
	//fn type_rule_index() -> usize where Self: Sized { RULE_resourceSpecification }
}
antlr_rust::tid!{ResourceSpecificationContextExt<'a>}

impl<'input> ResourceSpecificationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ResourceSpecificationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ResourceSpecificationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ResourceSpecificationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ResourceSpecificationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn resourceList(&self) -> Option<Rc<ResourceListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}

}

impl<'input> ResourceSpecificationContextAttrs<'input> for ResourceSpecificationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn resourceSpecification(&mut self,)
	-> Result<Rc<ResourceSpecificationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ResourceSpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 356, RULE_resourceSpecification);
        let mut _localctx: Rc<ResourceSpecificationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1944);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule resourceList*/
			recog.base.set_state(1945);
			recog.resourceList()?;

			recog.base.set_state(1947);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==SEMI {
				{
				recog.base.set_state(1946);
				recog.base.match_token(SEMI,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(1949);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- resourceList ----------------
pub type ResourceListContextAll<'input> = ResourceListContext<'input>;


pub type ResourceListContext<'input> = BaseParserRuleContext<'input,ResourceListContextExt<'input>>;

#[derive(Clone)]
pub struct ResourceListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ResourceListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ResourceListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_resourceList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_resourceList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ResourceListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_resourceList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_resourceList }
}
antlr_rust::tid!{ResourceListContextExt<'a>}

impl<'input> ResourceListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ResourceListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ResourceListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ResourceListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ResourceListContextExt<'input>>{

fn resource_all(&self) ->  Vec<Rc<ResourceContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn resource(&self, i: usize) -> Option<Rc<ResourceContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token SEMI in current rule
fn SEMI_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SEMI, starting from 0.
/// Returns `None` if number of children corresponding to token SEMI is less or equal than `i`.
fn SEMI(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SEMI, i)
}

}

impl<'input> ResourceListContextAttrs<'input> for ResourceListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn resourceList(&mut self,)
	-> Result<Rc<ResourceListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ResourceListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 358, RULE_resourceList);
        let mut _localctx: Rc<ResourceListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule resource*/
			recog.base.set_state(1951);
			recog.resource()?;

			recog.base.set_state(1956);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(200,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1952);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					/*InvokeRule resource*/
					recog.base.set_state(1953);
					recog.resource()?;

					}
					} 
				}
				recog.base.set_state(1958);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(200,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- resource ----------------
pub type ResourceContextAll<'input> = ResourceContext<'input>;


pub type ResourceContext<'input> = BaseParserRuleContext<'input,ResourceContextExt<'input>>;

#[derive(Clone)]
pub struct ResourceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ResourceContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ResourceContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_resource(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_resource(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ResourceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_resource }
	//fn type_rule_index() -> usize where Self: Sized { RULE_resource }
}
antlr_rust::tid!{ResourceContextExt<'a>}

impl<'input> ResourceContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ResourceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ResourceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ResourceContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ResourceContextExt<'input>>{

fn unannType(&self) -> Option<Rc<UnannTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaratorId(&self) -> Option<Rc<VariableDeclaratorIdContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGN
/// Returns `None` if there is no child corresponding to token ASSIGN
fn ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ASSIGN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableModifier_all(&self) ->  Vec<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableModifier(&self, i: usize) -> Option<Rc<VariableModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn variableAccess(&self) -> Option<Rc<VariableAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ResourceContextAttrs<'input> for ResourceContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn resource(&mut self,)
	-> Result<Rc<ResourceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ResourceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 360, RULE_resource);
        let mut _localctx: Rc<ResourceContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1971);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(202,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1962);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==FINAL || _la==AT {
						{
						{
						/*InvokeRule variableModifier*/
						recog.base.set_state(1959);
						recog.variableModifier()?;

						}
						}
						recog.base.set_state(1964);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule unannType*/
					recog.base.set_state(1965);
					recog.unannType()?;

					/*InvokeRule variableDeclaratorId*/
					recog.base.set_state(1966);
					recog.variableDeclaratorId()?;

					recog.base.set_state(1967);
					recog.base.match_token(ASSIGN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1968);
					recog.expression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule variableAccess*/
					recog.base.set_state(1970);
					recog.variableAccess()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableAccess ----------------
pub type VariableAccessContextAll<'input> = VariableAccessContext<'input>;


pub type VariableAccessContext<'input> = BaseParserRuleContext<'input,VariableAccessContextExt<'input>>;

#[derive(Clone)]
pub struct VariableAccessContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for VariableAccessContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for VariableAccessContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableAccess(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_variableAccess(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for VariableAccessContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableAccess }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableAccess }
}
antlr_rust::tid!{VariableAccessContextExt<'a>}

impl<'input> VariableAccessContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableAccessContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableAccessContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableAccessContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<VariableAccessContextExt<'input>>{

fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldAccess(&self) -> Option<Rc<FieldAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VariableAccessContextAttrs<'input> for VariableAccessContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableAccess(&mut self,)
	-> Result<Rc<VariableAccessContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableAccessContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 362, RULE_variableAccess);
        let mut _localctx: Rc<VariableAccessContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1975);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(203,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(1973);
					recog.expressionName()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule fieldAccess*/
					recog.base.set_state(1974);
					recog.fieldAccess()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primary ----------------
pub type PrimaryContextAll<'input> = PrimaryContext<'input>;


pub type PrimaryContext<'input> = BaseParserRuleContext<'input,PrimaryContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PrimaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PrimaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primary }
}
antlr_rust::tid!{PrimaryContextExt<'a>}

impl<'input> PrimaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PrimaryContextExt<'input>>{

fn primaryNoNewArray_lfno_primary(&self) -> Option<Rc<PrimaryNoNewArray_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayCreationExpression(&self) -> Option<Rc<ArrayCreationExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primaryNoNewArray_lf_primary_all(&self) ->  Vec<Rc<PrimaryNoNewArray_lf_primaryContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn primaryNoNewArray_lf_primary(&self, i: usize) -> Option<Rc<PrimaryNoNewArray_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PrimaryContextAttrs<'input> for PrimaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primary(&mut self,)
	-> Result<Rc<PrimaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 364, RULE_primary);
        let mut _localctx: Rc<PrimaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1979);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(204,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule primaryNoNewArray_lfno_primary*/
					recog.base.set_state(1977);
					recog.primaryNoNewArray_lfno_primary()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule arrayCreationExpression*/
					recog.base.set_state(1978);
					recog.arrayCreationExpression()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1984);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(205,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule primaryNoNewArray_lf_primary*/
					recog.base.set_state(1981);
					recog.primaryNoNewArray_lf_primary()?;

					}
					} 
				}
				recog.base.set_state(1986);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(205,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryNoNewArray ----------------
pub type PrimaryNoNewArrayContextAll<'input> = PrimaryNoNewArrayContext<'input>;


pub type PrimaryNoNewArrayContext<'input> = BaseParserRuleContext<'input,PrimaryNoNewArrayContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryNoNewArrayContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PrimaryNoNewArrayContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PrimaryNoNewArrayContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryNoNewArray(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_primaryNoNewArray(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimaryNoNewArrayContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryNoNewArray }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryNoNewArray }
}
antlr_rust::tid!{PrimaryNoNewArrayContextExt<'a>}

impl<'input> PrimaryNoNewArrayContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryNoNewArrayContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryNoNewArrayContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryNoNewArrayContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PrimaryNoNewArrayContextExt<'input>>{

fn literal(&self) -> Option<Rc<LiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classLiteral(&self) -> Option<Rc<ClassLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn classInstanceCreationExpression(&self) -> Option<Rc<ClassInstanceCreationExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldAccess(&self) -> Option<Rc<FieldAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayAccess(&self) -> Option<Rc<ArrayAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodInvocation(&self) -> Option<Rc<MethodInvocationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodReference(&self) -> Option<Rc<MethodReferenceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryNoNewArrayContextAttrs<'input> for PrimaryNoNewArrayContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryNoNewArray(&mut self,)
	-> Result<Rc<PrimaryNoNewArrayContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryNoNewArrayContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 366, RULE_primaryNoNewArray);
        let mut _localctx: Rc<PrimaryNoNewArrayContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2003);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(206,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule literal*/
					recog.base.set_state(1987);
					recog.literal()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule classLiteral*/
					recog.base.set_state(1988);
					recog.classLiteral()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(1989);
					recog.base.match_token(THIS,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(1990);
					recog.typeName()?;

					recog.base.set_state(1991);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1992);
					recog.base.match_token(THIS,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(1994);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1995);
					recog.expression()?;

					recog.base.set_state(1996);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule classInstanceCreationExpression*/
					recog.base.set_state(1998);
					recog.classInstanceCreationExpression()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule fieldAccess*/
					recog.base.set_state(1999);
					recog.fieldAccess()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule arrayAccess*/
					recog.base.set_state(2000);
					recog.arrayAccess()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule methodInvocation*/
					recog.base.set_state(2001);
					recog.methodInvocation()?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule methodReference*/
					recog.base.set_state(2002);
					recog.methodReference()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryNoNewArray_lf_arrayAccess ----------------
pub type PrimaryNoNewArray_lf_arrayAccessContextAll<'input> = PrimaryNoNewArray_lf_arrayAccessContext<'input>;


pub type PrimaryNoNewArray_lf_arrayAccessContext<'input> = BaseParserRuleContext<'input,PrimaryNoNewArray_lf_arrayAccessContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryNoNewArray_lf_arrayAccessContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PrimaryNoNewArray_lf_arrayAccessContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PrimaryNoNewArray_lf_arrayAccessContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryNoNewArray_lf_arrayAccess(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_primaryNoNewArray_lf_arrayAccess(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimaryNoNewArray_lf_arrayAccessContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryNoNewArray_lf_arrayAccess }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryNoNewArray_lf_arrayAccess }
}
antlr_rust::tid!{PrimaryNoNewArray_lf_arrayAccessContextExt<'a>}

impl<'input> PrimaryNoNewArray_lf_arrayAccessContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryNoNewArray_lf_arrayAccessContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryNoNewArray_lf_arrayAccessContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryNoNewArray_lf_arrayAccessContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PrimaryNoNewArray_lf_arrayAccessContextExt<'input>>{


}

impl<'input> PrimaryNoNewArray_lf_arrayAccessContextAttrs<'input> for PrimaryNoNewArray_lf_arrayAccessContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryNoNewArray_lf_arrayAccess(&mut self,)
	-> Result<Rc<PrimaryNoNewArray_lf_arrayAccessContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryNoNewArray_lf_arrayAccessContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 368, RULE_primaryNoNewArray_lf_arrayAccess);
        let mut _localctx: Rc<PrimaryNoNewArray_lf_arrayAccessContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryNoNewArray_lfno_arrayAccess ----------------
pub type PrimaryNoNewArray_lfno_arrayAccessContextAll<'input> = PrimaryNoNewArray_lfno_arrayAccessContext<'input>;


pub type PrimaryNoNewArray_lfno_arrayAccessContext<'input> = BaseParserRuleContext<'input,PrimaryNoNewArray_lfno_arrayAccessContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryNoNewArray_lfno_arrayAccessContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PrimaryNoNewArray_lfno_arrayAccessContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PrimaryNoNewArray_lfno_arrayAccessContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryNoNewArray_lfno_arrayAccess(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_primaryNoNewArray_lfno_arrayAccess(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimaryNoNewArray_lfno_arrayAccessContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryNoNewArray_lfno_arrayAccess }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryNoNewArray_lfno_arrayAccess }
}
antlr_rust::tid!{PrimaryNoNewArray_lfno_arrayAccessContextExt<'a>}

impl<'input> PrimaryNoNewArray_lfno_arrayAccessContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryNoNewArray_lfno_arrayAccessContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryNoNewArray_lfno_arrayAccessContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryNoNewArray_lfno_arrayAccessContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PrimaryNoNewArray_lfno_arrayAccessContextExt<'input>>{

fn literal(&self) -> Option<Rc<LiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token LBRACK in current rule
fn LBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token LBRACK is less or equal than `i`.
fn LBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RBRACK in current rule
fn RBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token RBRACK is less or equal than `i`.
fn RBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, i)
}
/// Retrieves first TerminalNode corresponding to token VOID
/// Returns `None` if there is no child corresponding to token VOID
fn VOID(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(VOID, 0)
}
/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn classInstanceCreationExpression(&self) -> Option<Rc<ClassInstanceCreationExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldAccess(&self) -> Option<Rc<FieldAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodInvocation(&self) -> Option<Rc<MethodInvocationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodReference(&self) -> Option<Rc<MethodReferenceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryNoNewArray_lfno_arrayAccessContextAttrs<'input> for PrimaryNoNewArray_lfno_arrayAccessContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryNoNewArray_lfno_arrayAccess(&mut self,)
	-> Result<Rc<PrimaryNoNewArray_lfno_arrayAccessContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryNoNewArray_lfno_arrayAccessContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 370, RULE_primaryNoNewArray_lfno_arrayAccess);
        let mut _localctx: Rc<PrimaryNoNewArray_lfno_arrayAccessContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2035);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(208,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule literal*/
					recog.base.set_state(2007);
					recog.literal()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2008);
					recog.typeName()?;

					recog.base.set_state(2013);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==LBRACK {
						{
						{
						recog.base.set_state(2009);
						recog.base.match_token(LBRACK,&mut recog.err_handler)?;

						recog.base.set_state(2010);
						recog.base.match_token(RBRACK,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2015);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2016);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2017);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2019);
					recog.base.match_token(VOID,&mut recog.err_handler)?;

					recog.base.set_state(2020);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2021);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2022);
					recog.base.match_token(THIS,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2023);
					recog.typeName()?;

					recog.base.set_state(2024);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2025);
					recog.base.match_token(THIS,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(2027);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2028);
					recog.expression()?;

					recog.base.set_state(2029);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule classInstanceCreationExpression*/
					recog.base.set_state(2031);
					recog.classInstanceCreationExpression()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule fieldAccess*/
					recog.base.set_state(2032);
					recog.fieldAccess()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule methodInvocation*/
					recog.base.set_state(2033);
					recog.methodInvocation()?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule methodReference*/
					recog.base.set_state(2034);
					recog.methodReference()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryNoNewArray_lf_primary ----------------
pub type PrimaryNoNewArray_lf_primaryContextAll<'input> = PrimaryNoNewArray_lf_primaryContext<'input>;


pub type PrimaryNoNewArray_lf_primaryContext<'input> = BaseParserRuleContext<'input,PrimaryNoNewArray_lf_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryNoNewArray_lf_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PrimaryNoNewArray_lf_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PrimaryNoNewArray_lf_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryNoNewArray_lf_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_primaryNoNewArray_lf_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimaryNoNewArray_lf_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryNoNewArray_lf_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryNoNewArray_lf_primary }
}
antlr_rust::tid!{PrimaryNoNewArray_lf_primaryContextExt<'a>}

impl<'input> PrimaryNoNewArray_lf_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryNoNewArray_lf_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryNoNewArray_lf_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryNoNewArray_lf_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PrimaryNoNewArray_lf_primaryContextExt<'input>>{

fn classInstanceCreationExpression_lf_primary(&self) -> Option<Rc<ClassInstanceCreationExpression_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldAccess_lf_primary(&self) -> Option<Rc<FieldAccess_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayAccess_lf_primary(&self) -> Option<Rc<ArrayAccess_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodInvocation_lf_primary(&self) -> Option<Rc<MethodInvocation_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodReference_lf_primary(&self) -> Option<Rc<MethodReference_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryNoNewArray_lf_primaryContextAttrs<'input> for PrimaryNoNewArray_lf_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryNoNewArray_lf_primary(&mut self,)
	-> Result<Rc<PrimaryNoNewArray_lf_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryNoNewArray_lf_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 372, RULE_primaryNoNewArray_lf_primary);
        let mut _localctx: Rc<PrimaryNoNewArray_lf_primaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2042);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(209,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classInstanceCreationExpression_lf_primary*/
					recog.base.set_state(2037);
					recog.classInstanceCreationExpression_lf_primary()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule fieldAccess_lf_primary*/
					recog.base.set_state(2038);
					recog.fieldAccess_lf_primary()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule arrayAccess_lf_primary*/
					recog.base.set_state(2039);
					recog.arrayAccess_lf_primary()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule methodInvocation_lf_primary*/
					recog.base.set_state(2040);
					recog.methodInvocation_lf_primary()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule methodReference_lf_primary*/
					recog.base.set_state(2041);
					recog.methodReference_lf_primary()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary ----------------
pub type PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextAll<'input> = PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext<'input>;


pub type PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext<'input> = BaseParserRuleContext<'input,PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary }
}
antlr_rust::tid!{PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextExt<'a>}

impl<'input> PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextExt<'input>>{


}

impl<'input> PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextAttrs<'input> for PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary(&mut self,)
	-> Result<Rc<PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 374, RULE_primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary);
        let mut _localctx: Rc<PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary ----------------
pub type PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextAll<'input> = PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext<'input>;


pub type PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext<'input> = BaseParserRuleContext<'input,PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary }
}
antlr_rust::tid!{PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextExt<'a>}

impl<'input> PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextExt<'input>>{

fn classInstanceCreationExpression_lf_primary(&self) -> Option<Rc<ClassInstanceCreationExpression_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldAccess_lf_primary(&self) -> Option<Rc<FieldAccess_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodInvocation_lf_primary(&self) -> Option<Rc<MethodInvocation_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodReference_lf_primary(&self) -> Option<Rc<MethodReference_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextAttrs<'input> for PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary(&mut self,)
	-> Result<Rc<PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 376, RULE_primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary);
        let mut _localctx: Rc<PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2050);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(210,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classInstanceCreationExpression_lf_primary*/
					recog.base.set_state(2046);
					recog.classInstanceCreationExpression_lf_primary()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule fieldAccess_lf_primary*/
					recog.base.set_state(2047);
					recog.fieldAccess_lf_primary()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule methodInvocation_lf_primary*/
					recog.base.set_state(2048);
					recog.methodInvocation_lf_primary()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule methodReference_lf_primary*/
					recog.base.set_state(2049);
					recog.methodReference_lf_primary()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryNoNewArray_lfno_primary ----------------
pub type PrimaryNoNewArray_lfno_primaryContextAll<'input> = PrimaryNoNewArray_lfno_primaryContext<'input>;


pub type PrimaryNoNewArray_lfno_primaryContext<'input> = BaseParserRuleContext<'input,PrimaryNoNewArray_lfno_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryNoNewArray_lfno_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PrimaryNoNewArray_lfno_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PrimaryNoNewArray_lfno_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryNoNewArray_lfno_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_primaryNoNewArray_lfno_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimaryNoNewArray_lfno_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryNoNewArray_lfno_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryNoNewArray_lfno_primary }
}
antlr_rust::tid!{PrimaryNoNewArray_lfno_primaryContextExt<'a>}

impl<'input> PrimaryNoNewArray_lfno_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryNoNewArray_lfno_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryNoNewArray_lfno_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryNoNewArray_lfno_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PrimaryNoNewArray_lfno_primaryContextExt<'input>>{

fn literal(&self) -> Option<Rc<LiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token LBRACK in current rule
fn LBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token LBRACK is less or equal than `i`.
fn LBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RBRACK in current rule
fn RBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token RBRACK is less or equal than `i`.
fn RBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, i)
}
fn unannPrimitiveType(&self) -> Option<Rc<UnannPrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token VOID
/// Returns `None` if there is no child corresponding to token VOID
fn VOID(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(VOID, 0)
}
/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn classInstanceCreationExpression_lfno_primary(&self) -> Option<Rc<ClassInstanceCreationExpression_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldAccess_lfno_primary(&self) -> Option<Rc<FieldAccess_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayAccess_lfno_primary(&self) -> Option<Rc<ArrayAccess_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodInvocation_lfno_primary(&self) -> Option<Rc<MethodInvocation_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodReference_lfno_primary(&self) -> Option<Rc<MethodReference_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryNoNewArray_lfno_primaryContextAttrs<'input> for PrimaryNoNewArray_lfno_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryNoNewArray_lfno_primary(&mut self,)
	-> Result<Rc<PrimaryNoNewArray_lfno_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryNoNewArray_lfno_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 378, RULE_primaryNoNewArray_lfno_primary);
        let mut _localctx: Rc<PrimaryNoNewArray_lfno_primaryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2092);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(213,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule literal*/
					recog.base.set_state(2052);
					recog.literal()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2053);
					recog.typeName()?;

					recog.base.set_state(2058);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==LBRACK {
						{
						{
						recog.base.set_state(2054);
						recog.base.match_token(LBRACK,&mut recog.err_handler)?;

						recog.base.set_state(2055);
						recog.base.match_token(RBRACK,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2060);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2061);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2062);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule unannPrimitiveType*/
					recog.base.set_state(2064);
					recog.unannPrimitiveType()?;

					recog.base.set_state(2069);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==LBRACK {
						{
						{
						recog.base.set_state(2065);
						recog.base.match_token(LBRACK,&mut recog.err_handler)?;

						recog.base.set_state(2066);
						recog.base.match_token(RBRACK,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2071);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2072);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2073);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2075);
					recog.base.match_token(VOID,&mut recog.err_handler)?;

					recog.base.set_state(2076);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2077);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(2078);
					recog.base.match_token(THIS,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2079);
					recog.typeName()?;

					recog.base.set_state(2080);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2081);
					recog.base.match_token(THIS,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(2083);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2084);
					recog.expression()?;

					recog.base.set_state(2085);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule classInstanceCreationExpression_lfno_primary*/
					recog.base.set_state(2087);
					recog.classInstanceCreationExpression_lfno_primary()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule fieldAccess_lfno_primary*/
					recog.base.set_state(2088);
					recog.fieldAccess_lfno_primary()?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule arrayAccess_lfno_primary*/
					recog.base.set_state(2089);
					recog.arrayAccess_lfno_primary()?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule methodInvocation_lfno_primary*/
					recog.base.set_state(2090);
					recog.methodInvocation_lfno_primary()?;

					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule methodReference_lfno_primary*/
					recog.base.set_state(2091);
					recog.methodReference_lfno_primary()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary ----------------
pub type PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextAll<'input> = PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext<'input>;


pub type PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext<'input> = BaseParserRuleContext<'input,PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary }
}
antlr_rust::tid!{PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextExt<'a>}

impl<'input> PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextExt<'input>>{


}

impl<'input> PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextAttrs<'input> for PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary(&mut self,)
	-> Result<Rc<PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 380, RULE_primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary);
        let mut _localctx: Rc<PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary ----------------
pub type PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextAll<'input> = PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext<'input>;


pub type PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext<'input> = BaseParserRuleContext<'input,PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary }
}
antlr_rust::tid!{PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextExt<'a>}

impl<'input> PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextExt<'input>>{

fn literal(&self) -> Option<Rc<LiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token LBRACK in current rule
fn LBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token LBRACK is less or equal than `i`.
fn LBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RBRACK in current rule
fn RBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token RBRACK is less or equal than `i`.
fn RBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, i)
}
fn unannPrimitiveType(&self) -> Option<Rc<UnannPrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token VOID
/// Returns `None` if there is no child corresponding to token VOID
fn VOID(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(VOID, 0)
}
/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn classInstanceCreationExpression_lfno_primary(&self) -> Option<Rc<ClassInstanceCreationExpression_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldAccess_lfno_primary(&self) -> Option<Rc<FieldAccess_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodInvocation_lfno_primary(&self) -> Option<Rc<MethodInvocation_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodReference_lfno_primary(&self) -> Option<Rc<MethodReference_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextAttrs<'input> for PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary(&mut self,)
	-> Result<Rc<PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 382, RULE_primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary);
        let mut _localctx: Rc<PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2135);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(216,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule literal*/
					recog.base.set_state(2096);
					recog.literal()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2097);
					recog.typeName()?;

					recog.base.set_state(2102);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==LBRACK {
						{
						{
						recog.base.set_state(2098);
						recog.base.match_token(LBRACK,&mut recog.err_handler)?;

						recog.base.set_state(2099);
						recog.base.match_token(RBRACK,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2104);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2105);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2106);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule unannPrimitiveType*/
					recog.base.set_state(2108);
					recog.unannPrimitiveType()?;

					recog.base.set_state(2113);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==LBRACK {
						{
						{
						recog.base.set_state(2109);
						recog.base.match_token(LBRACK,&mut recog.err_handler)?;

						recog.base.set_state(2110);
						recog.base.match_token(RBRACK,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2115);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2116);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2117);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2119);
					recog.base.match_token(VOID,&mut recog.err_handler)?;

					recog.base.set_state(2120);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2121);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(2122);
					recog.base.match_token(THIS,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2123);
					recog.typeName()?;

					recog.base.set_state(2124);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2125);
					recog.base.match_token(THIS,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(2127);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2128);
					recog.expression()?;

					recog.base.set_state(2129);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule classInstanceCreationExpression_lfno_primary*/
					recog.base.set_state(2131);
					recog.classInstanceCreationExpression_lfno_primary()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule fieldAccess_lfno_primary*/
					recog.base.set_state(2132);
					recog.fieldAccess_lfno_primary()?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule methodInvocation_lfno_primary*/
					recog.base.set_state(2133);
					recog.methodInvocation_lfno_primary()?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule methodReference_lfno_primary*/
					recog.base.set_state(2134);
					recog.methodReference_lfno_primary()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classLiteral ----------------
pub type ClassLiteralContextAll<'input> = ClassLiteralContext<'input>;


pub type ClassLiteralContext<'input> = BaseParserRuleContext<'input,ClassLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct ClassLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classLiteral(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classLiteral }
}
antlr_rust::tid!{ClassLiteralContextExt<'a>}

impl<'input> ClassLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassLiteralContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericType(&self) -> Option<Rc<NumericTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BOOLEAN
/// Returns `None` if there is no child corresponding to token BOOLEAN
fn BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(BOOLEAN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token LBRACK in current rule
fn LBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token LBRACK is less or equal than `i`.
fn LBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RBRACK in current rule
fn RBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token RBRACK is less or equal than `i`.
fn RBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, i)
}
/// Retrieves first TerminalNode corresponding to token VOID
/// Returns `None` if there is no child corresponding to token VOID
fn VOID(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(VOID, 0)
}

}

impl<'input> ClassLiteralContextAttrs<'input> for ClassLiteralContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classLiteral(&mut self,)
	-> Result<Rc<ClassLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 384, RULE_classLiteral);
        let mut _localctx: Rc<ClassLiteralContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2154);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN | BYTE | CHAR | DOUBLE | EXPORTS | FLOAT | INT | LONG | MODULE |
			 OPEN | OPERNS | PROVIDES | REQUIRES | SHORT | TO | USES | WITH | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2140);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 EXPORTS | MODULE | OPEN | OPERNS | PROVIDES | REQUIRES | TO | USES |
					 WITH | Identifier 
						=> {
							{
							/*InvokeRule typeName*/
							recog.base.set_state(2137);
							recog.typeName()?;

							}
						}

					 BYTE | CHAR | DOUBLE | FLOAT | INT | LONG | SHORT 
						=> {
							{
							/*InvokeRule numericType*/
							recog.base.set_state(2138);
							recog.numericType()?;

							}
						}

					 BOOLEAN 
						=> {
							{
							recog.base.set_state(2139);
							recog.base.match_token(BOOLEAN,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(2146);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==LBRACK {
						{
						{
						recog.base.set_state(2142);
						recog.base.match_token(LBRACK,&mut recog.err_handler)?;

						recog.base.set_state(2143);
						recog.base.match_token(RBRACK,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2148);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2149);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2150);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

			 VOID 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2151);
					recog.base.match_token(VOID,&mut recog.err_handler)?;

					recog.base.set_state(2152);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2153);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classInstanceCreationExpression ----------------
pub type ClassInstanceCreationExpressionContextAll<'input> = ClassInstanceCreationExpressionContext<'input>;


pub type ClassInstanceCreationExpressionContext<'input> = BaseParserRuleContext<'input,ClassInstanceCreationExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ClassInstanceCreationExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassInstanceCreationExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassInstanceCreationExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classInstanceCreationExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classInstanceCreationExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassInstanceCreationExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classInstanceCreationExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classInstanceCreationExpression }
}
antlr_rust::tid!{ClassInstanceCreationExpressionContextExt<'a>}

impl<'input> ClassInstanceCreationExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassInstanceCreationExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassInstanceCreationExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassInstanceCreationExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassInstanceCreationExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token NEW
/// Returns `None` if there is no child corresponding to token NEW
fn NEW(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(NEW, 0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn typeArgumentsOrDiamond(&self) -> Option<Rc<TypeArgumentsOrDiamondContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassInstanceCreationExpressionContextAttrs<'input> for ClassInstanceCreationExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classInstanceCreationExpression(&mut self,)
	-> Result<Rc<ClassInstanceCreationExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassInstanceCreationExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 386, RULE_classInstanceCreationExpression);
        let mut _localctx: Rc<ClassInstanceCreationExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2239);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(237,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2156);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					recog.base.set_state(2158);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2157);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2163);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(2160);
						recog.annotation()?;

						}
						}
						recog.base.set_state(2165);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule identifier*/
					recog.base.set_state(2166);
					recog.identifier()?;

					recog.base.set_state(2177);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==DOT {
						{
						{
						recog.base.set_state(2167);
						recog.base.match_token(DOT,&mut recog.err_handler)?;

						recog.base.set_state(2171);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==AT {
							{
							{
							/*InvokeRule annotation*/
							recog.base.set_state(2168);
							recog.annotation()?;

							}
							}
							recog.base.set_state(2173);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						/*InvokeRule identifier*/
						recog.base.set_state(2174);
						recog.identifier()?;

						}
						}
						recog.base.set_state(2179);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2181);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArgumentsOrDiamond*/
						recog.base.set_state(2180);
						recog.typeArgumentsOrDiamond()?;

						}
					}

					recog.base.set_state(2183);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2185);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2184);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2187);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2189);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LBRACE {
						{
						/*InvokeRule classBody*/
						recog.base.set_state(2188);
						recog.classBody()?;

						}
					}

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2191);
					recog.expressionName()?;

					recog.base.set_state(2192);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2193);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					recog.base.set_state(2195);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2194);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2200);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(2197);
						recog.annotation()?;

						}
						}
						recog.base.set_state(2202);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule identifier*/
					recog.base.set_state(2203);
					recog.identifier()?;

					recog.base.set_state(2205);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArgumentsOrDiamond*/
						recog.base.set_state(2204);
						recog.typeArgumentsOrDiamond()?;

						}
					}

					recog.base.set_state(2207);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2209);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2208);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2211);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2213);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LBRACE {
						{
						/*InvokeRule classBody*/
						recog.base.set_state(2212);
						recog.classBody()?;

						}
					}

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule primary*/
					recog.base.set_state(2215);
					recog.primary()?;

					recog.base.set_state(2216);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2217);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					recog.base.set_state(2219);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2218);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2224);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(2221);
						recog.annotation()?;

						}
						}
						recog.base.set_state(2226);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule identifier*/
					recog.base.set_state(2227);
					recog.identifier()?;

					recog.base.set_state(2229);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArgumentsOrDiamond*/
						recog.base.set_state(2228);
						recog.typeArgumentsOrDiamond()?;

						}
					}

					recog.base.set_state(2231);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2233);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2232);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2235);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2237);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LBRACE {
						{
						/*InvokeRule classBody*/
						recog.base.set_state(2236);
						recog.classBody()?;

						}
					}

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classInstanceCreationExpression_lf_primary ----------------
pub type ClassInstanceCreationExpression_lf_primaryContextAll<'input> = ClassInstanceCreationExpression_lf_primaryContext<'input>;


pub type ClassInstanceCreationExpression_lf_primaryContext<'input> = BaseParserRuleContext<'input,ClassInstanceCreationExpression_lf_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct ClassInstanceCreationExpression_lf_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassInstanceCreationExpression_lf_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassInstanceCreationExpression_lf_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classInstanceCreationExpression_lf_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classInstanceCreationExpression_lf_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassInstanceCreationExpression_lf_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classInstanceCreationExpression_lf_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classInstanceCreationExpression_lf_primary }
}
antlr_rust::tid!{ClassInstanceCreationExpression_lf_primaryContextExt<'a>}

impl<'input> ClassInstanceCreationExpression_lf_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassInstanceCreationExpression_lf_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassInstanceCreationExpression_lf_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassInstanceCreationExpression_lf_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassInstanceCreationExpression_lf_primaryContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token NEW
/// Returns `None` if there is no child corresponding to token NEW
fn NEW(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(NEW, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn typeArgumentsOrDiamond(&self) -> Option<Rc<TypeArgumentsOrDiamondContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassInstanceCreationExpression_lf_primaryContextAttrs<'input> for ClassInstanceCreationExpression_lf_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classInstanceCreationExpression_lf_primary(&mut self,)
	-> Result<Rc<ClassInstanceCreationExpression_lf_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassInstanceCreationExpression_lf_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 388, RULE_classInstanceCreationExpression_lf_primary);
        let mut _localctx: Rc<ClassInstanceCreationExpression_lf_primaryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2241);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(2242);
			recog.base.match_token(NEW,&mut recog.err_handler)?;

			recog.base.set_state(2244);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeArguments*/
				recog.base.set_state(2243);
				recog.typeArguments()?;

				}
			}

			recog.base.set_state(2249);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(2246);
				recog.annotation()?;

				}
				}
				recog.base.set_state(2251);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule identifier*/
			recog.base.set_state(2252);
			recog.identifier()?;

			recog.base.set_state(2254);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeArgumentsOrDiamond*/
				recog.base.set_state(2253);
				recog.typeArgumentsOrDiamond()?;

				}
			}

			recog.base.set_state(2256);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2258);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
				{
				/*InvokeRule argumentList*/
				recog.base.set_state(2257);
				recog.argumentList()?;

				}
			}

			recog.base.set_state(2260);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2262);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(242,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule classBody*/
					recog.base.set_state(2261);
					recog.classBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classInstanceCreationExpression_lfno_primary ----------------
pub type ClassInstanceCreationExpression_lfno_primaryContextAll<'input> = ClassInstanceCreationExpression_lfno_primaryContext<'input>;


pub type ClassInstanceCreationExpression_lfno_primaryContext<'input> = BaseParserRuleContext<'input,ClassInstanceCreationExpression_lfno_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct ClassInstanceCreationExpression_lfno_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ClassInstanceCreationExpression_lfno_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ClassInstanceCreationExpression_lfno_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classInstanceCreationExpression_lfno_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_classInstanceCreationExpression_lfno_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassInstanceCreationExpression_lfno_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classInstanceCreationExpression_lfno_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classInstanceCreationExpression_lfno_primary }
}
antlr_rust::tid!{ClassInstanceCreationExpression_lfno_primaryContextExt<'a>}

impl<'input> ClassInstanceCreationExpression_lfno_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassInstanceCreationExpression_lfno_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassInstanceCreationExpression_lfno_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassInstanceCreationExpression_lfno_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ClassInstanceCreationExpression_lfno_primaryContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token NEW
/// Returns `None` if there is no child corresponding to token NEW
fn NEW(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(NEW, 0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn typeArgumentsOrDiamond(&self) -> Option<Rc<TypeArgumentsOrDiamondContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassInstanceCreationExpression_lfno_primaryContextAttrs<'input> for ClassInstanceCreationExpression_lfno_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classInstanceCreationExpression_lfno_primary(&mut self,)
	-> Result<Rc<ClassInstanceCreationExpression_lfno_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassInstanceCreationExpression_lfno_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 390, RULE_classInstanceCreationExpression_lfno_primary);
        let mut _localctx: Rc<ClassInstanceCreationExpression_lfno_primaryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2323);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 NEW 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2264);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					recog.base.set_state(2266);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2265);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2271);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(2268);
						recog.annotation()?;

						}
						}
						recog.base.set_state(2273);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule identifier*/
					recog.base.set_state(2274);
					recog.identifier()?;

					recog.base.set_state(2285);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==DOT {
						{
						{
						recog.base.set_state(2275);
						recog.base.match_token(DOT,&mut recog.err_handler)?;

						recog.base.set_state(2279);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==AT {
							{
							{
							/*InvokeRule annotation*/
							recog.base.set_state(2276);
							recog.annotation()?;

							}
							}
							recog.base.set_state(2281);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						/*InvokeRule identifier*/
						recog.base.set_state(2282);
						recog.identifier()?;

						}
						}
						recog.base.set_state(2287);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2289);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArgumentsOrDiamond*/
						recog.base.set_state(2288);
						recog.typeArgumentsOrDiamond()?;

						}
					}

					recog.base.set_state(2291);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2293);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2292);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2295);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2297);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(249,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule classBody*/
							recog.base.set_state(2296);
							recog.classBody()?;

							}
						}

						_ => {}
					}
					}
				}

			 EXPORTS | MODULE | OPEN | OPERNS | PROVIDES | REQUIRES | TO | USES |
			 WITH | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2299);
					recog.expressionName()?;

					recog.base.set_state(2300);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2301);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					recog.base.set_state(2303);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2302);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2308);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(2305);
						recog.annotation()?;

						}
						}
						recog.base.set_state(2310);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule identifier*/
					recog.base.set_state(2311);
					recog.identifier()?;

					recog.base.set_state(2313);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArgumentsOrDiamond*/
						recog.base.set_state(2312);
						recog.typeArgumentsOrDiamond()?;

						}
					}

					recog.base.set_state(2315);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2317);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2316);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2319);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2321);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(254,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule classBody*/
							recog.base.set_state(2320);
							recog.classBody()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeArgumentsOrDiamond ----------------
pub type TypeArgumentsOrDiamondContextAll<'input> = TypeArgumentsOrDiamondContext<'input>;


pub type TypeArgumentsOrDiamondContext<'input> = BaseParserRuleContext<'input,TypeArgumentsOrDiamondContextExt<'input>>;

#[derive(Clone)]
pub struct TypeArgumentsOrDiamondContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for TypeArgumentsOrDiamondContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for TypeArgumentsOrDiamondContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeArgumentsOrDiamond(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_typeArgumentsOrDiamond(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TypeArgumentsOrDiamondContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeArgumentsOrDiamond }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeArgumentsOrDiamond }
}
antlr_rust::tid!{TypeArgumentsOrDiamondContextExt<'a>}

impl<'input> TypeArgumentsOrDiamondContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeArgumentsOrDiamondContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeArgumentsOrDiamondContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeArgumentsOrDiamondContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<TypeArgumentsOrDiamondContextExt<'input>>{

fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LT
/// Returns `None` if there is no child corresponding to token LT
fn LT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LT, 0)
}
/// Retrieves first TerminalNode corresponding to token GT
/// Returns `None` if there is no child corresponding to token GT
fn GT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(GT, 0)
}

}

impl<'input> TypeArgumentsOrDiamondContextAttrs<'input> for TypeArgumentsOrDiamondContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeArgumentsOrDiamond(&mut self,)
	-> Result<Rc<TypeArgumentsOrDiamondContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeArgumentsOrDiamondContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 392, RULE_typeArgumentsOrDiamond);
        let mut _localctx: Rc<TypeArgumentsOrDiamondContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2328);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(256,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(2325);
					recog.typeArguments()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2326);
					recog.base.match_token(LT,&mut recog.err_handler)?;

					recog.base.set_state(2327);
					recog.base.match_token(GT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldAccess ----------------
pub type FieldAccessContextAll<'input> = FieldAccessContext<'input>;


pub type FieldAccessContext<'input> = BaseParserRuleContext<'input,FieldAccessContextExt<'input>>;

#[derive(Clone)]
pub struct FieldAccessContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for FieldAccessContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for FieldAccessContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldAccess(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_fieldAccess(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldAccessContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldAccess }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldAccess }
}
antlr_rust::tid!{FieldAccessContextExt<'a>}

impl<'input> FieldAccessContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldAccessContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldAccessContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldAccessContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<FieldAccessContextExt<'input>>{

fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldAccessContextAttrs<'input> for FieldAccessContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldAccess(&mut self,)
	-> Result<Rc<FieldAccessContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldAccessContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 394, RULE_fieldAccess);
        let mut _localctx: Rc<FieldAccessContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2343);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(257,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule primary*/
					recog.base.set_state(2330);
					recog.primary()?;

					recog.base.set_state(2331);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2332);
					recog.identifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2334);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2335);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2336);
					recog.identifier()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2337);
					recog.typeName()?;

					recog.base.set_state(2338);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2339);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2340);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2341);
					recog.identifier()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldAccess_lf_primary ----------------
pub type FieldAccess_lf_primaryContextAll<'input> = FieldAccess_lf_primaryContext<'input>;


pub type FieldAccess_lf_primaryContext<'input> = BaseParserRuleContext<'input,FieldAccess_lf_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct FieldAccess_lf_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for FieldAccess_lf_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for FieldAccess_lf_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldAccess_lf_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_fieldAccess_lf_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldAccess_lf_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldAccess_lf_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldAccess_lf_primary }
}
antlr_rust::tid!{FieldAccess_lf_primaryContextExt<'a>}

impl<'input> FieldAccess_lf_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldAccess_lf_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldAccess_lf_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldAccess_lf_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<FieldAccess_lf_primaryContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldAccess_lf_primaryContextAttrs<'input> for FieldAccess_lf_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldAccess_lf_primary(&mut self,)
	-> Result<Rc<FieldAccess_lf_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldAccess_lf_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 396, RULE_fieldAccess_lf_primary);
        let mut _localctx: Rc<FieldAccess_lf_primaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2345);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(2346);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldAccess_lfno_primary ----------------
pub type FieldAccess_lfno_primaryContextAll<'input> = FieldAccess_lfno_primaryContext<'input>;


pub type FieldAccess_lfno_primaryContext<'input> = BaseParserRuleContext<'input,FieldAccess_lfno_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct FieldAccess_lfno_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for FieldAccess_lfno_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for FieldAccess_lfno_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldAccess_lfno_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_fieldAccess_lfno_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldAccess_lfno_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldAccess_lfno_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldAccess_lfno_primary }
}
antlr_rust::tid!{FieldAccess_lfno_primaryContextExt<'a>}

impl<'input> FieldAccess_lfno_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldAccess_lfno_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldAccess_lfno_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldAccess_lfno_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<FieldAccess_lfno_primaryContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldAccess_lfno_primaryContextAttrs<'input> for FieldAccess_lfno_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldAccess_lfno_primary(&mut self,)
	-> Result<Rc<FieldAccess_lfno_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldAccess_lfno_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 398, RULE_fieldAccess_lfno_primary);
        let mut _localctx: Rc<FieldAccess_lfno_primaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2357);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 SUPER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2348);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2349);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2350);
					recog.identifier()?;

					}
				}

			 EXPORTS | MODULE | OPEN | OPERNS | PROVIDES | REQUIRES | TO | USES |
			 WITH | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2351);
					recog.typeName()?;

					recog.base.set_state(2352);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2353);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2354);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2355);
					recog.identifier()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayAccess ----------------
pub type ArrayAccessContextAll<'input> = ArrayAccessContext<'input>;


pub type ArrayAccessContext<'input> = BaseParserRuleContext<'input,ArrayAccessContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayAccessContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ArrayAccessContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ArrayAccessContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayAccess(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_arrayAccess(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayAccessContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayAccess }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayAccess }
}
antlr_rust::tid!{ArrayAccessContextExt<'a>}

impl<'input> ArrayAccessContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayAccessContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayAccessContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayAccessContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ArrayAccessContextExt<'input>>{

fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token LBRACK in current rule
fn LBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token LBRACK is less or equal than `i`.
fn LBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, i)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token RBRACK in current rule
fn RBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token RBRACK is less or equal than `i`.
fn RBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, i)
}
fn primaryNoNewArray_lfno_arrayAccess(&self) -> Option<Rc<PrimaryNoNewArray_lfno_arrayAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primaryNoNewArray_lf_arrayAccess_all(&self) ->  Vec<Rc<PrimaryNoNewArray_lf_arrayAccessContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn primaryNoNewArray_lf_arrayAccess(&self, i: usize) -> Option<Rc<PrimaryNoNewArray_lf_arrayAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ArrayAccessContextAttrs<'input> for ArrayAccessContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayAccess(&mut self,)
	-> Result<Rc<ArrayAccessContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayAccessContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 400, RULE_arrayAccess);
        let mut _localctx: Rc<ArrayAccessContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2369);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(259,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2359);
					recog.expressionName()?;

					recog.base.set_state(2360);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2361);
					recog.expression()?;

					recog.base.set_state(2362);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule primaryNoNewArray_lfno_arrayAccess*/
					recog.base.set_state(2364);
					recog.primaryNoNewArray_lfno_arrayAccess()?;

					recog.base.set_state(2365);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2366);
					recog.expression()?;

					recog.base.set_state(2367);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2378);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==LBRACK {
				{
				{
				/*InvokeRule primaryNoNewArray_lf_arrayAccess*/
				recog.base.set_state(2371);
				recog.primaryNoNewArray_lf_arrayAccess()?;

				recog.base.set_state(2372);
				recog.base.match_token(LBRACK,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(2373);
				recog.expression()?;

				recog.base.set_state(2374);
				recog.base.match_token(RBRACK,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2380);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayAccess_lf_primary ----------------
pub type ArrayAccess_lf_primaryContextAll<'input> = ArrayAccess_lf_primaryContext<'input>;


pub type ArrayAccess_lf_primaryContext<'input> = BaseParserRuleContext<'input,ArrayAccess_lf_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayAccess_lf_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ArrayAccess_lf_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ArrayAccess_lf_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayAccess_lf_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_arrayAccess_lf_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayAccess_lf_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayAccess_lf_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayAccess_lf_primary }
}
antlr_rust::tid!{ArrayAccess_lf_primaryContextExt<'a>}

impl<'input> ArrayAccess_lf_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayAccess_lf_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayAccess_lf_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayAccess_lf_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ArrayAccess_lf_primaryContextExt<'input>>{

fn primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary(&self) -> Option<Rc<PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token LBRACK in current rule
fn LBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token LBRACK is less or equal than `i`.
fn LBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, i)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token RBRACK in current rule
fn RBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token RBRACK is less or equal than `i`.
fn RBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, i)
}
fn primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary_all(&self) ->  Vec<Rc<PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary(&self, i: usize) -> Option<Rc<PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ArrayAccess_lf_primaryContextAttrs<'input> for ArrayAccess_lf_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayAccess_lf_primary(&mut self,)
	-> Result<Rc<ArrayAccess_lf_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayAccess_lf_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 402, RULE_arrayAccess_lf_primary);
        let mut _localctx: Rc<ArrayAccess_lf_primaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary*/
			recog.base.set_state(2381);
			recog.primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary()?;

			recog.base.set_state(2382);
			recog.base.match_token(LBRACK,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2383);
			recog.expression()?;

			recog.base.set_state(2384);
			recog.base.match_token(RBRACK,&mut recog.err_handler)?;

			}
			recog.base.set_state(2393);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(261,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary*/
					recog.base.set_state(2386);
					recog.primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary()?;

					recog.base.set_state(2387);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2388);
					recog.expression()?;

					recog.base.set_state(2389);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2395);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(261,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayAccess_lfno_primary ----------------
pub type ArrayAccess_lfno_primaryContextAll<'input> = ArrayAccess_lfno_primaryContext<'input>;


pub type ArrayAccess_lfno_primaryContext<'input> = BaseParserRuleContext<'input,ArrayAccess_lfno_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayAccess_lfno_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ArrayAccess_lfno_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ArrayAccess_lfno_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayAccess_lfno_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_arrayAccess_lfno_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayAccess_lfno_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayAccess_lfno_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayAccess_lfno_primary }
}
antlr_rust::tid!{ArrayAccess_lfno_primaryContextExt<'a>}

impl<'input> ArrayAccess_lfno_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayAccess_lfno_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayAccess_lfno_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayAccess_lfno_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ArrayAccess_lfno_primaryContextExt<'input>>{

fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token LBRACK in current rule
fn LBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token LBRACK is less or equal than `i`.
fn LBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, i)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token RBRACK in current rule
fn RBRACK_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RBRACK, starting from 0.
/// Returns `None` if number of children corresponding to token RBRACK is less or equal than `i`.
fn RBRACK(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, i)
}
fn primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary(&self) -> Option<Rc<PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary_all(&self) ->  Vec<Rc<PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary(&self, i: usize) -> Option<Rc<PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ArrayAccess_lfno_primaryContextAttrs<'input> for ArrayAccess_lfno_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayAccess_lfno_primary(&mut self,)
	-> Result<Rc<ArrayAccess_lfno_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayAccess_lfno_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 404, RULE_arrayAccess_lfno_primary);
        let mut _localctx: Rc<ArrayAccess_lfno_primaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2406);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(262,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2396);
					recog.expressionName()?;

					recog.base.set_state(2397);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2398);
					recog.expression()?;

					recog.base.set_state(2399);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary*/
					recog.base.set_state(2401);
					recog.primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary()?;

					recog.base.set_state(2402);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2403);
					recog.expression()?;

					recog.base.set_state(2404);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2415);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(263,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary*/
					recog.base.set_state(2408);
					recog.primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary()?;

					recog.base.set_state(2409);
					recog.base.match_token(LBRACK,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2410);
					recog.expression()?;

					recog.base.set_state(2411);
					recog.base.match_token(RBRACK,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2417);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(263,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodInvocation ----------------
pub type MethodInvocationContextAll<'input> = MethodInvocationContext<'input>;


pub type MethodInvocationContext<'input> = BaseParserRuleContext<'input,MethodInvocationContextExt<'input>>;

#[derive(Clone)]
pub struct MethodInvocationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodInvocationContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodInvocationContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodInvocation(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodInvocation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodInvocationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodInvocation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodInvocation }
}
antlr_rust::tid!{MethodInvocationContextExt<'a>}

impl<'input> MethodInvocationContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodInvocationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodInvocationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodInvocationContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodInvocationContextExt<'input>>{

fn methodName(&self) -> Option<Rc<MethodNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}

}

impl<'input> MethodInvocationContextAttrs<'input> for MethodInvocationContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodInvocation(&mut self,)
	-> Result<Rc<MethodInvocationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodInvocationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 406, RULE_methodInvocation);
        let mut _localctx: Rc<MethodInvocationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2487);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(275,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule methodName*/
					recog.base.set_state(2418);
					recog.methodName()?;

					recog.base.set_state(2419);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2421);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2420);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2423);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2425);
					recog.typeName()?;

					recog.base.set_state(2426);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2428);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2427);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2430);
					recog.identifier()?;

					recog.base.set_state(2431);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2433);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2432);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2435);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2437);
					recog.expressionName()?;

					recog.base.set_state(2438);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2440);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2439);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2442);
					recog.identifier()?;

					recog.base.set_state(2443);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2445);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2444);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2447);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule primary*/
					recog.base.set_state(2449);
					recog.primary()?;

					recog.base.set_state(2450);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2452);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2451);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2454);
					recog.identifier()?;

					recog.base.set_state(2455);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2457);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2456);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2459);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(2461);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2462);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2464);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2463);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2466);
					recog.identifier()?;

					recog.base.set_state(2467);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2469);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2468);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2471);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2473);
					recog.typeName()?;

					recog.base.set_state(2474);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2475);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2476);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2478);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2477);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2480);
					recog.identifier()?;

					recog.base.set_state(2481);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2483);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2482);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2485);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodInvocation_lf_primary ----------------
pub type MethodInvocation_lf_primaryContextAll<'input> = MethodInvocation_lf_primaryContext<'input>;


pub type MethodInvocation_lf_primaryContext<'input> = BaseParserRuleContext<'input,MethodInvocation_lf_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct MethodInvocation_lf_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodInvocation_lf_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodInvocation_lf_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodInvocation_lf_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodInvocation_lf_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodInvocation_lf_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodInvocation_lf_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodInvocation_lf_primary }
}
antlr_rust::tid!{MethodInvocation_lf_primaryContextExt<'a>}

impl<'input> MethodInvocation_lf_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodInvocation_lf_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodInvocation_lf_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodInvocation_lf_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodInvocation_lf_primaryContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodInvocation_lf_primaryContextAttrs<'input> for MethodInvocation_lf_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodInvocation_lf_primary(&mut self,)
	-> Result<Rc<MethodInvocation_lf_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodInvocation_lf_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 408, RULE_methodInvocation_lf_primary);
        let mut _localctx: Rc<MethodInvocation_lf_primaryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2489);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(2491);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeArguments*/
				recog.base.set_state(2490);
				recog.typeArguments()?;

				}
			}

			/*InvokeRule identifier*/
			recog.base.set_state(2493);
			recog.identifier()?;

			recog.base.set_state(2494);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2496);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
				{
				/*InvokeRule argumentList*/
				recog.base.set_state(2495);
				recog.argumentList()?;

				}
			}

			recog.base.set_state(2498);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodInvocation_lfno_primary ----------------
pub type MethodInvocation_lfno_primaryContextAll<'input> = MethodInvocation_lfno_primaryContext<'input>;


pub type MethodInvocation_lfno_primaryContext<'input> = BaseParserRuleContext<'input,MethodInvocation_lfno_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct MethodInvocation_lfno_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodInvocation_lfno_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodInvocation_lfno_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodInvocation_lfno_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodInvocation_lfno_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodInvocation_lfno_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodInvocation_lfno_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodInvocation_lfno_primary }
}
antlr_rust::tid!{MethodInvocation_lfno_primaryContextExt<'a>}

impl<'input> MethodInvocation_lfno_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodInvocation_lfno_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodInvocation_lfno_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodInvocation_lfno_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodInvocation_lfno_primaryContextExt<'input>>{

fn methodName(&self) -> Option<Rc<MethodNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn argumentList(&self) -> Option<Rc<ArgumentListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}

}

impl<'input> MethodInvocation_lfno_primaryContextAttrs<'input> for MethodInvocation_lfno_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodInvocation_lfno_primary(&mut self,)
	-> Result<Rc<MethodInvocation_lfno_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodInvocation_lfno_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 410, RULE_methodInvocation_lfno_primary);
        let mut _localctx: Rc<MethodInvocation_lfno_primaryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2557);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(287,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule methodName*/
					recog.base.set_state(2500);
					recog.methodName()?;

					recog.base.set_state(2501);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2503);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2502);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2505);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2507);
					recog.typeName()?;

					recog.base.set_state(2508);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2510);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2509);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2512);
					recog.identifier()?;

					recog.base.set_state(2513);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2515);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2514);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2517);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2519);
					recog.expressionName()?;

					recog.base.set_state(2520);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2522);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2521);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2524);
					recog.identifier()?;

					recog.base.set_state(2525);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2527);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2526);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2529);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2531);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2532);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2534);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2533);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2536);
					recog.identifier()?;

					recog.base.set_state(2537);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2539);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2538);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2541);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2543);
					recog.typeName()?;

					recog.base.set_state(2544);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2545);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2546);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2548);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2547);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2550);
					recog.identifier()?;

					recog.base.set_state(2551);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2553);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 33)) & !0x3f) == 0 && ((1usize << (_la - 33)) & ((1usize << (NEW - 33)) | (1usize << (OPEN - 33)) | (1usize << (OPERNS - 33)) | (1usize << (PROVIDES - 33)) | (1usize << (REQUIRES - 33)) | (1usize << (SHORT - 33)) | (1usize << (SUPER - 33)) | (1usize << (THIS - 33)) | (1usize << (TO - 33)) | (1usize << (USES - 33)) | (1usize << (VOID - 33)) | (1usize << (WITH - 33)) | (1usize << (IntegerLiteral - 33)) | (1usize << (FloatingPointLiteral - 33)) | (1usize << (BooleanLiteral - 33)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (CharacterLiteral - 65)) | (1usize << (StringLiteral - 65)) | (1usize << (NullLiteral - 65)) | (1usize << (LPAREN - 65)) | (1usize << (AT - 65)) | (1usize << (BANG - 65)) | (1usize << (TILDE - 65)) | (1usize << (INC - 65)) | (1usize << (DEC - 65)) | (1usize << (ADD - 65)))) != 0) || _la==SUB || _la==Identifier {
						{
						/*InvokeRule argumentList*/
						recog.base.set_state(2552);
						recog.argumentList()?;

						}
					}

					recog.base.set_state(2555);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- argumentList ----------------
pub type ArgumentListContextAll<'input> = ArgumentListContext<'input>;


pub type ArgumentListContext<'input> = BaseParserRuleContext<'input,ArgumentListContextExt<'input>>;

#[derive(Clone)]
pub struct ArgumentListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ArgumentListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ArgumentListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_argumentList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_argumentList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArgumentListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_argumentList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_argumentList }
}
antlr_rust::tid!{ArgumentListContextExt<'a>}

impl<'input> ArgumentListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArgumentListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArgumentListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArgumentListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ArgumentListContextExt<'input>>{

fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ArgumentListContextAttrs<'input> for ArgumentListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn argumentList(&mut self,)
	-> Result<Rc<ArgumentListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArgumentListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 412, RULE_argumentList);
        let mut _localctx: Rc<ArgumentListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(2559);
			recog.expression()?;

			recog.base.set_state(2564);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(2560);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(2561);
				recog.expression()?;

				}
				}
				recog.base.set_state(2566);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodReference ----------------
pub type MethodReferenceContextAll<'input> = MethodReferenceContext<'input>;


pub type MethodReferenceContext<'input> = BaseParserRuleContext<'input,MethodReferenceContextExt<'input>>;

#[derive(Clone)]
pub struct MethodReferenceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodReferenceContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodReferenceContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodReference(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodReference(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodReferenceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodReference }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodReference }
}
antlr_rust::tid!{MethodReferenceContextExt<'a>}

impl<'input> MethodReferenceContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodReferenceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodReferenceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodReferenceContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodReferenceContextExt<'input>>{

fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLONCOLON
/// Returns `None` if there is no child corresponding to token COLONCOLON
fn COLONCOLON(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COLONCOLON, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token NEW
/// Returns `None` if there is no child corresponding to token NEW
fn NEW(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(NEW, 0)
}
fn arrayType(&self) -> Option<Rc<ArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodReferenceContextAttrs<'input> for MethodReferenceContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodReference(&mut self,)
	-> Result<Rc<MethodReferenceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodReferenceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 414, RULE_methodReference);
        let mut _localctx: Rc<MethodReferenceContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2614);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(295,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2567);
					recog.expressionName()?;

					recog.base.set_state(2568);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2570);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2569);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2572);
					recog.identifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule referenceType*/
					recog.base.set_state(2574);
					recog.referenceType()?;

					recog.base.set_state(2575);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2577);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2576);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2579);
					recog.identifier()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule primary*/
					recog.base.set_state(2581);
					recog.primary()?;

					recog.base.set_state(2582);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2584);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2583);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2586);
					recog.identifier()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2588);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2589);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2591);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2590);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2593);
					recog.identifier()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2594);
					recog.typeName()?;

					recog.base.set_state(2595);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2596);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2597);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2599);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2598);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2601);
					recog.identifier()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule classType*/
					recog.base.set_state(2603);
					recog.classType()?;

					recog.base.set_state(2604);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2606);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2605);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2608);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule arrayType*/
					recog.base.set_state(2610);
					recog.arrayType()?;

					recog.base.set_state(2611);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2612);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodReference_lf_primary ----------------
pub type MethodReference_lf_primaryContextAll<'input> = MethodReference_lf_primaryContext<'input>;


pub type MethodReference_lf_primaryContext<'input> = BaseParserRuleContext<'input,MethodReference_lf_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct MethodReference_lf_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodReference_lf_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodReference_lf_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodReference_lf_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodReference_lf_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodReference_lf_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodReference_lf_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodReference_lf_primary }
}
antlr_rust::tid!{MethodReference_lf_primaryContextExt<'a>}

impl<'input> MethodReference_lf_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodReference_lf_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodReference_lf_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodReference_lf_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodReference_lf_primaryContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COLONCOLON
/// Returns `None` if there is no child corresponding to token COLONCOLON
fn COLONCOLON(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COLONCOLON, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodReference_lf_primaryContextAttrs<'input> for MethodReference_lf_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodReference_lf_primary(&mut self,)
	-> Result<Rc<MethodReference_lf_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodReference_lf_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 416, RULE_methodReference_lf_primary);
        let mut _localctx: Rc<MethodReference_lf_primaryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2616);
			recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

			recog.base.set_state(2618);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LT {
				{
				/*InvokeRule typeArguments*/
				recog.base.set_state(2617);
				recog.typeArguments()?;

				}
			}

			/*InvokeRule identifier*/
			recog.base.set_state(2620);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodReference_lfno_primary ----------------
pub type MethodReference_lfno_primaryContextAll<'input> = MethodReference_lfno_primaryContext<'input>;


pub type MethodReference_lfno_primaryContext<'input> = BaseParserRuleContext<'input,MethodReference_lfno_primaryContextExt<'input>>;

#[derive(Clone)]
pub struct MethodReference_lfno_primaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MethodReference_lfno_primaryContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MethodReference_lfno_primaryContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodReference_lfno_primary(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_methodReference_lfno_primary(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodReference_lfno_primaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodReference_lfno_primary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodReference_lfno_primary }
}
antlr_rust::tid!{MethodReference_lfno_primaryContextExt<'a>}

impl<'input> MethodReference_lfno_primaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodReference_lfno_primaryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodReference_lfno_primaryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodReference_lfno_primaryContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MethodReference_lfno_primaryContextExt<'input>>{

fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLONCOLON
/// Returns `None` if there is no child corresponding to token COLONCOLON
fn COLONCOLON(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COLONCOLON, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
fn typeName(&self) -> Option<Rc<TypeNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn classType(&self) -> Option<Rc<ClassTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token NEW
/// Returns `None` if there is no child corresponding to token NEW
fn NEW(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(NEW, 0)
}
fn arrayType(&self) -> Option<Rc<ArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodReference_lfno_primaryContextAttrs<'input> for MethodReference_lfno_primaryContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodReference_lfno_primary(&mut self,)
	-> Result<Rc<MethodReference_lfno_primaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodReference_lfno_primaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 418, RULE_methodReference_lfno_primary);
        let mut _localctx: Rc<MethodReference_lfno_primaryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2662);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(302,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2622);
					recog.expressionName()?;

					recog.base.set_state(2623);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2625);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2624);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2627);
					recog.identifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule referenceType*/
					recog.base.set_state(2629);
					recog.referenceType()?;

					recog.base.set_state(2630);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2632);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2631);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2634);
					recog.identifier()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2636);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2637);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2639);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2638);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2641);
					recog.identifier()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule typeName*/
					recog.base.set_state(2642);
					recog.typeName()?;

					recog.base.set_state(2643);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(2644);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2645);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2647);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2646);
						recog.typeArguments()?;

						}
					}

					/*InvokeRule identifier*/
					recog.base.set_state(2649);
					recog.identifier()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule classType*/
					recog.base.set_state(2651);
					recog.classType()?;

					recog.base.set_state(2652);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2654);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LT {
						{
						/*InvokeRule typeArguments*/
						recog.base.set_state(2653);
						recog.typeArguments()?;

						}
					}

					recog.base.set_state(2656);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule arrayType*/
					recog.base.set_state(2658);
					recog.arrayType()?;

					recog.base.set_state(2659);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					recog.base.set_state(2660);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayCreationExpression ----------------
pub type ArrayCreationExpressionContextAll<'input> = ArrayCreationExpressionContext<'input>;


pub type ArrayCreationExpressionContext<'input> = BaseParserRuleContext<'input,ArrayCreationExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayCreationExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ArrayCreationExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ArrayCreationExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayCreationExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_arrayCreationExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayCreationExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayCreationExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayCreationExpression }
}
antlr_rust::tid!{ArrayCreationExpressionContextExt<'a>}

impl<'input> ArrayCreationExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayCreationExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayCreationExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayCreationExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ArrayCreationExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token NEW
/// Returns `None` if there is no child corresponding to token NEW
fn NEW(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(NEW, 0)
}
fn primitiveType(&self) -> Option<Rc<PrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dimExprs(&self) -> Option<Rc<DimExprsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dims(&self) -> Option<Rc<DimsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classOrInterfaceType(&self) -> Option<Rc<ClassOrInterfaceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayInitializer(&self) -> Option<Rc<ArrayInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayCreationExpressionContextAttrs<'input> for ArrayCreationExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayCreationExpression(&mut self,)
	-> Result<Rc<ArrayCreationExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayCreationExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 420, RULE_arrayCreationExpression);
        let mut _localctx: Rc<ArrayCreationExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2686);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(305,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2664);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					/*InvokeRule primitiveType*/
					recog.base.set_state(2665);
					recog.primitiveType()?;

					/*InvokeRule dimExprs*/
					recog.base.set_state(2666);
					recog.dimExprs()?;

					recog.base.set_state(2668);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(303,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule dims*/
							recog.base.set_state(2667);
							recog.dims()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2670);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					/*InvokeRule classOrInterfaceType*/
					recog.base.set_state(2671);
					recog.classOrInterfaceType()?;

					/*InvokeRule dimExprs*/
					recog.base.set_state(2672);
					recog.dimExprs()?;

					recog.base.set_state(2674);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(304,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule dims*/
							recog.base.set_state(2673);
							recog.dims()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2676);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					/*InvokeRule primitiveType*/
					recog.base.set_state(2677);
					recog.primitiveType()?;

					/*InvokeRule dims*/
					recog.base.set_state(2678);
					recog.dims()?;

					/*InvokeRule arrayInitializer*/
					recog.base.set_state(2679);
					recog.arrayInitializer()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2681);
					recog.base.match_token(NEW,&mut recog.err_handler)?;

					/*InvokeRule classOrInterfaceType*/
					recog.base.set_state(2682);
					recog.classOrInterfaceType()?;

					/*InvokeRule dims*/
					recog.base.set_state(2683);
					recog.dims()?;

					/*InvokeRule arrayInitializer*/
					recog.base.set_state(2684);
					recog.arrayInitializer()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dimExprs ----------------
pub type DimExprsContextAll<'input> = DimExprsContext<'input>;


pub type DimExprsContext<'input> = BaseParserRuleContext<'input,DimExprsContextExt<'input>>;

#[derive(Clone)]
pub struct DimExprsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for DimExprsContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for DimExprsContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_dimExprs(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_dimExprs(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DimExprsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dimExprs }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dimExprs }
}
antlr_rust::tid!{DimExprsContextExt<'a>}

impl<'input> DimExprsContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DimExprsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DimExprsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DimExprsContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<DimExprsContextExt<'input>>{

fn dimExpr_all(&self) ->  Vec<Rc<DimExprContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn dimExpr(&self, i: usize) -> Option<Rc<DimExprContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> DimExprsContextAttrs<'input> for DimExprsContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dimExprs(&mut self,)
	-> Result<Rc<DimExprsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DimExprsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 422, RULE_dimExprs);
        let mut _localctx: Rc<DimExprsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2689); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule dimExpr*/
					recog.base.set_state(2688);
					recog.dimExpr()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(2691); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(306,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dimExpr ----------------
pub type DimExprContextAll<'input> = DimExprContext<'input>;


pub type DimExprContext<'input> = BaseParserRuleContext<'input,DimExprContextExt<'input>>;

#[derive(Clone)]
pub struct DimExprContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for DimExprContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for DimExprContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_dimExpr(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_dimExpr(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DimExprContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dimExpr }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dimExpr }
}
antlr_rust::tid!{DimExprContextExt<'a>}

impl<'input> DimExprContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DimExprContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DimExprContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DimExprContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<DimExprContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACK
/// Returns `None` if there is no child corresponding to token LBRACK
fn LBRACK(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RBRACK
/// Returns `None` if there is no child corresponding to token RBRACK
fn RBRACK(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RBRACK, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> DimExprContextAttrs<'input> for DimExprContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dimExpr(&mut self,)
	-> Result<Rc<DimExprContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DimExprContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 424, RULE_dimExpr);
        let mut _localctx: Rc<DimExprContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2696);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(2693);
				recog.annotation()?;

				}
				}
				recog.base.set_state(2698);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2699);
			recog.base.match_token(LBRACK,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2700);
			recog.expression()?;

			recog.base.set_state(2701);
			recog.base.match_token(RBRACK,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constantExpression ----------------
pub type ConstantExpressionContextAll<'input> = ConstantExpressionContext<'input>;


pub type ConstantExpressionContext<'input> = BaseParserRuleContext<'input,ConstantExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ConstantExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ConstantExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ConstantExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constantExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_constantExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstantExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constantExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constantExpression }
}
antlr_rust::tid!{ConstantExpressionContextExt<'a>}

impl<'input> ConstantExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstantExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstantExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstantExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ConstantExpressionContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstantExpressionContextAttrs<'input> for ConstantExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constantExpression(&mut self,)
	-> Result<Rc<ConstantExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstantExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 426, RULE_constantExpression);
        let mut _localctx: Rc<ConstantExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(2703);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expression ----------------
pub type ExpressionContextAll<'input> = ExpressionContext<'input>;


pub type ExpressionContext<'input> = BaseParserRuleContext<'input,ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_expression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_expression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::tid!{ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ExpressionContextExt<'input>>{

fn lambdaExpression(&self) -> Option<Rc<LambdaExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentExpression(&self) -> Option<Rc<AssignmentExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expression(&mut self,)
	-> Result<Rc<ExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 428, RULE_expression);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2707);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(308,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule lambdaExpression*/
					recog.base.set_state(2705);
					recog.lambdaExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule assignmentExpression*/
					recog.base.set_state(2706);
					recog.assignmentExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaExpression ----------------
pub type LambdaExpressionContextAll<'input> = LambdaExpressionContext<'input>;


pub type LambdaExpressionContext<'input> = BaseParserRuleContext<'input,LambdaExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for LambdaExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for LambdaExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_lambdaExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LambdaExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaExpression }
}
antlr_rust::tid!{LambdaExpressionContextExt<'a>}

impl<'input> LambdaExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<LambdaExpressionContextExt<'input>>{

fn lambdaParameters(&self) -> Option<Rc<LambdaParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn lambdaBody(&self) -> Option<Rc<LambdaBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LambdaExpressionContextAttrs<'input> for LambdaExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaExpression(&mut self,)
	-> Result<Rc<LambdaExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 430, RULE_lambdaExpression);
        let mut _localctx: Rc<LambdaExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule lambdaParameters*/
			recog.base.set_state(2709);
			recog.lambdaParameters()?;

			recog.base.set_state(2710);
			recog.base.match_token(ARROW,&mut recog.err_handler)?;

			/*InvokeRule lambdaBody*/
			recog.base.set_state(2711);
			recog.lambdaBody()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaParameters ----------------
pub type LambdaParametersContextAll<'input> = LambdaParametersContext<'input>;


pub type LambdaParametersContext<'input> = BaseParserRuleContext<'input,LambdaParametersContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for LambdaParametersContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for LambdaParametersContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaParameters(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_lambdaParameters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LambdaParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaParameters }
}
antlr_rust::tid!{LambdaParametersContextExt<'a>}

impl<'input> LambdaParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaParametersContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<LambdaParametersContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn formalParameterList(&self) -> Option<Rc<FormalParameterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn inferredFormalParameterList(&self) -> Option<Rc<InferredFormalParameterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LambdaParametersContextAttrs<'input> for LambdaParametersContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaParameters(&mut self,)
	-> Result<Rc<LambdaParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 432, RULE_lambdaParameters);
        let mut _localctx: Rc<LambdaParametersContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2723);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(310,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule identifier*/
					recog.base.set_state(2713);
					recog.identifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2714);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2716);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << BOOLEAN) | (1usize << BYTE) | (1usize << CHAR) | (1usize << DOUBLE) | (1usize << EXPORTS) | (1usize << FINAL) | (1usize << FLOAT) | (1usize << INT) | (1usize << LONG) | (1usize << MODULE))) != 0) || ((((_la - 34)) & !0x3f) == 0 && ((1usize << (_la - 34)) & ((1usize << (OPEN - 34)) | (1usize << (OPERNS - 34)) | (1usize << (PROVIDES - 34)) | (1usize << (REQUIRES - 34)) | (1usize << (SHORT - 34)) | (1usize << (TO - 34)) | (1usize << (USES - 34)) | (1usize << (WITH - 34)))) != 0) || _la==AT || _la==Identifier {
						{
						/*InvokeRule formalParameterList*/
						recog.base.set_state(2715);
						recog.formalParameterList()?;

						}
					}

					recog.base.set_state(2718);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2719);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule inferredFormalParameterList*/
					recog.base.set_state(2720);
					recog.inferredFormalParameterList()?;

					recog.base.set_state(2721);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- inferredFormalParameterList ----------------
pub type InferredFormalParameterListContextAll<'input> = InferredFormalParameterListContext<'input>;


pub type InferredFormalParameterListContext<'input> = BaseParserRuleContext<'input,InferredFormalParameterListContextExt<'input>>;

#[derive(Clone)]
pub struct InferredFormalParameterListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InferredFormalParameterListContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InferredFormalParameterListContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_inferredFormalParameterList(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_inferredFormalParameterList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InferredFormalParameterListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inferredFormalParameterList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inferredFormalParameterList }
}
antlr_rust::tid!{InferredFormalParameterListContextExt<'a>}

impl<'input> InferredFormalParameterListContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InferredFormalParameterListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InferredFormalParameterListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InferredFormalParameterListContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InferredFormalParameterListContextExt<'input>>{

fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> InferredFormalParameterListContextAttrs<'input> for InferredFormalParameterListContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn inferredFormalParameterList(&mut self,)
	-> Result<Rc<InferredFormalParameterListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InferredFormalParameterListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 434, RULE_inferredFormalParameterList);
        let mut _localctx: Rc<InferredFormalParameterListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(2725);
			recog.identifier()?;

			recog.base.set_state(2730);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(2726);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(2727);
				recog.identifier()?;

				}
				}
				recog.base.set_state(2732);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaBody ----------------
pub type LambdaBodyContextAll<'input> = LambdaBodyContext<'input>;


pub type LambdaBodyContext<'input> = BaseParserRuleContext<'input,LambdaBodyContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for LambdaBodyContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for LambdaBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaBody(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_lambdaBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LambdaBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaBody }
}
antlr_rust::tid!{LambdaBodyContextExt<'a>}

impl<'input> LambdaBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaBodyContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<LambdaBodyContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LambdaBodyContextAttrs<'input> for LambdaBodyContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaBody(&mut self,)
	-> Result<Rc<LambdaBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 436, RULE_lambdaBody);
        let mut _localctx: Rc<LambdaBodyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2735);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN | BYTE | CHAR | DOUBLE | EXPORTS | FLOAT | INT | LONG | MODULE |
			 NEW | OPEN | OPERNS | PROVIDES | REQUIRES | SHORT | SUPER | THIS | TO |
			 USES | VOID | WITH | IntegerLiteral | FloatingPointLiteral | BooleanLiteral |
			 CharacterLiteral | StringLiteral | NullLiteral | LPAREN | AT | BANG |
			 TILDE | INC | DEC | ADD | SUB | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expression*/
					recog.base.set_state(2733);
					recog.expression()?;

					}
				}

			 LBRACE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule block*/
					recog.base.set_state(2734);
					recog.block()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentExpression ----------------
pub type AssignmentExpressionContextAll<'input> = AssignmentExpressionContext<'input>;


pub type AssignmentExpressionContext<'input> = BaseParserRuleContext<'input,AssignmentExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AssignmentExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AssignmentExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignmentExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_assignmentExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AssignmentExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentExpression }
}
antlr_rust::tid!{AssignmentExpressionContextExt<'a>}

impl<'input> AssignmentExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AssignmentExpressionContextExt<'input>>{

fn conditionalExpression(&self) -> Option<Rc<ConditionalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignment(&self) -> Option<Rc<AssignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AssignmentExpressionContextAttrs<'input> for AssignmentExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentExpression(&mut self,)
	-> Result<Rc<AssignmentExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 438, RULE_assignmentExpression);
        let mut _localctx: Rc<AssignmentExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2739);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(313,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule conditionalExpression*/
					recog.base.set_state(2737);
					recog.conditionalExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule assignment*/
					recog.base.set_state(2738);
					recog.assignment()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignment ----------------
pub type AssignmentContextAll<'input> = AssignmentContext<'input>;


pub type AssignmentContext<'input> = BaseParserRuleContext<'input,AssignmentContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AssignmentContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AssignmentContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignment(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_assignment(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AssignmentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignment }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignment }
}
antlr_rust::tid!{AssignmentContextExt<'a>}

impl<'input> AssignmentContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AssignmentContextExt<'input>>{

fn leftHandSide(&self) -> Option<Rc<LeftHandSideContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentOperator(&self) -> Option<Rc<AssignmentOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AssignmentContextAttrs<'input> for AssignmentContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignment(&mut self,)
	-> Result<Rc<AssignmentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 440, RULE_assignment);
        let mut _localctx: Rc<AssignmentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule leftHandSide*/
			recog.base.set_state(2741);
			recog.leftHandSide()?;

			/*InvokeRule assignmentOperator*/
			recog.base.set_state(2742);
			recog.assignmentOperator()?;

			/*InvokeRule expression*/
			recog.base.set_state(2743);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- leftHandSide ----------------
pub type LeftHandSideContextAll<'input> = LeftHandSideContext<'input>;


pub type LeftHandSideContext<'input> = BaseParserRuleContext<'input,LeftHandSideContextExt<'input>>;

#[derive(Clone)]
pub struct LeftHandSideContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for LeftHandSideContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for LeftHandSideContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_leftHandSide(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_leftHandSide(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LeftHandSideContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_leftHandSide }
	//fn type_rule_index() -> usize where Self: Sized { RULE_leftHandSide }
}
antlr_rust::tid!{LeftHandSideContextExt<'a>}

impl<'input> LeftHandSideContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LeftHandSideContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LeftHandSideContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LeftHandSideContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<LeftHandSideContextExt<'input>>{

fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldAccess(&self) -> Option<Rc<FieldAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayAccess(&self) -> Option<Rc<ArrayAccessContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LeftHandSideContextAttrs<'input> for LeftHandSideContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn leftHandSide(&mut self,)
	-> Result<Rc<LeftHandSideContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LeftHandSideContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 442, RULE_leftHandSide);
        let mut _localctx: Rc<LeftHandSideContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2748);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(314,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2745);
					recog.expressionName()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule fieldAccess*/
					recog.base.set_state(2746);
					recog.fieldAccess()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule arrayAccess*/
					recog.base.set_state(2747);
					recog.arrayAccess()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentOperator ----------------
pub type AssignmentOperatorContextAll<'input> = AssignmentOperatorContext<'input>;


pub type AssignmentOperatorContext<'input> = BaseParserRuleContext<'input,AssignmentOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AssignmentOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AssignmentOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignmentOperator(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_assignmentOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AssignmentOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentOperator }
}
antlr_rust::tid!{AssignmentOperatorContextExt<'a>}

impl<'input> AssignmentOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentOperatorContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AssignmentOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ASSIGN
/// Returns `None` if there is no child corresponding to token ASSIGN
fn ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token MUL_ASSIGN
/// Returns `None` if there is no child corresponding to token MUL_ASSIGN
fn MUL_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(MUL_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token DIV_ASSIGN
/// Returns `None` if there is no child corresponding to token DIV_ASSIGN
fn DIV_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DIV_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token MOD_ASSIGN
/// Returns `None` if there is no child corresponding to token MOD_ASSIGN
fn MOD_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(MOD_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token ADD_ASSIGN
/// Returns `None` if there is no child corresponding to token ADD_ASSIGN
fn ADD_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ADD_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token SUB_ASSIGN
/// Returns `None` if there is no child corresponding to token SUB_ASSIGN
fn SUB_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SUB_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token LSHIFT_ASSIGN
/// Returns `None` if there is no child corresponding to token LSHIFT_ASSIGN
fn LSHIFT_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LSHIFT_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token RSHIFT_ASSIGN
/// Returns `None` if there is no child corresponding to token RSHIFT_ASSIGN
fn RSHIFT_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RSHIFT_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token URSHIFT_ASSIGN
/// Returns `None` if there is no child corresponding to token URSHIFT_ASSIGN
fn URSHIFT_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(URSHIFT_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token AND_ASSIGN
/// Returns `None` if there is no child corresponding to token AND_ASSIGN
fn AND_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(AND_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token XOR_ASSIGN
/// Returns `None` if there is no child corresponding to token XOR_ASSIGN
fn XOR_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(XOR_ASSIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token OR_ASSIGN
/// Returns `None` if there is no child corresponding to token OR_ASSIGN
fn OR_ASSIGN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(OR_ASSIGN, 0)
}

}

impl<'input> AssignmentOperatorContextAttrs<'input> for AssignmentOperatorContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentOperator(&mut self,)
	-> Result<Rc<AssignmentOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 444, RULE_assignmentOperator);
        let mut _localctx: Rc<AssignmentOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2750);
			_la = recog.base.input.la(1);
			if { !(((((_la - 80)) & !0x3f) == 0 && ((1usize << (_la - 80)) & ((1usize << (ASSIGN - 80)) | (1usize << (ADD_ASSIGN - 80)) | (1usize << (SUB_ASSIGN - 80)) | (1usize << (MUL_ASSIGN - 80)) | (1usize << (DIV_ASSIGN - 80)) | (1usize << (AND_ASSIGN - 80)) | (1usize << (OR_ASSIGN - 80)) | (1usize << (XOR_ASSIGN - 80)) | (1usize << (MOD_ASSIGN - 80)))) != 0) || ((((_la - 112)) & !0x3f) == 0 && ((1usize << (_la - 112)) & ((1usize << (LSHIFT_ASSIGN - 112)) | (1usize << (RSHIFT_ASSIGN - 112)) | (1usize << (URSHIFT_ASSIGN - 112)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- conditionalExpression ----------------
pub type ConditionalExpressionContextAll<'input> = ConditionalExpressionContext<'input>;


pub type ConditionalExpressionContext<'input> = BaseParserRuleContext<'input,ConditionalExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ConditionalExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ConditionalExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ConditionalExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_conditionalExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_conditionalExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConditionalExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conditionalExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conditionalExpression }
}
antlr_rust::tid!{ConditionalExpressionContextExt<'a>}

impl<'input> ConditionalExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConditionalExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConditionalExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConditionalExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ConditionalExpressionContextExt<'input>>{

fn conditionalOrExpression(&self) -> Option<Rc<ConditionalOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token QUESTION
/// Returns `None` if there is no child corresponding to token QUESTION
fn QUESTION(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(QUESTION, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn conditionalExpression(&self) -> Option<Rc<ConditionalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn lambdaExpression(&self) -> Option<Rc<LambdaExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConditionalExpressionContextAttrs<'input> for ConditionalExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn conditionalExpression(&mut self,)
	-> Result<Rc<ConditionalExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConditionalExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 446, RULE_conditionalExpression);
        let mut _localctx: Rc<ConditionalExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2761);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(316,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule conditionalOrExpression*/
					recog.base.set_state(2752);
					recog.conditionalOrExpression_rec(0)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule conditionalOrExpression*/
					recog.base.set_state(2753);
					recog.conditionalOrExpression_rec(0)?;

					recog.base.set_state(2754);
					recog.base.match_token(QUESTION,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2755);
					recog.expression()?;

					recog.base.set_state(2756);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(2759);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(315,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule conditionalExpression*/
							recog.base.set_state(2757);
							recog.conditionalExpression()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule lambdaExpression*/
							recog.base.set_state(2758);
							recog.lambdaExpression()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- conditionalOrExpression ----------------
pub type ConditionalOrExpressionContextAll<'input> = ConditionalOrExpressionContext<'input>;


pub type ConditionalOrExpressionContext<'input> = BaseParserRuleContext<'input,ConditionalOrExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ConditionalOrExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ConditionalOrExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ConditionalOrExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_conditionalOrExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_conditionalOrExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConditionalOrExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conditionalOrExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conditionalOrExpression }
}
antlr_rust::tid!{ConditionalOrExpressionContextExt<'a>}

impl<'input> ConditionalOrExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConditionalOrExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConditionalOrExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConditionalOrExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ConditionalOrExpressionContextExt<'input>>{

fn conditionalAndExpression(&self) -> Option<Rc<ConditionalAndExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn conditionalOrExpression(&self) -> Option<Rc<ConditionalOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OR
/// Returns `None` if there is no child corresponding to token OR
fn OR(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(OR, 0)
}

}

impl<'input> ConditionalOrExpressionContextAttrs<'input> for ConditionalOrExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  conditionalOrExpression(&mut self,)
	-> Result<Rc<ConditionalOrExpressionContextAll<'input>>,ANTLRError> {
		self.conditionalOrExpression_rec(0)
	}

	fn conditionalOrExpression_rec(&mut self, _p: isize)
	-> Result<Rc<ConditionalOrExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = ConditionalOrExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 448, RULE_conditionalOrExpression, _p);
	    let mut _localctx: Rc<ConditionalOrExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 448;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule conditionalAndExpression*/
			recog.base.set_state(2764);
			recog.conditionalAndExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2771);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(317,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = ConditionalOrExpressionContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_conditionalOrExpression);
					_localctx = tmp;
					recog.base.set_state(2766);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(2767);
					recog.base.match_token(OR,&mut recog.err_handler)?;

					/*InvokeRule conditionalAndExpression*/
					recog.base.set_state(2768);
					recog.conditionalAndExpression_rec(0)?;

					}
					} 
				}
				recog.base.set_state(2773);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(317,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- conditionalAndExpression ----------------
pub type ConditionalAndExpressionContextAll<'input> = ConditionalAndExpressionContext<'input>;


pub type ConditionalAndExpressionContext<'input> = BaseParserRuleContext<'input,ConditionalAndExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ConditionalAndExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ConditionalAndExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ConditionalAndExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_conditionalAndExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_conditionalAndExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConditionalAndExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conditionalAndExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conditionalAndExpression }
}
antlr_rust::tid!{ConditionalAndExpressionContextExt<'a>}

impl<'input> ConditionalAndExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConditionalAndExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConditionalAndExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConditionalAndExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ConditionalAndExpressionContextExt<'input>>{

fn inclusiveOrExpression(&self) -> Option<Rc<InclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn conditionalAndExpression(&self) -> Option<Rc<ConditionalAndExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AND
/// Returns `None` if there is no child corresponding to token AND
fn AND(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(AND, 0)
}

}

impl<'input> ConditionalAndExpressionContextAttrs<'input> for ConditionalAndExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  conditionalAndExpression(&mut self,)
	-> Result<Rc<ConditionalAndExpressionContextAll<'input>>,ANTLRError> {
		self.conditionalAndExpression_rec(0)
	}

	fn conditionalAndExpression_rec(&mut self, _p: isize)
	-> Result<Rc<ConditionalAndExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = ConditionalAndExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 450, RULE_conditionalAndExpression, _p);
	    let mut _localctx: Rc<ConditionalAndExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 450;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule inclusiveOrExpression*/
			recog.base.set_state(2775);
			recog.inclusiveOrExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2782);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(318,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = ConditionalAndExpressionContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_conditionalAndExpression);
					_localctx = tmp;
					recog.base.set_state(2777);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(2778);
					recog.base.match_token(AND,&mut recog.err_handler)?;

					/*InvokeRule inclusiveOrExpression*/
					recog.base.set_state(2779);
					recog.inclusiveOrExpression_rec(0)?;

					}
					} 
				}
				recog.base.set_state(2784);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(318,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- inclusiveOrExpression ----------------
pub type InclusiveOrExpressionContextAll<'input> = InclusiveOrExpressionContext<'input>;


pub type InclusiveOrExpressionContext<'input> = BaseParserRuleContext<'input,InclusiveOrExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct InclusiveOrExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for InclusiveOrExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for InclusiveOrExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_inclusiveOrExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_inclusiveOrExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InclusiveOrExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inclusiveOrExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inclusiveOrExpression }
}
antlr_rust::tid!{InclusiveOrExpressionContextExt<'a>}

impl<'input> InclusiveOrExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InclusiveOrExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InclusiveOrExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InclusiveOrExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<InclusiveOrExpressionContextExt<'input>>{

fn exclusiveOrExpression(&self) -> Option<Rc<ExclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn inclusiveOrExpression(&self) -> Option<Rc<InclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BITOR
/// Returns `None` if there is no child corresponding to token BITOR
fn BITOR(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(BITOR, 0)
}

}

impl<'input> InclusiveOrExpressionContextAttrs<'input> for InclusiveOrExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  inclusiveOrExpression(&mut self,)
	-> Result<Rc<InclusiveOrExpressionContextAll<'input>>,ANTLRError> {
		self.inclusiveOrExpression_rec(0)
	}

	fn inclusiveOrExpression_rec(&mut self, _p: isize)
	-> Result<Rc<InclusiveOrExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = InclusiveOrExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 452, RULE_inclusiveOrExpression, _p);
	    let mut _localctx: Rc<InclusiveOrExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 452;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule exclusiveOrExpression*/
			recog.base.set_state(2786);
			recog.exclusiveOrExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2793);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(319,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = InclusiveOrExpressionContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_inclusiveOrExpression);
					_localctx = tmp;
					recog.base.set_state(2788);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(2789);
					recog.base.match_token(BITOR,&mut recog.err_handler)?;

					/*InvokeRule exclusiveOrExpression*/
					recog.base.set_state(2790);
					recog.exclusiveOrExpression_rec(0)?;

					}
					} 
				}
				recog.base.set_state(2795);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(319,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- exclusiveOrExpression ----------------
pub type ExclusiveOrExpressionContextAll<'input> = ExclusiveOrExpressionContext<'input>;


pub type ExclusiveOrExpressionContext<'input> = BaseParserRuleContext<'input,ExclusiveOrExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExclusiveOrExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ExclusiveOrExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ExclusiveOrExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_exclusiveOrExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_exclusiveOrExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExclusiveOrExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_exclusiveOrExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_exclusiveOrExpression }
}
antlr_rust::tid!{ExclusiveOrExpressionContextExt<'a>}

impl<'input> ExclusiveOrExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExclusiveOrExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExclusiveOrExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExclusiveOrExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ExclusiveOrExpressionContextExt<'input>>{

fn andExpression(&self) -> Option<Rc<AndExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn exclusiveOrExpression(&self) -> Option<Rc<ExclusiveOrExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CARET
/// Returns `None` if there is no child corresponding to token CARET
fn CARET(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(CARET, 0)
}

}

impl<'input> ExclusiveOrExpressionContextAttrs<'input> for ExclusiveOrExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  exclusiveOrExpression(&mut self,)
	-> Result<Rc<ExclusiveOrExpressionContextAll<'input>>,ANTLRError> {
		self.exclusiveOrExpression_rec(0)
	}

	fn exclusiveOrExpression_rec(&mut self, _p: isize)
	-> Result<Rc<ExclusiveOrExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = ExclusiveOrExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 454, RULE_exclusiveOrExpression, _p);
	    let mut _localctx: Rc<ExclusiveOrExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 454;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule andExpression*/
			recog.base.set_state(2797);
			recog.andExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2804);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(320,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = ExclusiveOrExpressionContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_exclusiveOrExpression);
					_localctx = tmp;
					recog.base.set_state(2799);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(2800);
					recog.base.match_token(CARET,&mut recog.err_handler)?;

					/*InvokeRule andExpression*/
					recog.base.set_state(2801);
					recog.andExpression_rec(0)?;

					}
					} 
				}
				recog.base.set_state(2806);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(320,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- andExpression ----------------
pub type AndExpressionContextAll<'input> = AndExpressionContext<'input>;


pub type AndExpressionContext<'input> = BaseParserRuleContext<'input,AndExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AndExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AndExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AndExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_andExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_andExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AndExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_andExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_andExpression }
}
antlr_rust::tid!{AndExpressionContextExt<'a>}

impl<'input> AndExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AndExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AndExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AndExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AndExpressionContextExt<'input>>{

fn equalityExpression(&self) -> Option<Rc<EqualityExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn andExpression(&self) -> Option<Rc<AndExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BITAND
/// Returns `None` if there is no child corresponding to token BITAND
fn BITAND(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(BITAND, 0)
}

}

impl<'input> AndExpressionContextAttrs<'input> for AndExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  andExpression(&mut self,)
	-> Result<Rc<AndExpressionContextAll<'input>>,ANTLRError> {
		self.andExpression_rec(0)
	}

	fn andExpression_rec(&mut self, _p: isize)
	-> Result<Rc<AndExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = AndExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 456, RULE_andExpression, _p);
	    let mut _localctx: Rc<AndExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 456;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule equalityExpression*/
			recog.base.set_state(2808);
			recog.equalityExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2815);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(321,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					{
					/*recRuleAltStartAction*/
					let mut tmp = AndExpressionContextExt::new(_parentctx.clone(), _parentState);
					recog.push_new_recursion_context(tmp.clone(), _startState, RULE_andExpression);
					_localctx = tmp;
					recog.base.set_state(2810);
					if !({recog.precpred(None, 1)}) {
						Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
					}
					recog.base.set_state(2811);
					recog.base.match_token(BITAND,&mut recog.err_handler)?;

					/*InvokeRule equalityExpression*/
					recog.base.set_state(2812);
					recog.equalityExpression_rec(0)?;

					}
					} 
				}
				recog.base.set_state(2817);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(321,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- equalityExpression ----------------
pub type EqualityExpressionContextAll<'input> = EqualityExpressionContext<'input>;


pub type EqualityExpressionContext<'input> = BaseParserRuleContext<'input,EqualityExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct EqualityExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for EqualityExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for EqualityExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_equalityExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_equalityExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for EqualityExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_equalityExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_equalityExpression }
}
antlr_rust::tid!{EqualityExpressionContextExt<'a>}

impl<'input> EqualityExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EqualityExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EqualityExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EqualityExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<EqualityExpressionContextExt<'input>>{

fn relationalExpression(&self) -> Option<Rc<RelationalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn equalityExpression(&self) -> Option<Rc<EqualityExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EQUAL
/// Returns `None` if there is no child corresponding to token EQUAL
fn EQUAL(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(EQUAL, 0)
}
/// Retrieves first TerminalNode corresponding to token NOTEQUAL
/// Returns `None` if there is no child corresponding to token NOTEQUAL
fn NOTEQUAL(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(NOTEQUAL, 0)
}

}

impl<'input> EqualityExpressionContextAttrs<'input> for EqualityExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  equalityExpression(&mut self,)
	-> Result<Rc<EqualityExpressionContextAll<'input>>,ANTLRError> {
		self.equalityExpression_rec(0)
	}

	fn equalityExpression_rec(&mut self, _p: isize)
	-> Result<Rc<EqualityExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = EqualityExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 458, RULE_equalityExpression, _p);
	    let mut _localctx: Rc<EqualityExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 458;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule relationalExpression*/
			recog.base.set_state(2819);
			recog.relationalExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2829);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(323,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(2827);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(322,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = EqualityExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_equalityExpression);
							_localctx = tmp;
							recog.base.set_state(2821);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(2822);
							recog.base.match_token(EQUAL,&mut recog.err_handler)?;

							/*InvokeRule relationalExpression*/
							recog.base.set_state(2823);
							recog.relationalExpression_rec(0)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = EqualityExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_equalityExpression);
							_localctx = tmp;
							recog.base.set_state(2824);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(2825);
							recog.base.match_token(NOTEQUAL,&mut recog.err_handler)?;

							/*InvokeRule relationalExpression*/
							recog.base.set_state(2826);
							recog.relationalExpression_rec(0)?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(2831);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(323,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- relationalExpression ----------------
pub type RelationalExpressionContextAll<'input> = RelationalExpressionContext<'input>;


pub type RelationalExpressionContext<'input> = BaseParserRuleContext<'input,RelationalExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct RelationalExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for RelationalExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for RelationalExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_relationalExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_relationalExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RelationalExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relationalExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relationalExpression }
}
antlr_rust::tid!{RelationalExpressionContextExt<'a>}

impl<'input> RelationalExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RelationalExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RelationalExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RelationalExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<RelationalExpressionContextExt<'input>>{

fn shiftExpression(&self) -> Option<Rc<ShiftExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn relationalExpression(&self) -> Option<Rc<RelationalExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LT
/// Returns `None` if there is no child corresponding to token LT
fn LT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LT, 0)
}
/// Retrieves first TerminalNode corresponding to token GT
/// Returns `None` if there is no child corresponding to token GT
fn GT(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(GT, 0)
}
/// Retrieves first TerminalNode corresponding to token LE
/// Returns `None` if there is no child corresponding to token LE
fn LE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LE, 0)
}
/// Retrieves first TerminalNode corresponding to token GE
/// Returns `None` if there is no child corresponding to token GE
fn GE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(GE, 0)
}
/// Retrieves first TerminalNode corresponding to token INSTANCEOF
/// Returns `None` if there is no child corresponding to token INSTANCEOF
fn INSTANCEOF(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(INSTANCEOF, 0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RelationalExpressionContextAttrs<'input> for RelationalExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  relationalExpression(&mut self,)
	-> Result<Rc<RelationalExpressionContextAll<'input>>,ANTLRError> {
		self.relationalExpression_rec(0)
	}

	fn relationalExpression_rec(&mut self, _p: isize)
	-> Result<Rc<RelationalExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = RelationalExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 460, RULE_relationalExpression, _p);
	    let mut _localctx: Rc<RelationalExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 460;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule shiftExpression*/
			recog.base.set_state(2833);
			recog.shiftExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2852);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(325,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(2850);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(324,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = RelationalExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_relationalExpression);
							_localctx = tmp;
							recog.base.set_state(2835);
							if !({recog.precpred(None, 5)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 5)".to_owned()), None))?;
							}
							recog.base.set_state(2836);
							recog.base.match_token(LT,&mut recog.err_handler)?;

							/*InvokeRule shiftExpression*/
							recog.base.set_state(2837);
							recog.shiftExpression_rec(0)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = RelationalExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_relationalExpression);
							_localctx = tmp;
							recog.base.set_state(2838);
							if !({recog.precpred(None, 4)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 4)".to_owned()), None))?;
							}
							recog.base.set_state(2839);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							/*InvokeRule shiftExpression*/
							recog.base.set_state(2840);
							recog.shiftExpression_rec(0)?;

							}
						}
					,
						3 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = RelationalExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_relationalExpression);
							_localctx = tmp;
							recog.base.set_state(2841);
							if !({recog.precpred(None, 3)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 3)".to_owned()), None))?;
							}
							recog.base.set_state(2842);
							recog.base.match_token(LE,&mut recog.err_handler)?;

							/*InvokeRule shiftExpression*/
							recog.base.set_state(2843);
							recog.shiftExpression_rec(0)?;

							}
						}
					,
						4 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = RelationalExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_relationalExpression);
							_localctx = tmp;
							recog.base.set_state(2844);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(2845);
							recog.base.match_token(GE,&mut recog.err_handler)?;

							/*InvokeRule shiftExpression*/
							recog.base.set_state(2846);
							recog.shiftExpression_rec(0)?;

							}
						}
					,
						5 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = RelationalExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_relationalExpression);
							_localctx = tmp;
							recog.base.set_state(2847);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(2848);
							recog.base.match_token(INSTANCEOF,&mut recog.err_handler)?;

							/*InvokeRule referenceType*/
							recog.base.set_state(2849);
							recog.referenceType()?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(2854);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(325,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- shiftExpression ----------------
pub type ShiftExpressionContextAll<'input> = ShiftExpressionContext<'input>;


pub type ShiftExpressionContext<'input> = BaseParserRuleContext<'input,ShiftExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ShiftExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for ShiftExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for ShiftExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shiftExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_shiftExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShiftExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shiftExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shiftExpression }
}
antlr_rust::tid!{ShiftExpressionContextExt<'a>}

impl<'input> ShiftExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShiftExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShiftExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShiftExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<ShiftExpressionContextExt<'input>>{

fn additiveExpression(&self) -> Option<Rc<AdditiveExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shiftExpression(&self) -> Option<Rc<ShiftExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token LT in current rule
fn LT_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LT, starting from 0.
/// Returns `None` if number of children corresponding to token LT is less or equal than `i`.
fn LT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LT, i)
}
/// Retrieves all `TerminalNode`s corresponding to token GT in current rule
fn GT_all(&self) -> Vec<Rc<TerminalNode<'input,Java9ParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token GT, starting from 0.
/// Returns `None` if number of children corresponding to token GT is less or equal than `i`.
fn GT(&self, i: usize) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(GT, i)
}

}

impl<'input> ShiftExpressionContextAttrs<'input> for ShiftExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  shiftExpression(&mut self,)
	-> Result<Rc<ShiftExpressionContextAll<'input>>,ANTLRError> {
		self.shiftExpression_rec(0)
	}

	fn shiftExpression_rec(&mut self, _p: isize)
	-> Result<Rc<ShiftExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = ShiftExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 462, RULE_shiftExpression, _p);
	    let mut _localctx: Rc<ShiftExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 462;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule additiveExpression*/
			recog.base.set_state(2856);
			recog.additiveExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2873);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(327,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(2871);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(326,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = ShiftExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_shiftExpression);
							_localctx = tmp;
							recog.base.set_state(2858);
							if !({recog.precpred(None, 3)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 3)".to_owned()), None))?;
							}
							recog.base.set_state(2859);
							recog.base.match_token(LT,&mut recog.err_handler)?;

							recog.base.set_state(2860);
							recog.base.match_token(LT,&mut recog.err_handler)?;

							/*InvokeRule additiveExpression*/
							recog.base.set_state(2861);
							recog.additiveExpression_rec(0)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = ShiftExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_shiftExpression);
							_localctx = tmp;
							recog.base.set_state(2862);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(2863);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							recog.base.set_state(2864);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							/*InvokeRule additiveExpression*/
							recog.base.set_state(2865);
							recog.additiveExpression_rec(0)?;

							}
						}
					,
						3 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = ShiftExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_shiftExpression);
							_localctx = tmp;
							recog.base.set_state(2866);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(2867);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							recog.base.set_state(2868);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							recog.base.set_state(2869);
							recog.base.match_token(GT,&mut recog.err_handler)?;

							/*InvokeRule additiveExpression*/
							recog.base.set_state(2870);
							recog.additiveExpression_rec(0)?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(2875);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(327,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- additiveExpression ----------------
pub type AdditiveExpressionContextAll<'input> = AdditiveExpressionContext<'input>;


pub type AdditiveExpressionContext<'input> = BaseParserRuleContext<'input,AdditiveExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AdditiveExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for AdditiveExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for AdditiveExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_additiveExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_additiveExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AdditiveExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_additiveExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_additiveExpression }
}
antlr_rust::tid!{AdditiveExpressionContextExt<'a>}

impl<'input> AdditiveExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AdditiveExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AdditiveExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AdditiveExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<AdditiveExpressionContextExt<'input>>{

fn multiplicativeExpression(&self) -> Option<Rc<MultiplicativeExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn additiveExpression(&self) -> Option<Rc<AdditiveExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ADD
/// Returns `None` if there is no child corresponding to token ADD
fn ADD(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ADD, 0)
}
/// Retrieves first TerminalNode corresponding to token SUB
/// Returns `None` if there is no child corresponding to token SUB
fn SUB(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SUB, 0)
}

}

impl<'input> AdditiveExpressionContextAttrs<'input> for AdditiveExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  additiveExpression(&mut self,)
	-> Result<Rc<AdditiveExpressionContextAll<'input>>,ANTLRError> {
		self.additiveExpression_rec(0)
	}

	fn additiveExpression_rec(&mut self, _p: isize)
	-> Result<Rc<AdditiveExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = AdditiveExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 464, RULE_additiveExpression, _p);
	    let mut _localctx: Rc<AdditiveExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 464;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule multiplicativeExpression*/
			recog.base.set_state(2877);
			recog.multiplicativeExpression_rec(0)?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2887);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(329,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(2885);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(328,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = AdditiveExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_additiveExpression);
							_localctx = tmp;
							recog.base.set_state(2879);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(2880);
							recog.base.match_token(ADD,&mut recog.err_handler)?;

							/*InvokeRule multiplicativeExpression*/
							recog.base.set_state(2881);
							recog.multiplicativeExpression_rec(0)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = AdditiveExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_additiveExpression);
							_localctx = tmp;
							recog.base.set_state(2882);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(2883);
							recog.base.match_token(SUB,&mut recog.err_handler)?;

							/*InvokeRule multiplicativeExpression*/
							recog.base.set_state(2884);
							recog.multiplicativeExpression_rec(0)?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(2889);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(329,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- multiplicativeExpression ----------------
pub type MultiplicativeExpressionContextAll<'input> = MultiplicativeExpressionContext<'input>;


pub type MultiplicativeExpressionContext<'input> = BaseParserRuleContext<'input,MultiplicativeExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct MultiplicativeExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for MultiplicativeExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for MultiplicativeExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multiplicativeExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_multiplicativeExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MultiplicativeExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiplicativeExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiplicativeExpression }
}
antlr_rust::tid!{MultiplicativeExpressionContextExt<'a>}

impl<'input> MultiplicativeExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiplicativeExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiplicativeExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiplicativeExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<MultiplicativeExpressionContextExt<'input>>{

fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn multiplicativeExpression(&self) -> Option<Rc<MultiplicativeExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token MUL
/// Returns `None` if there is no child corresponding to token MUL
fn MUL(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(MUL, 0)
}
/// Retrieves first TerminalNode corresponding to token DIV
/// Returns `None` if there is no child corresponding to token DIV
fn DIV(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DIV, 0)
}
/// Retrieves first TerminalNode corresponding to token MOD
/// Returns `None` if there is no child corresponding to token MOD
fn MOD(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(MOD, 0)
}

}

impl<'input> MultiplicativeExpressionContextAttrs<'input> for MultiplicativeExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  multiplicativeExpression(&mut self,)
	-> Result<Rc<MultiplicativeExpressionContextAll<'input>>,ANTLRError> {
		self.multiplicativeExpression_rec(0)
	}

	fn multiplicativeExpression_rec(&mut self, _p: isize)
	-> Result<Rc<MultiplicativeExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = MultiplicativeExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 466, RULE_multiplicativeExpression, _p);
	    let mut _localctx: Rc<MultiplicativeExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 466;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			/*InvokeRule unaryExpression*/
			recog.base.set_state(2891);
			recog.unaryExpression()?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(2904);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(331,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(2902);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(330,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = MultiplicativeExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_multiplicativeExpression);
							_localctx = tmp;
							recog.base.set_state(2893);
							if !({recog.precpred(None, 3)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 3)".to_owned()), None))?;
							}
							recog.base.set_state(2894);
							recog.base.match_token(MUL,&mut recog.err_handler)?;

							/*InvokeRule unaryExpression*/
							recog.base.set_state(2895);
							recog.unaryExpression()?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = MultiplicativeExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_multiplicativeExpression);
							_localctx = tmp;
							recog.base.set_state(2896);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(2897);
							recog.base.match_token(DIV,&mut recog.err_handler)?;

							/*InvokeRule unaryExpression*/
							recog.base.set_state(2898);
							recog.unaryExpression()?;

							}
						}
					,
						3 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = MultiplicativeExpressionContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_multiplicativeExpression);
							_localctx = tmp;
							recog.base.set_state(2899);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(2900);
							recog.base.match_token(MOD,&mut recog.err_handler)?;

							/*InvokeRule unaryExpression*/
							recog.base.set_state(2901);
							recog.unaryExpression()?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(2906);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(331,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- unaryExpression ----------------
pub type UnaryExpressionContextAll<'input> = UnaryExpressionContext<'input>;


pub type UnaryExpressionContext<'input> = BaseParserRuleContext<'input,UnaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct UnaryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnaryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnaryExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unaryExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unaryExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnaryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unaryExpression }
}
antlr_rust::tid!{UnaryExpressionContextExt<'a>}

impl<'input> UnaryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnaryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnaryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnaryExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnaryExpressionContextExt<'input>>{

fn preIncrementExpression(&self) -> Option<Rc<PreIncrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn preDecrementExpression(&self) -> Option<Rc<PreDecrementExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ADD
/// Returns `None` if there is no child corresponding to token ADD
fn ADD(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(ADD, 0)
}
fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUB
/// Returns `None` if there is no child corresponding to token SUB
fn SUB(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(SUB, 0)
}
fn unaryExpressionNotPlusMinus(&self) -> Option<Rc<UnaryExpressionNotPlusMinusContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnaryExpressionContextAttrs<'input> for UnaryExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unaryExpression(&mut self,)
	-> Result<Rc<UnaryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 468, RULE_unaryExpression);
        let mut _localctx: Rc<UnaryExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2914);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 INC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule preIncrementExpression*/
					recog.base.set_state(2907);
					recog.preIncrementExpression()?;

					}
				}

			 DEC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule preDecrementExpression*/
					recog.base.set_state(2908);
					recog.preDecrementExpression()?;

					}
				}

			 ADD 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2909);
					recog.base.match_token(ADD,&mut recog.err_handler)?;

					/*InvokeRule unaryExpression*/
					recog.base.set_state(2910);
					recog.unaryExpression()?;

					}
				}

			 SUB 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(2911);
					recog.base.match_token(SUB,&mut recog.err_handler)?;

					/*InvokeRule unaryExpression*/
					recog.base.set_state(2912);
					recog.unaryExpression()?;

					}
				}

			 BOOLEAN | BYTE | CHAR | DOUBLE | EXPORTS | FLOAT | INT | LONG | MODULE |
			 NEW | OPEN | OPERNS | PROVIDES | REQUIRES | SHORT | SUPER | THIS | TO |
			 USES | VOID | WITH | IntegerLiteral | FloatingPointLiteral | BooleanLiteral |
			 CharacterLiteral | StringLiteral | NullLiteral | LPAREN | AT | BANG |
			 TILDE | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule unaryExpressionNotPlusMinus*/
					recog.base.set_state(2913);
					recog.unaryExpressionNotPlusMinus()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- preIncrementExpression ----------------
pub type PreIncrementExpressionContextAll<'input> = PreIncrementExpressionContext<'input>;


pub type PreIncrementExpressionContext<'input> = BaseParserRuleContext<'input,PreIncrementExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PreIncrementExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PreIncrementExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PreIncrementExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_preIncrementExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_preIncrementExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PreIncrementExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_preIncrementExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_preIncrementExpression }
}
antlr_rust::tid!{PreIncrementExpressionContextExt<'a>}

impl<'input> PreIncrementExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PreIncrementExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PreIncrementExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PreIncrementExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PreIncrementExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INC
/// Returns `None` if there is no child corresponding to token INC
fn INC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(INC, 0)
}
fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PreIncrementExpressionContextAttrs<'input> for PreIncrementExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn preIncrementExpression(&mut self,)
	-> Result<Rc<PreIncrementExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PreIncrementExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 470, RULE_preIncrementExpression);
        let mut _localctx: Rc<PreIncrementExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2916);
			recog.base.match_token(INC,&mut recog.err_handler)?;

			/*InvokeRule unaryExpression*/
			recog.base.set_state(2917);
			recog.unaryExpression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- preDecrementExpression ----------------
pub type PreDecrementExpressionContextAll<'input> = PreDecrementExpressionContext<'input>;


pub type PreDecrementExpressionContext<'input> = BaseParserRuleContext<'input,PreDecrementExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PreDecrementExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PreDecrementExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PreDecrementExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_preDecrementExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_preDecrementExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PreDecrementExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_preDecrementExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_preDecrementExpression }
}
antlr_rust::tid!{PreDecrementExpressionContextExt<'a>}

impl<'input> PreDecrementExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PreDecrementExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PreDecrementExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PreDecrementExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PreDecrementExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DEC
/// Returns `None` if there is no child corresponding to token DEC
fn DEC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DEC, 0)
}
fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PreDecrementExpressionContextAttrs<'input> for PreDecrementExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn preDecrementExpression(&mut self,)
	-> Result<Rc<PreDecrementExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PreDecrementExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 472, RULE_preDecrementExpression);
        let mut _localctx: Rc<PreDecrementExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2919);
			recog.base.match_token(DEC,&mut recog.err_handler)?;

			/*InvokeRule unaryExpression*/
			recog.base.set_state(2920);
			recog.unaryExpression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unaryExpressionNotPlusMinus ----------------
pub type UnaryExpressionNotPlusMinusContextAll<'input> = UnaryExpressionNotPlusMinusContext<'input>;


pub type UnaryExpressionNotPlusMinusContext<'input> = BaseParserRuleContext<'input,UnaryExpressionNotPlusMinusContextExt<'input>>;

#[derive(Clone)]
pub struct UnaryExpressionNotPlusMinusContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for UnaryExpressionNotPlusMinusContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for UnaryExpressionNotPlusMinusContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unaryExpressionNotPlusMinus(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_unaryExpressionNotPlusMinus(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UnaryExpressionNotPlusMinusContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unaryExpressionNotPlusMinus }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unaryExpressionNotPlusMinus }
}
antlr_rust::tid!{UnaryExpressionNotPlusMinusContextExt<'a>}

impl<'input> UnaryExpressionNotPlusMinusContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnaryExpressionNotPlusMinusContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnaryExpressionNotPlusMinusContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnaryExpressionNotPlusMinusContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<UnaryExpressionNotPlusMinusContextExt<'input>>{

fn postfixExpression(&self) -> Option<Rc<PostfixExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token TILDE
/// Returns `None` if there is no child corresponding to token TILDE
fn TILDE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(TILDE, 0)
}
fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BANG
/// Returns `None` if there is no child corresponding to token BANG
fn BANG(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(BANG, 0)
}
fn castExpression(&self) -> Option<Rc<CastExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnaryExpressionNotPlusMinusContextAttrs<'input> for UnaryExpressionNotPlusMinusContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unaryExpressionNotPlusMinus(&mut self,)
	-> Result<Rc<UnaryExpressionNotPlusMinusContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnaryExpressionNotPlusMinusContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 474, RULE_unaryExpressionNotPlusMinus);
        let mut _localctx: Rc<UnaryExpressionNotPlusMinusContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2928);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(333,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule postfixExpression*/
					recog.base.set_state(2922);
					recog.postfixExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2923);
					recog.base.match_token(TILDE,&mut recog.err_handler)?;

					/*InvokeRule unaryExpression*/
					recog.base.set_state(2924);
					recog.unaryExpression()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2925);
					recog.base.match_token(BANG,&mut recog.err_handler)?;

					/*InvokeRule unaryExpression*/
					recog.base.set_state(2926);
					recog.unaryExpression()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule castExpression*/
					recog.base.set_state(2927);
					recog.castExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postfixExpression ----------------
pub type PostfixExpressionContextAll<'input> = PostfixExpressionContext<'input>;


pub type PostfixExpressionContext<'input> = BaseParserRuleContext<'input,PostfixExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PostfixExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PostfixExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PostfixExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postfixExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_postfixExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PostfixExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postfixExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postfixExpression }
}
antlr_rust::tid!{PostfixExpressionContextExt<'a>}

impl<'input> PostfixExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostfixExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostfixExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostfixExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PostfixExpressionContextExt<'input>>{

fn primary(&self) -> Option<Rc<PrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expressionName(&self) -> Option<Rc<ExpressionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn postIncrementExpression_lf_postfixExpression_all(&self) ->  Vec<Rc<PostIncrementExpression_lf_postfixExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn postIncrementExpression_lf_postfixExpression(&self, i: usize) -> Option<Rc<PostIncrementExpression_lf_postfixExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn postDecrementExpression_lf_postfixExpression_all(&self) ->  Vec<Rc<PostDecrementExpression_lf_postfixExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn postDecrementExpression_lf_postfixExpression(&self, i: usize) -> Option<Rc<PostDecrementExpression_lf_postfixExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PostfixExpressionContextAttrs<'input> for PostfixExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postfixExpression(&mut self,)
	-> Result<Rc<PostfixExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostfixExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 476, RULE_postfixExpression);
        let mut _localctx: Rc<PostfixExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2932);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(334,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule primary*/
					recog.base.set_state(2930);
					recog.primary()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule expressionName*/
					recog.base.set_state(2931);
					recog.expressionName()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2938);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(336,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					recog.base.set_state(2936);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 INC 
						=> {
							{
							/*InvokeRule postIncrementExpression_lf_postfixExpression*/
							recog.base.set_state(2934);
							recog.postIncrementExpression_lf_postfixExpression()?;

							}
						}

					 DEC 
						=> {
							{
							/*InvokeRule postDecrementExpression_lf_postfixExpression*/
							recog.base.set_state(2935);
							recog.postDecrementExpression_lf_postfixExpression()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					} 
				}
				recog.base.set_state(2940);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(336,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postIncrementExpression ----------------
pub type PostIncrementExpressionContextAll<'input> = PostIncrementExpressionContext<'input>;


pub type PostIncrementExpressionContext<'input> = BaseParserRuleContext<'input,PostIncrementExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PostIncrementExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PostIncrementExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PostIncrementExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postIncrementExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_postIncrementExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PostIncrementExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postIncrementExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postIncrementExpression }
}
antlr_rust::tid!{PostIncrementExpressionContextExt<'a>}

impl<'input> PostIncrementExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostIncrementExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostIncrementExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostIncrementExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PostIncrementExpressionContextExt<'input>>{

fn postfixExpression(&self) -> Option<Rc<PostfixExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token INC
/// Returns `None` if there is no child corresponding to token INC
fn INC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(INC, 0)
}

}

impl<'input> PostIncrementExpressionContextAttrs<'input> for PostIncrementExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postIncrementExpression(&mut self,)
	-> Result<Rc<PostIncrementExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostIncrementExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 478, RULE_postIncrementExpression);
        let mut _localctx: Rc<PostIncrementExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule postfixExpression*/
			recog.base.set_state(2941);
			recog.postfixExpression()?;

			recog.base.set_state(2942);
			recog.base.match_token(INC,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postIncrementExpression_lf_postfixExpression ----------------
pub type PostIncrementExpression_lf_postfixExpressionContextAll<'input> = PostIncrementExpression_lf_postfixExpressionContext<'input>;


pub type PostIncrementExpression_lf_postfixExpressionContext<'input> = BaseParserRuleContext<'input,PostIncrementExpression_lf_postfixExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PostIncrementExpression_lf_postfixExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PostIncrementExpression_lf_postfixExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PostIncrementExpression_lf_postfixExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postIncrementExpression_lf_postfixExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_postIncrementExpression_lf_postfixExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PostIncrementExpression_lf_postfixExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postIncrementExpression_lf_postfixExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postIncrementExpression_lf_postfixExpression }
}
antlr_rust::tid!{PostIncrementExpression_lf_postfixExpressionContextExt<'a>}

impl<'input> PostIncrementExpression_lf_postfixExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostIncrementExpression_lf_postfixExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostIncrementExpression_lf_postfixExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostIncrementExpression_lf_postfixExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PostIncrementExpression_lf_postfixExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INC
/// Returns `None` if there is no child corresponding to token INC
fn INC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(INC, 0)
}

}

impl<'input> PostIncrementExpression_lf_postfixExpressionContextAttrs<'input> for PostIncrementExpression_lf_postfixExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postIncrementExpression_lf_postfixExpression(&mut self,)
	-> Result<Rc<PostIncrementExpression_lf_postfixExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostIncrementExpression_lf_postfixExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 480, RULE_postIncrementExpression_lf_postfixExpression);
        let mut _localctx: Rc<PostIncrementExpression_lf_postfixExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2944);
			recog.base.match_token(INC,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postDecrementExpression ----------------
pub type PostDecrementExpressionContextAll<'input> = PostDecrementExpressionContext<'input>;


pub type PostDecrementExpressionContext<'input> = BaseParserRuleContext<'input,PostDecrementExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PostDecrementExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PostDecrementExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PostDecrementExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postDecrementExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_postDecrementExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PostDecrementExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postDecrementExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postDecrementExpression }
}
antlr_rust::tid!{PostDecrementExpressionContextExt<'a>}

impl<'input> PostDecrementExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostDecrementExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostDecrementExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostDecrementExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PostDecrementExpressionContextExt<'input>>{

fn postfixExpression(&self) -> Option<Rc<PostfixExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DEC
/// Returns `None` if there is no child corresponding to token DEC
fn DEC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DEC, 0)
}

}

impl<'input> PostDecrementExpressionContextAttrs<'input> for PostDecrementExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postDecrementExpression(&mut self,)
	-> Result<Rc<PostDecrementExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostDecrementExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 482, RULE_postDecrementExpression);
        let mut _localctx: Rc<PostDecrementExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule postfixExpression*/
			recog.base.set_state(2946);
			recog.postfixExpression()?;

			recog.base.set_state(2947);
			recog.base.match_token(DEC,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postDecrementExpression_lf_postfixExpression ----------------
pub type PostDecrementExpression_lf_postfixExpressionContextAll<'input> = PostDecrementExpression_lf_postfixExpressionContext<'input>;


pub type PostDecrementExpression_lf_postfixExpressionContext<'input> = BaseParserRuleContext<'input,PostDecrementExpression_lf_postfixExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PostDecrementExpression_lf_postfixExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for PostDecrementExpression_lf_postfixExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for PostDecrementExpression_lf_postfixExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postDecrementExpression_lf_postfixExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_postDecrementExpression_lf_postfixExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PostDecrementExpression_lf_postfixExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postDecrementExpression_lf_postfixExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postDecrementExpression_lf_postfixExpression }
}
antlr_rust::tid!{PostDecrementExpression_lf_postfixExpressionContextExt<'a>}

impl<'input> PostDecrementExpression_lf_postfixExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostDecrementExpression_lf_postfixExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostDecrementExpression_lf_postfixExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostDecrementExpression_lf_postfixExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<PostDecrementExpression_lf_postfixExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DEC
/// Returns `None` if there is no child corresponding to token DEC
fn DEC(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(DEC, 0)
}

}

impl<'input> PostDecrementExpression_lf_postfixExpressionContextAttrs<'input> for PostDecrementExpression_lf_postfixExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postDecrementExpression_lf_postfixExpression(&mut self,)
	-> Result<Rc<PostDecrementExpression_lf_postfixExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostDecrementExpression_lf_postfixExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 484, RULE_postDecrementExpression_lf_postfixExpression);
        let mut _localctx: Rc<PostDecrementExpression_lf_postfixExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2949);
			recog.base.match_token(DEC,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- castExpression ----------------
pub type CastExpressionContextAll<'input> = CastExpressionContext<'input>;


pub type CastExpressionContext<'input> = BaseParserRuleContext<'input,CastExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct CastExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for CastExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for CastExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_castExpression(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_castExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CastExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_castExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_castExpression }
}
antlr_rust::tid!{CastExpressionContextExt<'a>}

impl<'input> CastExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CastExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CastExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CastExpressionContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<CastExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn primitiveType(&self) -> Option<Rc<PrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn unaryExpression(&self) -> Option<Rc<UnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unaryExpressionNotPlusMinus(&self) -> Option<Rc<UnaryExpressionNotPlusMinusContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn additionalBound_all(&self) ->  Vec<Rc<AdditionalBoundContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn additionalBound(&self, i: usize) -> Option<Rc<AdditionalBoundContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn lambdaExpression(&self) -> Option<Rc<LambdaExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CastExpressionContextAttrs<'input> for CastExpressionContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn castExpression(&mut self,)
	-> Result<Rc<CastExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CastExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 486, RULE_castExpression);
        let mut _localctx: Rc<CastExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2978);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(339,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2951);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule primitiveType*/
					recog.base.set_state(2952);
					recog.primitiveType()?;

					recog.base.set_state(2953);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule unaryExpression*/
					recog.base.set_state(2954);
					recog.unaryExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2956);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule referenceType*/
					recog.base.set_state(2957);
					recog.referenceType()?;

					recog.base.set_state(2961);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==BITAND {
						{
						{
						/*InvokeRule additionalBound*/
						recog.base.set_state(2958);
						recog.additionalBound()?;

						}
						}
						recog.base.set_state(2963);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2964);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule unaryExpressionNotPlusMinus*/
					recog.base.set_state(2965);
					recog.unaryExpressionNotPlusMinus()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(2967);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule referenceType*/
					recog.base.set_state(2968);
					recog.referenceType()?;

					recog.base.set_state(2972);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==BITAND {
						{
						{
						/*InvokeRule additionalBound*/
						recog.base.set_state(2969);
						recog.additionalBound()?;

						}
						}
						recog.base.set_state(2974);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2975);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule lambdaExpression*/
					recog.base.set_state(2976);
					recog.lambdaExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- identifier ----------------
pub type IdentifierContextAll<'input> = IdentifierContext<'input>;


pub type IdentifierContext<'input> = BaseParserRuleContext<'input,IdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> Java9ParserContext<'input> for IdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn Java9ParserListener<'input> + 'a> for IdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_identifier(self);
		}fn exit(&self,listener: &mut (dyn Java9ParserListener<'input> + 'a)) {
			listener.exit_identifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = Java9ParserContextType;
	fn get_rule_index(&self) -> usize { RULE_identifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}
antlr_rust::tid!{IdentifierContextExt<'a>}

impl<'input> IdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn Java9ParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IdentifierContextAttrs<'input>: Java9ParserContext<'input> + BorrowMut<IdentifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token TO
/// Returns `None` if there is no child corresponding to token TO
fn TO(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(TO, 0)
}
/// Retrieves first TerminalNode corresponding to token MODULE
/// Returns `None` if there is no child corresponding to token MODULE
fn MODULE(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(MODULE, 0)
}
/// Retrieves first TerminalNode corresponding to token OPEN
/// Returns `None` if there is no child corresponding to token OPEN
fn OPEN(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(OPEN, 0)
}
/// Retrieves first TerminalNode corresponding to token WITH
/// Returns `None` if there is no child corresponding to token WITH
fn WITH(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(WITH, 0)
}
/// Retrieves first TerminalNode corresponding to token PROVIDES
/// Returns `None` if there is no child corresponding to token PROVIDES
fn PROVIDES(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(PROVIDES, 0)
}
/// Retrieves first TerminalNode corresponding to token USES
/// Returns `None` if there is no child corresponding to token USES
fn USES(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(USES, 0)
}
/// Retrieves first TerminalNode corresponding to token OPERNS
/// Returns `None` if there is no child corresponding to token OPERNS
fn OPERNS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(OPERNS, 0)
}
/// Retrieves first TerminalNode corresponding to token REQUIRES
/// Returns `None` if there is no child corresponding to token REQUIRES
fn REQUIRES(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(REQUIRES, 0)
}
/// Retrieves first TerminalNode corresponding to token EXPORTS
/// Returns `None` if there is no child corresponding to token EXPORTS
fn EXPORTS(&self) -> Option<Rc<TerminalNode<'input,Java9ParserContextType>>> where Self:Sized{
	self.get_token(EXPORTS, 0)
}

}

impl<'input> IdentifierContextAttrs<'input> for IdentifierContext<'input>{}

impl<'input, I, H> Java9Parser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn identifier(&mut self,)
	-> Result<Rc<IdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 488, RULE_identifier);
        let mut _localctx: Rc<IdentifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2980);
			_la = recog.base.input.la(1);
			if { !(_la==EXPORTS || _la==MODULE || ((((_la - 34)) & !0x3f) == 0 && ((1usize << (_la - 34)) & ((1usize << (OPEN - 34)) | (1usize << (OPERNS - 34)) | (1usize << (PROVIDES - 34)) | (1usize << (REQUIRES - 34)) | (1usize << (TO - 34)) | (1usize << (USES - 34)) | (1usize << (WITH - 34)))) != 0) || _la==Identifier) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}

lazy_static! {
    static ref _ATN: Arc<ATN> =
        Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(
                _ATN.clone(),
                _ATN.get_decision_state(i),
                i as isize,
            ).into())
        }
        Arc::new(dfa)
    };
}



const _serializedATN:&'static str =
	"\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\x78\u{ba9}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x04\x7a\x09\
	\x7a\x04\x7b\x09\x7b\x04\x7c\x09\x7c\x04\x7d\x09\x7d\x04\x7e\x09\x7e\x04\
	\x7f\x09\x7f\x04\u{80}\x09\u{80}\x04\u{81}\x09\u{81}\x04\u{82}\x09\u{82}\
	\x04\u{83}\x09\u{83}\x04\u{84}\x09\u{84}\x04\u{85}\x09\u{85}\x04\u{86}\x09\
	\u{86}\x04\u{87}\x09\u{87}\x04\u{88}\x09\u{88}\x04\u{89}\x09\u{89}\x04\u{8a}\
	\x09\u{8a}\x04\u{8b}\x09\u{8b}\x04\u{8c}\x09\u{8c}\x04\u{8d}\x09\u{8d}\x04\
	\u{8e}\x09\u{8e}\x04\u{8f}\x09\u{8f}\x04\u{90}\x09\u{90}\x04\u{91}\x09\u{91}\
	\x04\u{92}\x09\u{92}\x04\u{93}\x09\u{93}\x04\u{94}\x09\u{94}\x04\u{95}\x09\
	\u{95}\x04\u{96}\x09\u{96}\x04\u{97}\x09\u{97}\x04\u{98}\x09\u{98}\x04\u{99}\
	\x09\u{99}\x04\u{9a}\x09\u{9a}\x04\u{9b}\x09\u{9b}\x04\u{9c}\x09\u{9c}\x04\
	\u{9d}\x09\u{9d}\x04\u{9e}\x09\u{9e}\x04\u{9f}\x09\u{9f}\x04\u{a0}\x09\u{a0}\
	\x04\u{a1}\x09\u{a1}\x04\u{a2}\x09\u{a2}\x04\u{a3}\x09\u{a3}\x04\u{a4}\x09\
	\u{a4}\x04\u{a5}\x09\u{a5}\x04\u{a6}\x09\u{a6}\x04\u{a7}\x09\u{a7}\x04\u{a8}\
	\x09\u{a8}\x04\u{a9}\x09\u{a9}\x04\u{aa}\x09\u{aa}\x04\u{ab}\x09\u{ab}\x04\
	\u{ac}\x09\u{ac}\x04\u{ad}\x09\u{ad}\x04\u{ae}\x09\u{ae}\x04\u{af}\x09\u{af}\
	\x04\u{b0}\x09\u{b0}\x04\u{b1}\x09\u{b1}\x04\u{b2}\x09\u{b2}\x04\u{b3}\x09\
	\u{b3}\x04\u{b4}\x09\u{b4}\x04\u{b5}\x09\u{b5}\x04\u{b6}\x09\u{b6}\x04\u{b7}\
	\x09\u{b7}\x04\u{b8}\x09\u{b8}\x04\u{b9}\x09\u{b9}\x04\u{ba}\x09\u{ba}\x04\
	\u{bb}\x09\u{bb}\x04\u{bc}\x09\u{bc}\x04\u{bd}\x09\u{bd}\x04\u{be}\x09\u{be}\
	\x04\u{bf}\x09\u{bf}\x04\u{c0}\x09\u{c0}\x04\u{c1}\x09\u{c1}\x04\u{c2}\x09\
	\u{c2}\x04\u{c3}\x09\u{c3}\x04\u{c4}\x09\u{c4}\x04\u{c5}\x09\u{c5}\x04\u{c6}\
	\x09\u{c6}\x04\u{c7}\x09\u{c7}\x04\u{c8}\x09\u{c8}\x04\u{c9}\x09\u{c9}\x04\
	\u{ca}\x09\u{ca}\x04\u{cb}\x09\u{cb}\x04\u{cc}\x09\u{cc}\x04\u{cd}\x09\u{cd}\
	\x04\u{ce}\x09\u{ce}\x04\u{cf}\x09\u{cf}\x04\u{d0}\x09\u{d0}\x04\u{d1}\x09\
	\u{d1}\x04\u{d2}\x09\u{d2}\x04\u{d3}\x09\u{d3}\x04\u{d4}\x09\u{d4}\x04\u{d5}\
	\x09\u{d5}\x04\u{d6}\x09\u{d6}\x04\u{d7}\x09\u{d7}\x04\u{d8}\x09\u{d8}\x04\
	\u{d9}\x09\u{d9}\x04\u{da}\x09\u{da}\x04\u{db}\x09\u{db}\x04\u{dc}\x09\u{dc}\
	\x04\u{dd}\x09\u{dd}\x04\u{de}\x09\u{de}\x04\u{df}\x09\u{df}\x04\u{e0}\x09\
	\u{e0}\x04\u{e1}\x09\u{e1}\x04\u{e2}\x09\u{e2}\x04\u{e3}\x09\u{e3}\x04\u{e4}\
	\x09\u{e4}\x04\u{e5}\x09\u{e5}\x04\u{e6}\x09\u{e6}\x04\u{e7}\x09\u{e7}\x04\
	\u{e8}\x09\u{e8}\x04\u{e9}\x09\u{e9}\x04\u{ea}\x09\u{ea}\x04\u{eb}\x09\u{eb}\
	\x04\u{ec}\x09\u{ec}\x04\u{ed}\x09\u{ed}\x04\u{ee}\x09\u{ee}\x04\u{ef}\x09\
	\u{ef}\x04\u{f0}\x09\u{f0}\x04\u{f1}\x09\u{f1}\x04\u{f2}\x09\u{f2}\x04\u{f3}\
	\x09\u{f3}\x04\u{f4}\x09\u{f4}\x04\u{f5}\x09\u{f5}\x04\u{f6}\x09\u{f6}\x03\
	\x02\x03\x02\x03\x03\x07\x03\u{1f0}\x0a\x03\x0c\x03\x0e\x03\u{1f3}\x0b\x03\
	\x03\x03\x03\x03\x07\x03\u{1f7}\x0a\x03\x0c\x03\x0e\x03\u{1fa}\x0b\x03\x03\
	\x03\x05\x03\u{1fd}\x0a\x03\x03\x04\x03\x04\x05\x04\u{201}\x0a\x04\x03\x05\
	\x03\x05\x03\x06\x03\x06\x03\x07\x03\x07\x03\x07\x05\x07\u{20a}\x0a\x07\
	\x03\x08\x03\x08\x05\x08\u{20e}\x0a\x08\x03\x08\x03\x08\x07\x08\u{212}\x0a\
	\x08\x0c\x08\x0e\x08\u{215}\x0b\x08\x03\x09\x07\x09\u{218}\x0a\x09\x0c\x09\
	\x0e\x09\u{21b}\x0b\x09\x03\x09\x03\x09\x05\x09\u{21f}\x0a\x09\x03\x09\x03\
	\x09\x03\x09\x07\x09\u{224}\x0a\x09\x0c\x09\x0e\x09\u{227}\x0b\x09\x03\x09\
	\x03\x09\x05\x09\u{22b}\x0a\x09\x05\x09\u{22d}\x0a\x09\x03\x0a\x03\x0a\x07\
	\x0a\u{231}\x0a\x0a\x0c\x0a\x0e\x0a\u{234}\x0b\x0a\x03\x0a\x03\x0a\x05\x0a\
	\u{238}\x0a\x0a\x03\x0b\x07\x0b\u{23b}\x0a\x0b\x0c\x0b\x0e\x0b\u{23e}\x0b\
	\x0b\x03\x0b\x03\x0b\x05\x0b\u{242}\x0a\x0b\x03\x0c\x03\x0c\x03\x0d\x03\
	\x0d\x03\x0e\x03\x0e\x03\x0f\x07\x0f\u{24b}\x0a\x0f\x0c\x0f\x0e\x0f\u{24e}\
	\x0b\x0f\x03\x0f\x03\x0f\x03\x10\x03\x10\x03\x10\x03\x10\x03\x10\x03\x10\
	\x03\x10\x03\x10\x03\x10\x05\x10\u{25b}\x0a\x10\x03\x11\x07\x11\u{25e}\x0a\
	\x11\x0c\x11\x0e\x11\u{261}\x0b\x11\x03\x11\x03\x11\x03\x11\x07\x11\u{266}\
	\x0a\x11\x0c\x11\x0e\x11\u{269}\x0b\x11\x03\x11\x03\x11\x07\x11\u{26d}\x0a\
	\x11\x0c\x11\x0e\x11\u{270}\x0b\x11\x03\x12\x07\x12\u{273}\x0a\x12\x0c\x12\
	\x0e\x12\u{276}\x0b\x12\x03\x12\x03\x12\x05\x12\u{27a}\x0a\x12\x03\x13\x03\
	\x13\x03\x14\x03\x14\x03\x14\x03\x14\x03\x14\x07\x14\u{283}\x0a\x14\x0c\
	\x14\x0e\x14\u{286}\x0b\x14\x05\x14\u{288}\x0a\x14\x03\x15\x03\x15\x03\x15\
	\x03\x16\x03\x16\x03\x16\x03\x16\x03\x17\x03\x17\x03\x17\x07\x17\u{294}\
	\x0a\x17\x0c\x17\x0e\x17\u{297}\x0b\x17\x03\x18\x03\x18\x05\x18\u{29b}\x0a\
	\x18\x03\x19\x07\x19\u{29e}\x0a\x19\x0c\x19\x0e\x19\u{2a1}\x0b\x19\x03\x19\
	\x03\x19\x05\x19\u{2a5}\x0a\x19\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x05\x1a\
	\u{2ab}\x0a\x1a\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x07\x1b\
	\u{2b3}\x0a\x1b\x0c\x1b\x0e\x1b\u{2b6}\x0b\x1b\x03\x1c\x03\x1c\x03\x1c\x03\
	\x1c\x03\x1c\x03\x1c\x07\x1c\u{2be}\x0a\x1c\x0c\x1c\x0e\x1c\u{2c1}\x0b\x1c\
	\x03\x1d\x03\x1d\x03\x1d\x03\x1d\x03\x1d\x05\x1d\u{2c8}\x0a\x1d\x03\x1e\
	\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x03\x1e\x07\x1e\u{2d0}\x0a\x1e\x0c\x1e\
	\x0e\x1e\u{2d3}\x0b\x1e\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x03\x1f\x05\x1f\
	\u{2da}\x0a\x1f\x03\x20\x03\x20\x03\x21\x03\x21\x03\x21\x03\x21\x03\x21\
	\x03\x21\x07\x21\u{2e4}\x0a\x21\x0c\x21\x0e\x21\u{2e7}\x0b\x21\x03\x22\x03\
	\x22\x05\x22\u{2eb}\x0a\x22\x03\x22\x03\x22\x03\x23\x05\x23\u{2f0}\x0a\x23\
	\x03\x23\x07\x23\u{2f3}\x0a\x23\x0c\x23\x0e\x23\u{2f6}\x0b\x23\x03\x23\x07\
	\x23\u{2f9}\x0a\x23\x0c\x23\x0e\x23\u{2fc}\x0b\x23\x03\x23\x03\x23\x03\x24\
	\x07\x24\u{301}\x0a\x24\x0c\x24\x0e\x24\u{304}\x0b\x24\x03\x24\x03\x24\x03\
	\x25\x07\x25\u{309}\x0a\x25\x0c\x25\x0e\x25\u{30c}\x0b\x25\x03\x25\x03\x25\
	\x03\x25\x03\x25\x03\x26\x03\x26\x03\x27\x03\x27\x03\x27\x03\x27\x05\x27\
	\u{318}\x0a\x27\x03\x28\x03\x28\x03\x28\x03\x28\x03\x29\x03\x29\x03\x29\
	\x03\x29\x03\x29\x03\x29\x03\x2a\x03\x2a\x03\x2a\x03\x2a\x03\x2a\x03\x2a\
	\x03\x2a\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x03\x2b\x03\x2c\
	\x03\x2c\x03\x2c\x05\x2c\u{335}\x0a\x2c\x03\x2d\x07\x2d\u{338}\x0a\x2d\x0c\
	\x2d\x0e\x2d\u{33b}\x0b\x2d\x03\x2d\x05\x2d\u{33e}\x0a\x2d\x03\x2d\x03\x2d\
	\x03\x2d\x03\x2d\x07\x2d\u{344}\x0a\x2d\x0c\x2d\x0e\x2d\u{347}\x0b\x2d\x03\
	\x2d\x03\x2d\x03\x2e\x03\x2e\x07\x2e\u{34d}\x0a\x2e\x0c\x2e\x0e\x2e\u{350}\
	\x0b\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\
	\x03\x2e\x07\x2e\u{35b}\x0a\x2e\x0c\x2e\x0e\x2e\u{35e}\x0b\x2e\x05\x2e\u{360}\
	\x0a\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\
	\x07\x2e\u{36a}\x0a\x2e\x0c\x2e\x0e\x2e\u{36d}\x0b\x2e\x05\x2e\u{36f}\x0a\
	\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\x2e\x03\
	\x2e\x03\x2e\x03\x2e\x03\x2e\x07\x2e\u{37d}\x0a\x2e\x0c\x2e\x0e\x2e\u{380}\
	\x0b\x2e\x03\x2e\x03\x2e\x05\x2e\u{384}\x0a\x2e\x03\x2f\x03\x2f\x03\x30\
	\x03\x30\x05\x30\u{38a}\x0a\x30\x03\x31\x07\x31\u{38d}\x0a\x31\x0c\x31\x0e\
	\x31\u{390}\x0b\x31\x03\x31\x03\x31\x03\x31\x05\x31\u{395}\x0a\x31\x03\x31\
	\x05\x31\u{398}\x0a\x31\x03\x31\x05\x31\u{39b}\x0a\x31\x03\x31\x03\x31\x03\
	\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x03\x32\x05\x32\u{3a7}\
	\x0a\x32\x03\x33\x03\x33\x03\x33\x03\x33\x03\x34\x03\x34\x03\x34\x07\x34\
	\u{3b0}\x0a\x34\x0c\x34\x0e\x34\u{3b3}\x0b\x34\x03\x35\x03\x35\x03\x35\x03\
	\x36\x03\x36\x03\x36\x03\x37\x03\x37\x03\x37\x07\x37\u{3be}\x0a\x37\x0c\
	\x37\x0e\x37\u{3c1}\x0b\x37\x03\x38\x03\x38\x07\x38\u{3c5}\x0a\x38\x0c\x38\
	\x0e\x38\u{3c8}\x0b\x38\x03\x38\x03\x38\x03\x39\x03\x39\x03\x39\x03\x39\
	\x05\x39\u{3d0}\x0a\x39\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x03\x3a\x05\x3a\
	\u{3d7}\x0a\x3a\x03\x3b\x07\x3b\u{3da}\x0a\x3b\x0c\x3b\x0e\x3b\u{3dd}\x0b\
	\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\
	\x3c\x03\x3c\x03\x3c\x03\x3c\x05\x3c\u{3eb}\x0a\x3c\x03\x3d\x03\x3d\x03\
	\x3d\x07\x3d\u{3f0}\x0a\x3d\x0c\x3d\x0e\x3d\u{3f3}\x0b\x3d\x03\x3e\x03\x3e\
	\x03\x3e\x05\x3e\u{3f8}\x0a\x3e\x03\x3f\x03\x3f\x05\x3f\u{3fc}\x0a\x3f\x03\
	\x40\x03\x40\x05\x40\u{400}\x0a\x40\x03\x41\x03\x41\x05\x41\u{404}\x0a\x41\
	\x03\x42\x03\x42\x05\x42\u{408}\x0a\x42\x03\x43\x03\x43\x03\x43\x05\x43\
	\u{40d}\x0a\x43\x03\x44\x03\x44\x05\x44\u{411}\x0a\x44\x03\x44\x03\x44\x07\
	\x44\u{415}\x0a\x44\x0c\x44\x0e\x44\u{418}\x0b\x44\x03\x45\x03\x45\x05\x45\
	\u{41c}\x0a\x45\x03\x45\x03\x45\x03\x45\x07\x45\u{421}\x0a\x45\x0c\x45\x0e\
	\x45\u{424}\x0b\x45\x03\x45\x03\x45\x05\x45\u{428}\x0a\x45\x05\x45\u{42a}\
	\x0a\x45\x03\x46\x03\x46\x07\x46\u{42e}\x0a\x46\x0c\x46\x0e\x46\u{431}\x0b\
	\x46\x03\x46\x03\x46\x05\x46\u{435}\x0a\x46\x03\x47\x03\x47\x05\x47\u{439}\
	\x0a\x47\x03\x48\x03\x48\x03\x49\x03\x49\x03\x4a\x03\x4a\x03\x4b\x03\x4b\
	\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4c\
	\x05\x4c\u{44c}\x0a\x4c\x03\x4d\x07\x4d\u{44f}\x0a\x4d\x0c\x4d\x0e\x4d\u{452}\
	\x0b\x4d\x03\x4d\x03\x4d\x03\x4d\x03\x4e\x03\x4e\x03\x4e\x03\x4e\x03\x4e\
	\x03\x4e\x03\x4e\x03\x4e\x03\x4e\x03\x4e\x05\x4e\u{461}\x0a\x4e\x03\x4f\
	\x03\x4f\x03\x4f\x05\x4f\u{466}\x0a\x4f\x03\x4f\x03\x4f\x07\x4f\u{46a}\x0a\
	\x4f\x0c\x4f\x0e\x4f\u{46d}\x0b\x4f\x03\x4f\x03\x4f\x03\x4f\x05\x4f\u{472}\
	\x0a\x4f\x05\x4f\u{474}\x0a\x4f\x03\x50\x03\x50\x05\x50\u{478}\x0a\x50\x03\
	\x51\x03\x51\x03\x51\x05\x51\u{47d}\x0a\x51\x03\x51\x03\x51\x05\x51\u{481}\
	\x0a\x51\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x05\x52\u{489}\
	\x0a\x52\x03\x53\x03\x53\x03\x53\x07\x53\u{48e}\x0a\x53\x0c\x53\x0e\x53\
	\u{491}\x0b\x53\x03\x53\x03\x53\x03\x53\x07\x53\u{496}\x0a\x53\x0c\x53\x0e\
	\x53\u{499}\x0b\x53\x05\x53\u{49b}\x0a\x53\x03\x54\x07\x54\u{49e}\x0a\x54\
	\x0c\x54\x0e\x54\u{4a1}\x0b\x54\x03\x54\x03\x54\x03\x54\x03\x55\x03\x55\
	\x05\x55\u{4a8}\x0a\x55\x03\x56\x07\x56\u{4ab}\x0a\x56\x0c\x56\x0e\x56\u{4ae}\
	\x0b\x56\x03\x56\x03\x56\x07\x56\u{4b2}\x0a\x56\x0c\x56\x0e\x56\u{4b5}\x0b\
	\x56\x03\x56\x03\x56\x03\x56\x03\x56\x05\x56\u{4bb}\x0a\x56\x03\x57\x07\
	\x57\u{4be}\x0a\x57\x0c\x57\x0e\x57\u{4c1}\x0b\x57\x03\x57\x03\x57\x03\x57\
	\x03\x57\x05\x57\u{4c7}\x0a\x57\x03\x57\x03\x57\x03\x58\x03\x58\x03\x58\
	\x03\x59\x03\x59\x03\x59\x07\x59\u{4d1}\x0a\x59\x0c\x59\x0e\x59\u{4d4}\x0b\
	\x59\x03\x5a\x03\x5a\x05\x5a\u{4d8}\x0a\x5a\x03\x5b\x03\x5b\x05\x5b\u{4dc}\
	\x0a\x5b\x03\x5c\x03\x5c\x03\x5d\x03\x5d\x03\x5d\x03\x5e\x07\x5e\u{4e4}\
	\x0a\x5e\x0c\x5e\x0e\x5e\u{4e7}\x0b\x5e\x03\x5e\x03\x5e\x05\x5e\u{4eb}\x0a\
	\x5e\x03\x5e\x03\x5e\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x05\x5f\u{4f3}\x0a\
	\x5f\x03\x60\x05\x60\u{4f6}\x0a\x60\x03\x60\x03\x60\x03\x60\x05\x60\u{4fb}\
	\x0a\x60\x03\x60\x03\x60\x03\x61\x03\x61\x03\x62\x03\x62\x05\x62\u{503}\
	\x0a\x62\x03\x62\x05\x62\u{506}\x0a\x62\x03\x62\x03\x62\x03\x63\x05\x63\
	\u{50b}\x0a\x63\x03\x63\x03\x63\x03\x63\x05\x63\u{510}\x0a\x63\x03\x63\x03\
	\x63\x03\x63\x05\x63\u{515}\x0a\x63\x03\x63\x03\x63\x03\x63\x05\x63\u{51a}\
	\x0a\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x05\x63\u{521}\x0a\x63\
	\x03\x63\x03\x63\x03\x63\x05\x63\u{526}\x0a\x63\x03\x63\x03\x63\x03\x63\
	\x03\x63\x03\x63\x03\x63\x05\x63\u{52e}\x0a\x63\x03\x63\x03\x63\x03\x63\
	\x05\x63\u{533}\x0a\x63\x03\x63\x03\x63\x03\x63\x05\x63\u{538}\x0a\x63\x03\
	\x64\x07\x64\u{53b}\x0a\x64\x0c\x64\x0e\x64\u{53e}\x0b\x64\x03\x64\x03\x64\
	\x03\x64\x05\x64\u{543}\x0a\x64\x03\x64\x03\x64\x03\x65\x03\x65\x05\x65\
	\u{549}\x0a\x65\x03\x65\x05\x65\u{54c}\x0a\x65\x03\x65\x05\x65\u{54f}\x0a\
	\x65\x03\x65\x03\x65\x03\x66\x03\x66\x03\x66\x07\x66\u{556}\x0a\x66\x0c\
	\x66\x0e\x66\u{559}\x0b\x66\x03\x67\x07\x67\u{55c}\x0a\x67\x0c\x67\x0e\x67\
	\u{55f}\x0b\x67\x03\x67\x03\x67\x03\x67\x05\x67\u{564}\x0a\x67\x03\x67\x05\
	\x67\u{567}\x0a\x67\x03\x67\x05\x67\u{56a}\x0a\x67\x03\x68\x03\x68\x03\x69\
	\x03\x69\x07\x69\u{570}\x0a\x69\x0c\x69\x0e\x69\u{573}\x0b\x69\x03\x6a\x03\
	\x6a\x05\x6a\u{577}\x0a\x6a\x03\x6b\x07\x6b\u{57a}\x0a\x6b\x0c\x6b\x0e\x6b\
	\u{57d}\x0b\x6b\x03\x6b\x03\x6b\x03\x6b\x05\x6b\u{582}\x0a\x6b\x03\x6b\x05\
	\x6b\u{585}\x0a\x6b\x03\x6b\x03\x6b\x03\x6c\x03\x6c\x03\x6c\x03\x6c\x03\
	\x6c\x03\x6c\x03\x6c\x05\x6c\u{590}\x0a\x6c\x03\x6d\x03\x6d\x03\x6d\x03\
	\x6e\x03\x6e\x07\x6e\u{597}\x0a\x6e\x0c\x6e\x0e\x6e\u{59a}\x0b\x6e\x03\x6e\
	\x03\x6e\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x05\x6f\u{5a3}\x0a\x6f\
	\x03\x70\x07\x70\u{5a6}\x0a\x70\x0c\x70\x0e\x70\u{5a9}\x0b\x70\x03\x70\x03\
	\x70\x03\x70\x03\x70\x03\x71\x03\x71\x03\x71\x03\x71\x05\x71\u{5b3}\x0a\
	\x71\x03\x72\x07\x72\u{5b6}\x0a\x72\x0c\x72\x0e\x72\u{5b9}\x0b\x72\x03\x72\
	\x03\x72\x03\x72\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\
	\x05\x73\u{5c5}\x0a\x73\x03\x74\x07\x74\u{5c8}\x0a\x74\x0c\x74\x0e\x74\u{5cb}\
	\x0b\x74\x03\x74\x03\x74\x03\x74\x03\x74\x03\x74\x03\x75\x03\x75\x07\x75\
	\u{5d4}\x0a\x75\x0c\x75\x0e\x75\u{5d7}\x0b\x75\x03\x75\x03\x75\x03\x76\x03\
	\x76\x03\x76\x03\x76\x03\x76\x05\x76\u{5e0}\x0a\x76\x03\x77\x07\x77\u{5e3}\
	\x0a\x77\x0c\x77\x0e\x77\u{5e6}\x0b\x77\x03\x77\x03\x77\x03\x77\x03\x77\
	\x03\x77\x05\x77\u{5ed}\x0a\x77\x03\x77\x05\x77\u{5f0}\x0a\x77\x03\x77\x03\
	\x77\x03\x78\x03\x78\x03\x78\x05\x78\u{5f7}\x0a\x78\x03\x79\x03\x79\x03\
	\x79\x03\x7a\x03\x7a\x03\x7a\x05\x7a\u{5ff}\x0a\x7a\x03\x7b\x03\x7b\x03\
	\x7b\x03\x7b\x05\x7b\u{605}\x0a\x7b\x03\x7b\x03\x7b\x03\x7c\x03\x7c\x03\
	\x7c\x07\x7c\u{60c}\x0a\x7c\x0c\x7c\x0e\x7c\u{60f}\x0b\x7c\x03\x7d\x03\x7d\
	\x03\x7d\x03\x7d\x03\x7e\x03\x7e\x03\x7e\x05\x7e\u{618}\x0a\x7e\x03\x7f\
	\x03\x7f\x05\x7f\u{61c}\x0a\x7f\x03\x7f\x05\x7f\u{61f}\x0a\x7f\x03\x7f\x03\
	\x7f\x03\u{80}\x03\u{80}\x03\u{80}\x07\u{80}\u{626}\x0a\u{80}\x0c\u{80}\
	\x0e\u{80}\u{629}\x0b\u{80}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{82}\x03\
	\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{83}\x03\u{83}\x05\u{83}\
	\u{636}\x0a\u{83}\x03\u{83}\x05\u{83}\u{639}\x0a\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{84}\x03\u{84}\x03\u{84}\x07\u{84}\u{640}\x0a\u{84}\x0c\u{84}\x0e\
	\u{84}\u{643}\x0b\u{84}\x03\u{85}\x03\u{85}\x05\u{85}\u{647}\x0a\u{85}\x03\
	\u{85}\x03\u{85}\x03\u{86}\x06\u{86}\u{64c}\x0a\u{86}\x0d\u{86}\x0e\u{86}\
	\u{64d}\x03\u{87}\x03\u{87}\x03\u{87}\x05\u{87}\u{653}\x0a\u{87}\x03\u{88}\
	\x03\u{88}\x03\u{88}\x03\u{89}\x07\u{89}\u{659}\x0a\u{89}\x0c\u{89}\x0e\
	\u{89}\u{65c}\x0b\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x03\u{8a}\x03\u{8a}\
	\x03\u{8a}\x03\u{8a}\x03\u{8a}\x03\u{8a}\x05\u{8a}\u{667}\x0a\u{8a}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x05\u{8b}\u{66e}\x0a\u{8b}\
	\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\
	\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x05\u{8c}\u{67c}\x0a\u{8c}\
	\x03\u{8d}\x03\u{8d}\x03\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8f}\x03\
	\u{8f}\x03\u{8f}\x03\u{8f}\x03\u{90}\x03\u{90}\x03\u{90}\x03\u{91}\x03\u{91}\
	\x03\u{91}\x03\u{91}\x03\u{91}\x03\u{91}\x03\u{91}\x05\u{91}\u{692}\x0a\
	\u{91}\x03\u{92}\x03\u{92}\x03\u{92}\x03\u{92}\x03\u{92}\x03\u{92}\x03\u{93}\
	\x03\u{93}\x03\u{93}\x03\u{93}\x03\u{93}\x03\u{93}\x03\u{93}\x03\u{93}\x03\
	\u{94}\x03\u{94}\x03\u{94}\x03\u{94}\x03\u{94}\x03\u{94}\x03\u{94}\x03\u{94}\
	\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\
	\u{95}\x03\u{95}\x03\u{95}\x05\u{95}\u{6b4}\x0a\u{95}\x03\u{96}\x03\u{96}\
	\x03\u{96}\x03\u{96}\x03\u{96}\x03\u{96}\x03\u{97}\x03\u{97}\x07\u{97}\u{6be}\
	\x0a\u{97}\x0c\u{97}\x0e\u{97}\u{6c1}\x0b\u{97}\x03\u{97}\x07\u{97}\u{6c4}\
	\x0a\u{97}\x0c\u{97}\x0e\u{97}\u{6c7}\x0b\u{97}\x03\u{97}\x03\u{97}\x03\
	\u{98}\x03\u{98}\x03\u{98}\x03\u{99}\x06\u{99}\u{6cf}\x0a\u{99}\x0d\u{99}\
	\x0e\u{99}\u{6d0}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\
	\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x05\u{9a}\u{6dd}\x0a\u{9a}\
	\x03\u{9b}\x03\u{9b}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\
	\u{9c}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9e}\
	\x03\u{9e}\x03\u{9e}\x03\u{9e}\x03\u{9e}\x03\u{9e}\x03\u{9e}\x03\u{9e}\x03\
	\u{9f}\x03\u{9f}\x05\u{9f}\u{6f7}\x0a\u{9f}\x03\u{a0}\x03\u{a0}\x05\u{a0}\
	\u{6fb}\x0a\u{a0}\x03\u{a1}\x03\u{a1}\x03\u{a1}\x05\u{a1}\u{700}\x0a\u{a1}\
	\x03\u{a1}\x03\u{a1}\x05\u{a1}\u{704}\x0a\u{a1}\x03\u{a1}\x03\u{a1}\x05\
	\u{a1}\u{708}\x0a\u{a1}\x03\u{a1}\x03\u{a1}\x03\u{a1}\x03\u{a2}\x03\u{a2}\
	\x03\u{a2}\x05\u{a2}\u{710}\x0a\u{a2}\x03\u{a2}\x03\u{a2}\x05\u{a2}\u{714}\
	\x0a\u{a2}\x03\u{a2}\x03\u{a2}\x05\u{a2}\u{718}\x0a\u{a2}\x03\u{a2}\x03\
	\u{a2}\x03\u{a2}\x03\u{a3}\x03\u{a3}\x05\u{a3}\u{71f}\x0a\u{a3}\x03\u{a4}\
	\x03\u{a4}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x07\u{a5}\u{726}\x0a\u{a5}\x0c\
	\u{a5}\x0e\u{a5}\u{729}\x0b\u{a5}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x07\u{a6}\
	\u{72e}\x0a\u{a6}\x0c\u{a6}\x0e\u{a6}\u{731}\x0b\u{a6}\x03\u{a6}\x03\u{a6}\
	\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a7}\x03\u{a7}\x03\
	\u{a7}\x07\u{a7}\u{73d}\x0a\u{a7}\x0c\u{a7}\x0e\u{a7}\u{740}\x0b\u{a7}\x03\
	\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a8}\
	\x03\u{a8}\x05\u{a8}\u{74b}\x0a\u{a8}\x03\u{a8}\x03\u{a8}\x03\u{a9}\x03\
	\u{a9}\x05\u{a9}\u{751}\x0a\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{aa}\x03\u{aa}\
	\x05\u{aa}\u{757}\x0a\u{aa}\x03\u{aa}\x03\u{aa}\x03\u{ab}\x03\u{ab}\x03\
	\u{ab}\x03\u{ab}\x03\u{ac}\x03\u{ac}\x03\u{ac}\x03\u{ac}\x03\u{ac}\x03\u{ac}\
	\x03\u{ad}\x03\u{ad}\x03\u{ad}\x03\u{ad}\x03\u{ad}\x03\u{ad}\x03\u{ad}\x05\
	\u{ad}\u{76c}\x0a\u{ad}\x03\u{ad}\x03\u{ad}\x03\u{ad}\x05\u{ad}\u{771}\x0a\
	\u{ad}\x03\u{ae}\x06\u{ae}\u{774}\x0a\u{ae}\x0d\u{ae}\x0e\u{ae}\u{775}\x03\
	\u{af}\x03\u{af}\x03\u{af}\x03\u{af}\x03\u{af}\x03\u{af}\x03\u{b0}\x07\u{b0}\
	\u{77f}\x0a\u{b0}\x0c\u{b0}\x0e\u{b0}\u{782}\x0b\u{b0}\x03\u{b0}\x03\u{b0}\
	\x03\u{b0}\x03\u{b1}\x03\u{b1}\x03\u{b1}\x07\u{b1}\u{78a}\x0a\u{b1}\x0c\
	\u{b1}\x0e\u{b1}\u{78d}\x0b\u{b1}\x03\u{b2}\x03\u{b2}\x03\u{b2}\x03\u{b3}\
	\x03\u{b3}\x03\u{b3}\x03\u{b3}\x05\u{b3}\u{796}\x0a\u{b3}\x03\u{b3}\x05\
	\u{b3}\u{799}\x0a\u{b3}\x03\u{b4}\x03\u{b4}\x03\u{b4}\x05\u{b4}\u{79e}\x0a\
	\u{b4}\x03\u{b4}\x03\u{b4}\x03\u{b5}\x03\u{b5}\x03\u{b5}\x07\u{b5}\u{7a5}\
	\x0a\u{b5}\x0c\u{b5}\x0e\u{b5}\u{7a8}\x0b\u{b5}\x03\u{b6}\x07\u{b6}\u{7ab}\
	\x0a\u{b6}\x0c\u{b6}\x0e\u{b6}\u{7ae}\x0b\u{b6}\x03\u{b6}\x03\u{b6}\x03\
	\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x05\u{b6}\u{7b6}\x0a\u{b6}\x03\u{b7}\
	\x03\u{b7}\x05\u{b7}\u{7ba}\x0a\u{b7}\x03\u{b8}\x03\u{b8}\x05\u{b8}\u{7be}\
	\x0a\u{b8}\x03\u{b8}\x07\u{b8}\u{7c1}\x0a\u{b8}\x0c\u{b8}\x0e\u{b8}\u{7c4}\
	\x0b\u{b8}\x03\u{b9}\x03\u{b9}\x03\u{b9}\x03\u{b9}\x03\u{b9}\x03\u{b9}\x03\
	\u{b9}\x03\u{b9}\x03\u{b9}\x03\u{b9}\x03\u{b9}\x03\u{b9}\x03\u{b9}\x03\u{b9}\
	\x03\u{b9}\x03\u{b9}\x05\u{b9}\u{7d6}\x0a\u{b9}\x03\u{ba}\x03\u{ba}\x03\
	\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x07\u{bb}\u{7de}\x0a\u{bb}\x0c\u{bb}\
	\x0e\u{bb}\u{7e1}\x0b\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\
	\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\
	\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x05\
	\u{bb}\u{7f6}\x0a\u{bb}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bc}\
	\x05\u{bc}\u{7fd}\x0a\u{bc}\x03\u{bd}\x03\u{bd}\x03\u{be}\x03\u{be}\x03\
	\u{be}\x03\u{be}\x05\u{be}\u{805}\x0a\u{be}\x03\u{bf}\x03\u{bf}\x03\u{bf}\
	\x03\u{bf}\x07\u{bf}\u{80b}\x0a\u{bf}\x0c\u{bf}\x0e\u{bf}\u{80e}\x0b\u{bf}\
	\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x07\u{bf}\u{816}\
	\x0a\u{bf}\x0c\u{bf}\x0e\u{bf}\u{819}\x0b\u{bf}\x03\u{bf}\x03\u{bf}\x03\
	\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\
	\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\
	\u{bf}\x03\u{bf}\x03\u{bf}\x05\u{bf}\u{82f}\x0a\u{bf}\x03\u{c0}\x03\u{c0}\
	\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x07\u{c1}\u{837}\x0a\u{c1}\x0c\
	\u{c1}\x0e\u{c1}\u{83a}\x0b\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\
	\x03\u{c1}\x03\u{c1}\x07\u{c1}\u{842}\x0a\u{c1}\x0c\u{c1}\x0e\u{c1}\u{845}\
	\x0b\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\
	\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\
	\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x05\u{c1}\u{85a}\x0a\
	\u{c1}\x03\u{c2}\x03\u{c2}\x03\u{c2}\x05\u{c2}\u{85f}\x0a\u{c2}\x03\u{c2}\
	\x03\u{c2}\x07\u{c2}\u{863}\x0a\u{c2}\x0c\u{c2}\x0e\u{c2}\u{866}\x0b\u{c2}\
	\x03\u{c2}\x03\u{c2}\x03\u{c2}\x03\u{c2}\x03\u{c2}\x05\u{c2}\u{86d}\x0a\
	\u{c2}\x03\u{c3}\x03\u{c3}\x05\u{c3}\u{871}\x0a\u{c3}\x03\u{c3}\x07\u{c3}\
	\u{874}\x0a\u{c3}\x0c\u{c3}\x0e\u{c3}\u{877}\x0b\u{c3}\x03\u{c3}\x03\u{c3}\
	\x03\u{c3}\x07\u{c3}\u{87c}\x0a\u{c3}\x0c\u{c3}\x0e\u{c3}\u{87f}\x0b\u{c3}\
	\x03\u{c3}\x07\u{c3}\u{882}\x0a\u{c3}\x0c\u{c3}\x0e\u{c3}\u{885}\x0b\u{c3}\
	\x03\u{c3}\x05\u{c3}\u{888}\x0a\u{c3}\x03\u{c3}\x03\u{c3}\x05\u{c3}\u{88c}\
	\x0a\u{c3}\x03\u{c3}\x03\u{c3}\x05\u{c3}\u{890}\x0a\u{c3}\x03\u{c3}\x03\
	\u{c3}\x03\u{c3}\x03\u{c3}\x05\u{c3}\u{896}\x0a\u{c3}\x03\u{c3}\x07\u{c3}\
	\u{899}\x0a\u{c3}\x0c\u{c3}\x0e\u{c3}\u{89c}\x0b\u{c3}\x03\u{c3}\x03\u{c3}\
	\x05\u{c3}\u{8a0}\x0a\u{c3}\x03\u{c3}\x03\u{c3}\x05\u{c3}\u{8a4}\x0a\u{c3}\
	\x03\u{c3}\x03\u{c3}\x05\u{c3}\u{8a8}\x0a\u{c3}\x03\u{c3}\x03\u{c3}\x03\
	\u{c3}\x03\u{c3}\x05\u{c3}\u{8ae}\x0a\u{c3}\x03\u{c3}\x07\u{c3}\u{8b1}\x0a\
	\u{c3}\x0c\u{c3}\x0e\u{c3}\u{8b4}\x0b\u{c3}\x03\u{c3}\x03\u{c3}\x05\u{c3}\
	\u{8b8}\x0a\u{c3}\x03\u{c3}\x03\u{c3}\x05\u{c3}\u{8bc}\x0a\u{c3}\x03\u{c3}\
	\x03\u{c3}\x05\u{c3}\u{8c0}\x0a\u{c3}\x05\u{c3}\u{8c2}\x0a\u{c3}\x03\u{c4}\
	\x03\u{c4}\x03\u{c4}\x05\u{c4}\u{8c7}\x0a\u{c4}\x03\u{c4}\x07\u{c4}\u{8ca}\
	\x0a\u{c4}\x0c\u{c4}\x0e\u{c4}\u{8cd}\x0b\u{c4}\x03\u{c4}\x03\u{c4}\x05\
	\u{c4}\u{8d1}\x0a\u{c4}\x03\u{c4}\x03\u{c4}\x05\u{c4}\u{8d5}\x0a\u{c4}\x03\
	\u{c4}\x03\u{c4}\x05\u{c4}\u{8d9}\x0a\u{c4}\x03\u{c5}\x03\u{c5}\x05\u{c5}\
	\u{8dd}\x0a\u{c5}\x03\u{c5}\x07\u{c5}\u{8e0}\x0a\u{c5}\x0c\u{c5}\x0e\u{c5}\
	\u{8e3}\x0b\u{c5}\x03\u{c5}\x03\u{c5}\x03\u{c5}\x07\u{c5}\u{8e8}\x0a\u{c5}\
	\x0c\u{c5}\x0e\u{c5}\u{8eb}\x0b\u{c5}\x03\u{c5}\x07\u{c5}\u{8ee}\x0a\u{c5}\
	\x0c\u{c5}\x0e\u{c5}\u{8f1}\x0b\u{c5}\x03\u{c5}\x05\u{c5}\u{8f4}\x0a\u{c5}\
	\x03\u{c5}\x03\u{c5}\x05\u{c5}\u{8f8}\x0a\u{c5}\x03\u{c5}\x03\u{c5}\x05\
	\u{c5}\u{8fc}\x0a\u{c5}\x03\u{c5}\x03\u{c5}\x03\u{c5}\x03\u{c5}\x05\u{c5}\
	\u{902}\x0a\u{c5}\x03\u{c5}\x07\u{c5}\u{905}\x0a\u{c5}\x0c\u{c5}\x0e\u{c5}\
	\u{908}\x0b\u{c5}\x03\u{c5}\x03\u{c5}\x05\u{c5}\u{90c}\x0a\u{c5}\x03\u{c5}\
	\x03\u{c5}\x05\u{c5}\u{910}\x0a\u{c5}\x03\u{c5}\x03\u{c5}\x05\u{c5}\u{914}\
	\x0a\u{c5}\x05\u{c5}\u{916}\x0a\u{c5}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x05\
	\u{c6}\u{91b}\x0a\u{c6}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\
	\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\
	\u{c7}\x05\u{c7}\u{92a}\x0a\u{c7}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c9}\
	\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\
	\u{c9}\x05\u{c9}\u{938}\x0a\u{c9}\x03\u{ca}\x03\u{ca}\x03\u{ca}\x03\u{ca}\
	\x03\u{ca}\x03\u{ca}\x03\u{ca}\x03\u{ca}\x03\u{ca}\x03\u{ca}\x05\u{ca}\u{944}\
	\x0a\u{ca}\x03\u{ca}\x03\u{ca}\x03\u{ca}\x03\u{ca}\x03\u{ca}\x07\u{ca}\u{94b}\
	\x0a\u{ca}\x0c\u{ca}\x0e\u{ca}\u{94e}\x0b\u{ca}\x03\u{cb}\x03\u{cb}\x03\
	\u{cb}\x03\u{cb}\x03\u{cb}\x03\u{cb}\x03\u{cb}\x03\u{cb}\x03\u{cb}\x03\u{cb}\
	\x07\u{cb}\u{95a}\x0a\u{cb}\x0c\u{cb}\x0e\u{cb}\u{95d}\x0b\u{cb}\x03\u{cc}\
	\x03\u{cc}\x03\u{cc}\x03\u{cc}\x03\u{cc}\x03\u{cc}\x03\u{cc}\x03\u{cc}\x03\
	\u{cc}\x03\u{cc}\x05\u{cc}\u{969}\x0a\u{cc}\x03\u{cc}\x03\u{cc}\x03\u{cc}\
	\x03\u{cc}\x03\u{cc}\x07\u{cc}\u{970}\x0a\u{cc}\x0c\u{cc}\x0e\u{cc}\u{973}\
	\x0b\u{cc}\x03\u{cd}\x03\u{cd}\x03\u{cd}\x05\u{cd}\u{978}\x0a\u{cd}\x03\
	\u{cd}\x03\u{cd}\x03\u{cd}\x03\u{cd}\x03\u{cd}\x05\u{cd}\u{97f}\x0a\u{cd}\
	\x03\u{cd}\x03\u{cd}\x03\u{cd}\x05\u{cd}\u{984}\x0a\u{cd}\x03\u{cd}\x03\
	\u{cd}\x03\u{cd}\x03\u{cd}\x03\u{cd}\x05\u{cd}\u{98b}\x0a\u{cd}\x03\u{cd}\
	\x03\u{cd}\x03\u{cd}\x05\u{cd}\u{990}\x0a\u{cd}\x03\u{cd}\x03\u{cd}\x03\
	\u{cd}\x03\u{cd}\x03\u{cd}\x05\u{cd}\u{997}\x0a\u{cd}\x03\u{cd}\x03\u{cd}\
	\x03\u{cd}\x05\u{cd}\u{99c}\x0a\u{cd}\x03\u{cd}\x03\u{cd}\x03\u{cd}\x03\
	\u{cd}\x03\u{cd}\x05\u{cd}\u{9a3}\x0a\u{cd}\x03\u{cd}\x03\u{cd}\x03\u{cd}\
	\x05\u{cd}\u{9a8}\x0a\u{cd}\x03\u{cd}\x03\u{cd}\x03\u{cd}\x03\u{cd}\x03\
	\u{cd}\x03\u{cd}\x03\u{cd}\x05\u{cd}\u{9b1}\x0a\u{cd}\x03\u{cd}\x03\u{cd}\
	\x03\u{cd}\x05\u{cd}\u{9b6}\x0a\u{cd}\x03\u{cd}\x03\u{cd}\x05\u{cd}\u{9ba}\
	\x0a\u{cd}\x03\u{ce}\x03\u{ce}\x05\u{ce}\u{9be}\x0a\u{ce}\x03\u{ce}\x03\
	\u{ce}\x03\u{ce}\x05\u{ce}\u{9c3}\x0a\u{ce}\x03\u{ce}\x03\u{ce}\x03\u{cf}\
	\x03\u{cf}\x03\u{cf}\x05\u{cf}\u{9ca}\x0a\u{cf}\x03\u{cf}\x03\u{cf}\x03\
	\u{cf}\x03\u{cf}\x03\u{cf}\x05\u{cf}\u{9d1}\x0a\u{cf}\x03\u{cf}\x03\u{cf}\
	\x03\u{cf}\x05\u{cf}\u{9d6}\x0a\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\
	\u{cf}\x03\u{cf}\x05\u{cf}\u{9dd}\x0a\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\
	\x05\u{cf}\u{9e2}\x0a\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\
	\u{cf}\x05\u{cf}\u{9e9}\x0a\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x05\u{cf}\
	\u{9ee}\x0a\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\
	\u{cf}\x03\u{cf}\x05\u{cf}\u{9f7}\x0a\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\
	\x05\u{cf}\u{9fc}\x0a\u{cf}\x03\u{cf}\x03\u{cf}\x05\u{cf}\u{a00}\x0a\u{cf}\
	\x03\u{d0}\x03\u{d0}\x03\u{d0}\x07\u{d0}\u{a05}\x0a\u{d0}\x0c\u{d0}\x0e\
	\u{d0}\u{a08}\x0b\u{d0}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x05\u{d1}\u{a0d}\x0a\
	\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x05\u{d1}\u{a14}\
	\x0a\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x05\u{d1}\u{a1b}\
	\x0a\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x05\u{d1}\u{a22}\
	\x0a\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x05\
	\u{d1}\u{a2a}\x0a\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\
	\x05\u{d1}\u{a31}\x0a\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\
	\u{d1}\x03\u{d1}\x05\u{d1}\u{a39}\x0a\u{d1}\x03\u{d2}\x03\u{d2}\x05\u{d2}\
	\u{a3d}\x0a\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x05\
	\u{d3}\u{a44}\x0a\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\
	\x05\u{d3}\u{a4b}\x0a\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\
	\u{d3}\x05\u{d3}\u{a52}\x0a\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\
	\x03\u{d3}\x03\u{d3}\x05\u{d3}\u{a5a}\x0a\u{d3}\x03\u{d3}\x03\u{d3}\x03\
	\u{d3}\x03\u{d3}\x03\u{d3}\x05\u{d3}\u{a61}\x0a\u{d3}\x03\u{d3}\x03\u{d3}\
	\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x05\u{d3}\u{a69}\x0a\u{d3}\x03\
	\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x05\u{d4}\u{a6f}\x0a\u{d4}\x03\u{d4}\
	\x03\u{d4}\x03\u{d4}\x03\u{d4}\x05\u{d4}\u{a75}\x0a\u{d4}\x03\u{d4}\x03\
	\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\
	\x03\u{d4}\x05\u{d4}\u{a81}\x0a\u{d4}\x03\u{d5}\x06\u{d5}\u{a84}\x0a\u{d5}\
	\x0d\u{d5}\x0e\u{d5}\u{a85}\x03\u{d6}\x07\u{d6}\u{a89}\x0a\u{d6}\x0c\u{d6}\
	\x0e\u{d6}\u{a8c}\x0b\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\x03\
	\u{d7}\x03\u{d7}\x03\u{d8}\x03\u{d8}\x05\u{d8}\u{a96}\x0a\u{d8}\x03\u{d9}\
	\x03\u{d9}\x03\u{d9}\x03\u{d9}\x03\u{da}\x03\u{da}\x03\u{da}\x05\u{da}\u{a9f}\
	\x0a\u{da}\x03\u{da}\x03\u{da}\x03\u{da}\x03\u{da}\x03\u{da}\x05\u{da}\u{aa6}\
	\x0a\u{da}\x03\u{db}\x03\u{db}\x03\u{db}\x07\u{db}\u{aab}\x0a\u{db}\x0c\
	\u{db}\x0e\u{db}\u{aae}\x0b\u{db}\x03\u{dc}\x03\u{dc}\x05\u{dc}\u{ab2}\x0a\
	\u{dc}\x03\u{dd}\x03\u{dd}\x05\u{dd}\u{ab6}\x0a\u{dd}\x03\u{de}\x03\u{de}\
	\x03\u{de}\x03\u{de}\x03\u{df}\x03\u{df}\x03\u{df}\x05\u{df}\u{abf}\x0a\
	\u{df}\x03\u{e0}\x03\u{e0}\x03\u{e1}\x03\u{e1}\x03\u{e1}\x03\u{e1}\x03\u{e1}\
	\x03\u{e1}\x03\u{e1}\x05\u{e1}\u{aca}\x0a\u{e1}\x05\u{e1}\u{acc}\x0a\u{e1}\
	\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x07\u{e2}\u{ad4}\
	\x0a\u{e2}\x0c\u{e2}\x0e\u{e2}\u{ad7}\x0b\u{e2}\x03\u{e3}\x03\u{e3}\x03\
	\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x07\u{e3}\u{adf}\x0a\u{e3}\x0c\u{e3}\
	\x0e\u{e3}\u{ae2}\x0b\u{e3}\x03\u{e4}\x03\u{e4}\x03\u{e4}\x03\u{e4}\x03\
	\u{e4}\x03\u{e4}\x07\u{e4}\u{aea}\x0a\u{e4}\x0c\u{e4}\x0e\u{e4}\u{aed}\x0b\
	\u{e4}\x03\u{e5}\x03\u{e5}\x03\u{e5}\x03\u{e5}\x03\u{e5}\x03\u{e5}\x07\u{e5}\
	\u{af5}\x0a\u{e5}\x0c\u{e5}\x0e\u{e5}\u{af8}\x0b\u{e5}\x03\u{e6}\x03\u{e6}\
	\x03\u{e6}\x03\u{e6}\x03\u{e6}\x03\u{e6}\x07\u{e6}\u{b00}\x0a\u{e6}\x0c\
	\u{e6}\x0e\u{e6}\u{b03}\x0b\u{e6}\x03\u{e7}\x03\u{e7}\x03\u{e7}\x03\u{e7}\
	\x03\u{e7}\x03\u{e7}\x03\u{e7}\x03\u{e7}\x03\u{e7}\x07\u{e7}\u{b0e}\x0a\
	\u{e7}\x0c\u{e7}\x0e\u{e7}\u{b11}\x0b\u{e7}\x03\u{e8}\x03\u{e8}\x03\u{e8}\
	\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\
	\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e8}\
	\x07\u{e8}\u{b25}\x0a\u{e8}\x0c\u{e8}\x0e\u{e8}\u{b28}\x0b\u{e8}\x03\u{e9}\
	\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\
	\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{e9}\
	\x07\u{e9}\u{b3a}\x0a\u{e9}\x0c\u{e9}\x0e\u{e9}\u{b3d}\x0b\u{e9}\x03\u{ea}\
	\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\
	\u{ea}\x07\u{ea}\u{b48}\x0a\u{ea}\x0c\u{ea}\x0e\u{ea}\u{b4b}\x0b\u{ea}\x03\
	\u{eb}\x03\u{eb}\x03\u{eb}\x03\u{eb}\x03\u{eb}\x03\u{eb}\x03\u{eb}\x03\u{eb}\
	\x03\u{eb}\x03\u{eb}\x03\u{eb}\x03\u{eb}\x07\u{eb}\u{b59}\x0a\u{eb}\x0c\
	\u{eb}\x0e\u{eb}\u{b5c}\x0b\u{eb}\x03\u{ec}\x03\u{ec}\x03\u{ec}\x03\u{ec}\
	\x03\u{ec}\x03\u{ec}\x03\u{ec}\x05\u{ec}\u{b65}\x0a\u{ec}\x03\u{ed}\x03\
	\u{ed}\x03\u{ed}\x03\u{ee}\x03\u{ee}\x03\u{ee}\x03\u{ef}\x03\u{ef}\x03\u{ef}\
	\x03\u{ef}\x03\u{ef}\x03\u{ef}\x05\u{ef}\u{b73}\x0a\u{ef}\x03\u{f0}\x03\
	\u{f0}\x05\u{f0}\u{b77}\x0a\u{f0}\x03\u{f0}\x03\u{f0}\x07\u{f0}\u{b7b}\x0a\
	\u{f0}\x0c\u{f0}\x0e\u{f0}\u{b7e}\x0b\u{f0}\x03\u{f1}\x03\u{f1}\x03\u{f1}\
	\x03\u{f2}\x03\u{f2}\x03\u{f3}\x03\u{f3}\x03\u{f3}\x03\u{f4}\x03\u{f4}\x03\
	\u{f5}\x03\u{f5}\x03\u{f5}\x03\u{f5}\x03\u{f5}\x03\u{f5}\x03\u{f5}\x03\u{f5}\
	\x07\u{f5}\u{b92}\x0a\u{f5}\x0c\u{f5}\x0e\u{f5}\u{b95}\x0b\u{f5}\x03\u{f5}\
	\x03\u{f5}\x03\u{f5}\x03\u{f5}\x03\u{f5}\x03\u{f5}\x07\u{f5}\u{b9d}\x0a\
	\u{f5}\x0c\u{f5}\x0e\u{f5}\u{ba0}\x0b\u{f5}\x03\u{f5}\x03\u{f5}\x03\u{f5}\
	\x05\u{f5}\u{ba5}\x0a\u{f5}\x03\u{f6}\x03\u{f6}\x03\u{f6}\x02\x10\x34\x36\
	\x3a\x40\u{1c2}\u{1c4}\u{1c6}\u{1c8}\u{1ca}\u{1cc}\u{1ce}\u{1d0}\u{1d2}\
	\u{1d4}\u{f7}\x02\x04\x06\x08\x0a\x0c\x0e\x10\x12\x14\x16\x18\x1a\x1c\x1e\
	\x20\x22\x24\x26\x28\x2a\x2c\x2e\x30\x32\x34\x36\x38\x3a\x3c\x3e\x40\x42\
	\x44\x46\x48\x4a\x4c\x4e\x50\x52\x54\x56\x58\x5a\x5c\x5e\x60\x62\x64\x66\
	\x68\x6a\x6c\x6e\x70\x72\x74\x76\x78\x7a\x7c\x7e\u{80}\u{82}\u{84}\u{86}\
	\u{88}\u{8a}\u{8c}\u{8e}\u{90}\u{92}\u{94}\u{96}\u{98}\u{9a}\u{9c}\u{9e}\
	\u{a0}\u{a2}\u{a4}\u{a6}\u{a8}\u{aa}\u{ac}\u{ae}\u{b0}\u{b2}\u{b4}\u{b6}\
	\u{b8}\u{ba}\u{bc}\u{be}\u{c0}\u{c2}\u{c4}\u{c6}\u{c8}\u{ca}\u{cc}\u{ce}\
	\u{d0}\u{d2}\u{d4}\u{d6}\u{d8}\u{da}\u{dc}\u{de}\u{e0}\u{e2}\u{e4}\u{e6}\
	\u{e8}\u{ea}\u{ec}\u{ee}\u{f0}\u{f2}\u{f4}\u{f6}\u{f8}\u{fa}\u{fc}\u{fe}\
	\u{100}\u{102}\u{104}\u{106}\u{108}\u{10a}\u{10c}\u{10e}\u{110}\u{112}\u{114}\
	\u{116}\u{118}\u{11a}\u{11c}\u{11e}\u{120}\u{122}\u{124}\u{126}\u{128}\u{12a}\
	\u{12c}\u{12e}\u{130}\u{132}\u{134}\u{136}\u{138}\u{13a}\u{13c}\u{13e}\u{140}\
	\u{142}\u{144}\u{146}\u{148}\u{14a}\u{14c}\u{14e}\u{150}\u{152}\u{154}\u{156}\
	\u{158}\u{15a}\u{15c}\u{15e}\u{160}\u{162}\u{164}\u{166}\u{168}\u{16a}\u{16c}\
	\u{16e}\u{170}\u{172}\u{174}\u{176}\u{178}\u{17a}\u{17c}\u{17e}\u{180}\u{182}\
	\u{184}\u{186}\u{188}\u{18a}\u{18c}\u{18e}\u{190}\u{192}\u{194}\u{196}\u{198}\
	\u{19a}\u{19c}\u{19e}\u{1a0}\u{1a2}\u{1a4}\u{1a6}\u{1a8}\u{1aa}\u{1ac}\u{1ae}\
	\u{1b0}\u{1b2}\u{1b4}\u{1b6}\u{1b8}\u{1ba}\u{1bc}\u{1be}\u{1c0}\u{1c2}\u{1c4}\
	\u{1c6}\u{1c8}\u{1ca}\u{1cc}\u{1ce}\u{1d0}\u{1d2}\u{1d4}\u{1d6}\u{1d8}\u{1da}\
	\u{1dc}\u{1de}\u{1e0}\u{1e2}\u{1e4}\u{1e6}\u{1e8}\u{1ea}\x02\x08\x03\x02\
	\x40\x45\x07\x02\x07\x07\x0a\x0a\x1e\x1e\x20\x20\x2d\x2d\x04\x02\x10\x10\
	\x17\x17\x04\x02\x2e\x2e\x38\x38\x04\x02\x52\x52\x6a\x74\x0b\x02\x13\x13\
	\x21\x21\x24\x25\x29\x29\x2b\x2b\x36\x36\x3a\x3a\x3e\x3e\x75\x75\x02\u{ca7}\
	\x02\u{1ec}\x03\x02\x02\x02\x04\u{1fc}\x03\x02\x02\x02\x06\u{200}\x03\x02\
	\x02\x02\x08\u{202}\x03\x02\x02\x02\x0a\u{204}\x03\x02\x02\x02\x0c\u{209}\
	\x03\x02\x02\x02\x0e\u{20d}\x03\x02\x02\x02\x10\u{22c}\x03\x02\x02\x02\x12\
	\u{22e}\x03\x02\x02\x02\x14\u{23c}\x03\x02\x02\x02\x16\u{243}\x03\x02\x02\
	\x02\x18\u{245}\x03\x02\x02\x02\x1a\u{247}\x03\x02\x02\x02\x1c\u{24c}\x03\
	\x02\x02\x02\x1e\u{25a}\x03\x02\x02\x02\x20\u{25f}\x03\x02\x02\x02\x22\u{274}\
	\x03\x02\x02\x02\x24\u{27b}\x03\x02\x02\x02\x26\u{287}\x03\x02\x02\x02\x28\
	\u{289}\x03\x02\x02\x02\x2a\u{28c}\x03\x02\x02\x02\x2c\u{290}\x03\x02\x02\
	\x02\x2e\u{29a}\x03\x02\x02\x02\x30\u{29f}\x03\x02\x02\x02\x32\u{2aa}\x03\
	\x02\x02\x02\x34\u{2ac}\x03\x02\x02\x02\x36\u{2b7}\x03\x02\x02\x02\x38\u{2c7}\
	\x03\x02\x02\x02\x3a\u{2c9}\x03\x02\x02\x02\x3c\u{2d9}\x03\x02\x02\x02\x3e\
	\u{2db}\x03\x02\x02\x02\x40\u{2dd}\x03\x02\x02\x02\x42\u{2ea}\x03\x02\x02\
	\x02\x44\u{2ef}\x03\x02\x02\x02\x46\u{302}\x03\x02\x02\x02\x48\u{30a}\x03\
	\x02\x02\x02\x4a\u{311}\x03\x02\x02\x02\x4c\u{317}\x03\x02\x02\x02\x4e\u{319}\
	\x03\x02\x02\x02\x50\u{31d}\x03\x02\x02\x02\x52\u{323}\x03\x02\x02\x02\x54\
	\u{32a}\x03\x02\x02\x02\x56\u{334}\x03\x02\x02\x02\x58\u{339}\x03\x02\x02\
	\x02\x5a\u{383}\x03\x02\x02\x02\x5c\u{385}\x03\x02\x02\x02\x5e\u{389}\x03\
	\x02\x02\x02\x60\u{38e}\x03\x02\x02\x02\x62\u{3a6}\x03\x02\x02\x02\x64\u{3a8}\
	\x03\x02\x02\x02\x66\u{3ac}\x03\x02\x02\x02\x68\u{3b4}\x03\x02\x02\x02\x6a\
	\u{3b7}\x03\x02\x02\x02\x6c\u{3ba}\x03\x02\x02\x02\x6e\u{3c2}\x03\x02\x02\
	\x02\x70\u{3cf}\x03\x02\x02\x02\x72\u{3d6}\x03\x02\x02\x02\x74\u{3db}\x03\
	\x02\x02\x02\x76\u{3ea}\x03\x02\x02\x02\x78\u{3ec}\x03\x02\x02\x02\x7a\u{3f4}\
	\x03\x02\x02\x02\x7c\u{3f9}\x03\x02\x02\x02\x7e\u{3ff}\x03\x02\x02\x02\u{80}\
	\u{403}\x03\x02\x02\x02\u{82}\u{407}\x03\x02\x02\x02\u{84}\u{40c}\x03\x02\
	\x02\x02\u{86}\u{410}\x03\x02\x02\x02\u{88}\u{429}\x03\x02\x02\x02\u{8a}\
	\u{42b}\x03\x02\x02\x02\u{8c}\u{436}\x03\x02\x02\x02\u{8e}\u{43a}\x03\x02\
	\x02\x02\u{90}\u{43c}\x03\x02\x02\x02\u{92}\u{43e}\x03\x02\x02\x02\u{94}\
	\u{440}\x03\x02\x02\x02\u{96}\u{44b}\x03\x02\x02\x02\u{98}\u{450}\x03\x02\
	\x02\x02\u{9a}\u{460}\x03\x02\x02\x02\u{9c}\u{473}\x03\x02\x02\x02\u{9e}\
	\u{477}\x03\x02\x02\x02\u{a0}\u{479}\x03\x02\x02\x02\u{a2}\u{488}\x03\x02\
	\x02\x02\u{a4}\u{49a}\x03\x02\x02\x02\u{a6}\u{49f}\x03\x02\x02\x02\u{a8}\
	\u{4a7}\x03\x02\x02\x02\u{aa}\u{4ba}\x03\x02\x02\x02\u{ac}\u{4bf}\x03\x02\
	\x02\x02\u{ae}\u{4ca}\x03\x02\x02\x02\u{b0}\u{4cd}\x03\x02\x02\x02\u{b2}\
	\u{4d7}\x03\x02\x02\x02\u{b4}\u{4db}\x03\x02\x02\x02\u{b6}\u{4dd}\x03\x02\
	\x02\x02\u{b8}\u{4df}\x03\x02\x02\x02\u{ba}\u{4e5}\x03\x02\x02\x02\u{bc}\
	\u{4f2}\x03\x02\x02\x02\u{be}\u{4f5}\x03\x02\x02\x02\u{c0}\u{4fe}\x03\x02\
	\x02\x02\u{c2}\u{500}\x03\x02\x02\x02\u{c4}\u{537}\x03\x02\x02\x02\u{c6}\
	\u{53c}\x03\x02\x02\x02\u{c8}\u{546}\x03\x02\x02\x02\u{ca}\u{552}\x03\x02\
	\x02\x02\u{cc}\u{55d}\x03\x02\x02\x02\u{ce}\u{56b}\x03\x02\x02\x02\u{d0}\
	\u{56d}\x03\x02\x02\x02\u{d2}\u{576}\x03\x02\x02\x02\u{d4}\u{57b}\x03\x02\
	\x02\x02\u{d6}\u{58f}\x03\x02\x02\x02\u{d8}\u{591}\x03\x02\x02\x02\u{da}\
	\u{594}\x03\x02\x02\x02\u{dc}\u{5a2}\x03\x02\x02\x02\u{de}\u{5a7}\x03\x02\
	\x02\x02\u{e0}\u{5b2}\x03\x02\x02\x02\u{e2}\u{5b7}\x03\x02\x02\x02\u{e4}\
	\u{5c4}\x03\x02\x02\x02\u{e6}\u{5c9}\x03\x02\x02\x02\u{e8}\u{5d1}\x03\x02\
	\x02\x02\u{ea}\u{5df}\x03\x02\x02\x02\u{ec}\u{5e4}\x03\x02\x02\x02\u{ee}\
	\u{5f6}\x03\x02\x02\x02\u{f0}\u{5f8}\x03\x02\x02\x02\u{f2}\u{5fe}\x03\x02\
	\x02\x02\u{f4}\u{600}\x03\x02\x02\x02\u{f6}\u{608}\x03\x02\x02\x02\u{f8}\
	\u{610}\x03\x02\x02\x02\u{fa}\u{617}\x03\x02\x02\x02\u{fc}\u{619}\x03\x02\
	\x02\x02\u{fe}\u{622}\x03\x02\x02\x02\u{100}\u{62a}\x03\x02\x02\x02\u{102}\
	\u{62d}\x03\x02\x02\x02\u{104}\u{633}\x03\x02\x02\x02\u{106}\u{63c}\x03\
	\x02\x02\x02\u{108}\u{644}\x03\x02\x02\x02\u{10a}\u{64b}\x03\x02\x02\x02\
	\u{10c}\u{652}\x03\x02\x02\x02\u{10e}\u{654}\x03\x02\x02\x02\u{110}\u{65a}\
	\x03\x02\x02\x02\u{112}\u{666}\x03\x02\x02\x02\u{114}\u{66d}\x03\x02\x02\
	\x02\u{116}\u{67b}\x03\x02\x02\x02\u{118}\u{67d}\x03\x02\x02\x02\u{11a}\
	\u{67f}\x03\x02\x02\x02\u{11c}\u{683}\x03\x02\x02\x02\u{11e}\u{687}\x03\
	\x02\x02\x02\u{120}\u{691}\x03\x02\x02\x02\u{122}\u{693}\x03\x02\x02\x02\
	\u{124}\u{699}\x03\x02\x02\x02\u{126}\u{6a1}\x03\x02\x02\x02\u{128}\u{6b3}\
	\x03\x02\x02\x02\u{12a}\u{6b5}\x03\x02\x02\x02\u{12c}\u{6bb}\x03\x02\x02\
	\x02\u{12e}\u{6ca}\x03\x02\x02\x02\u{130}\u{6ce}\x03\x02\x02\x02\u{132}\
	\u{6dc}\x03\x02\x02\x02\u{134}\u{6de}\x03\x02\x02\x02\u{136}\u{6e0}\x03\
	\x02\x02\x02\u{138}\u{6e6}\x03\x02\x02\x02\u{13a}\u{6ec}\x03\x02\x02\x02\
	\u{13c}\u{6f6}\x03\x02\x02\x02\u{13e}\u{6fa}\x03\x02\x02\x02\u{140}\u{6fc}\
	\x03\x02\x02\x02\u{142}\u{70c}\x03\x02\x02\x02\u{144}\u{71e}\x03\x02\x02\
	\x02\u{146}\u{720}\x03\x02\x02\x02\u{148}\u{722}\x03\x02\x02\x02\u{14a}\
	\u{72a}\x03\x02\x02\x02\u{14c}\u{739}\x03\x02\x02\x02\u{14e}\u{748}\x03\
	\x02\x02\x02\u{150}\u{74e}\x03\x02\x02\x02\u{152}\u{754}\x03\x02\x02\x02\
	\u{154}\u{75a}\x03\x02\x02\x02\u{156}\u{75e}\x03\x02\x02\x02\u{158}\u{770}\
	\x03\x02\x02\x02\u{15a}\u{773}\x03\x02\x02\x02\u{15c}\u{777}\x03\x02\x02\
	\x02\u{15e}\u{780}\x03\x02\x02\x02\u{160}\u{786}\x03\x02\x02\x02\u{162}\
	\u{78e}\x03\x02\x02\x02\u{164}\u{791}\x03\x02\x02\x02\u{166}\u{79a}\x03\
	\x02\x02\x02\u{168}\u{7a1}\x03\x02\x02\x02\u{16a}\u{7b5}\x03\x02\x02\x02\
	\u{16c}\u{7b9}\x03\x02\x02\x02\u{16e}\u{7bd}\x03\x02\x02\x02\u{170}\u{7d5}\
	\x03\x02\x02\x02\u{172}\u{7d7}\x03\x02\x02\x02\u{174}\u{7f5}\x03\x02\x02\
	\x02\u{176}\u{7fc}\x03\x02\x02\x02\u{178}\u{7fe}\x03\x02\x02\x02\u{17a}\
	\u{804}\x03\x02\x02\x02\u{17c}\u{82e}\x03\x02\x02\x02\u{17e}\u{830}\x03\
	\x02\x02\x02\u{180}\u{859}\x03\x02\x02\x02\u{182}\u{86c}\x03\x02\x02\x02\
	\u{184}\u{8c1}\x03\x02\x02\x02\u{186}\u{8c3}\x03\x02\x02\x02\u{188}\u{915}\
	\x03\x02\x02\x02\u{18a}\u{91a}\x03\x02\x02\x02\u{18c}\u{929}\x03\x02\x02\
	\x02\u{18e}\u{92b}\x03\x02\x02\x02\u{190}\u{937}\x03\x02\x02\x02\u{192}\
	\u{943}\x03\x02\x02\x02\u{194}\u{94f}\x03\x02\x02\x02\u{196}\u{968}\x03\
	\x02\x02\x02\u{198}\u{9b9}\x03\x02\x02\x02\u{19a}\u{9bb}\x03\x02\x02\x02\
	\u{19c}\u{9ff}\x03\x02\x02\x02\u{19e}\u{a01}\x03\x02\x02\x02\u{1a0}\u{a38}\
	\x03\x02\x02\x02\u{1a2}\u{a3a}\x03\x02\x02\x02\u{1a4}\u{a68}\x03\x02\x02\
	\x02\u{1a6}\u{a80}\x03\x02\x02\x02\u{1a8}\u{a83}\x03\x02\x02\x02\u{1aa}\
	\u{a8a}\x03\x02\x02\x02\u{1ac}\u{a91}\x03\x02\x02\x02\u{1ae}\u{a95}\x03\
	\x02\x02\x02\u{1b0}\u{a97}\x03\x02\x02\x02\u{1b2}\u{aa5}\x03\x02\x02\x02\
	\u{1b4}\u{aa7}\x03\x02\x02\x02\u{1b6}\u{ab1}\x03\x02\x02\x02\u{1b8}\u{ab5}\
	\x03\x02\x02\x02\u{1ba}\u{ab7}\x03\x02\x02\x02\u{1bc}\u{abe}\x03\x02\x02\
	\x02\u{1be}\u{ac0}\x03\x02\x02\x02\u{1c0}\u{acb}\x03\x02\x02\x02\u{1c2}\
	\u{acd}\x03\x02\x02\x02\u{1c4}\u{ad8}\x03\x02\x02\x02\u{1c6}\u{ae3}\x03\
	\x02\x02\x02\u{1c8}\u{aee}\x03\x02\x02\x02\u{1ca}\u{af9}\x03\x02\x02\x02\
	\u{1cc}\u{b04}\x03\x02\x02\x02\u{1ce}\u{b12}\x03\x02\x02\x02\u{1d0}\u{b29}\
	\x03\x02\x02\x02\u{1d2}\u{b3e}\x03\x02\x02\x02\u{1d4}\u{b4c}\x03\x02\x02\
	\x02\u{1d6}\u{b64}\x03\x02\x02\x02\u{1d8}\u{b66}\x03\x02\x02\x02\u{1da}\
	\u{b69}\x03\x02\x02\x02\u{1dc}\u{b72}\x03\x02\x02\x02\u{1de}\u{b76}\x03\
	\x02\x02\x02\u{1e0}\u{b7f}\x03\x02\x02\x02\u{1e2}\u{b82}\x03\x02\x02\x02\
	\u{1e4}\u{b84}\x03\x02\x02\x02\u{1e6}\u{b87}\x03\x02\x02\x02\u{1e8}\u{ba4}\
	\x03\x02\x02\x02\u{1ea}\u{ba6}\x03\x02\x02\x02\u{1ec}\u{1ed}\x09\x02\x02\
	\x02\u{1ed}\x03\x03\x02\x02\x02\u{1ee}\u{1f0}\x05\u{f2}\x7a\x02\u{1ef}\u{1ee}\
	\x03\x02\x02\x02\u{1f0}\u{1f3}\x03\x02\x02\x02\u{1f1}\u{1ef}\x03\x02\x02\
	\x02\u{1f1}\u{1f2}\x03\x02\x02\x02\u{1f2}\u{1f4}\x03\x02\x02\x02\u{1f3}\
	\u{1f1}\x03\x02\x02\x02\u{1f4}\u{1fd}\x05\x06\x04\x02\u{1f5}\u{1f7}\x05\
	\u{f2}\x7a\x02\u{1f6}\u{1f5}\x03\x02\x02\x02\u{1f7}\u{1fa}\x03\x02\x02\x02\
	\u{1f8}\u{1f6}\x03\x02\x02\x02\u{1f8}\u{1f9}\x03\x02\x02\x02\u{1f9}\u{1fb}\
	\x03\x02\x02\x02\u{1fa}\u{1f8}\x03\x02\x02\x02\u{1fb}\u{1fd}\x07\x05\x02\
	\x02\u{1fc}\u{1f1}\x03\x02\x02\x02\u{1fc}\u{1f8}\x03\x02\x02\x02\u{1fd}\
	\x05\x03\x02\x02\x02\u{1fe}\u{201}\x05\x08\x05\x02\u{1ff}\u{201}\x05\x0a\
	\x06\x02\u{200}\u{1fe}\x03\x02\x02\x02\u{200}\u{1ff}\x03\x02\x02\x02\u{201}\
	\x07\x03\x02\x02\x02\u{202}\u{203}\x09\x03\x02\x02\u{203}\x09\x03\x02\x02\
	\x02\u{204}\u{205}\x09\x04\x02\x02\u{205}\x0b\x03\x02\x02\x02\u{206}\u{20a}\
	\x05\x0e\x08\x02\u{207}\u{20a}\x05\x1c\x0f\x02\u{208}\u{20a}\x05\x1e\x10\
	\x02\u{209}\u{206}\x03\x02\x02\x02\u{209}\u{207}\x03\x02\x02\x02\u{209}\
	\u{208}\x03\x02\x02\x02\u{20a}\x0d\x03\x02\x02\x02\u{20b}\u{20e}\x05\x14\
	\x0b\x02\u{20c}\u{20e}\x05\x1a\x0e\x02\u{20d}\u{20b}\x03\x02\x02\x02\u{20d}\
	\u{20c}\x03\x02\x02\x02\u{20e}\u{213}\x03\x02\x02\x02\u{20f}\u{212}\x05\
	\x12\x0a\x02\u{210}\u{212}\x05\x18\x0d\x02\u{211}\u{20f}\x03\x02\x02\x02\
	\u{211}\u{210}\x03\x02\x02\x02\u{212}\u{215}\x03\x02\x02\x02\u{213}\u{211}\
	\x03\x02\x02\x02\u{213}\u{214}\x03\x02\x02\x02\u{214}\x0f\x03\x02\x02\x02\
	\u{215}\u{213}\x03\x02\x02\x02\u{216}\u{218}\x05\u{f2}\x7a\x02\u{217}\u{216}\
	\x03\x02\x02\x02\u{218}\u{21b}\x03\x02\x02\x02\u{219}\u{217}\x03\x02\x02\
	\x02\u{219}\u{21a}\x03\x02\x02\x02\u{21a}\u{21c}\x03\x02\x02\x02\u{21b}\
	\u{219}\x03\x02\x02\x02\u{21c}\u{21e}\x05\u{1ea}\u{f6}\x02\u{21d}\u{21f}\
	\x05\x2a\x16\x02\u{21e}\u{21d}\x03\x02\x02\x02\u{21e}\u{21f}\x03\x02\x02\
	\x02\u{21f}\u{22d}\x03\x02\x02\x02\u{220}\u{221}\x05\x0e\x08\x02\u{221}\
	\u{225}\x07\x4e\x02\x02\u{222}\u{224}\x05\u{f2}\x7a\x02\u{223}\u{222}\x03\
	\x02\x02\x02\u{224}\u{227}\x03\x02\x02\x02\u{225}\u{223}\x03\x02\x02\x02\
	\u{225}\u{226}\x03\x02\x02\x02\u{226}\u{228}\x03\x02\x02\x02\u{227}\u{225}\
	\x03\x02\x02\x02\u{228}\u{22a}\x05\u{1ea}\u{f6}\x02\u{229}\u{22b}\x05\x2a\
	\x16\x02\u{22a}\u{229}\x03\x02\x02\x02\u{22a}\u{22b}\x03\x02\x02\x02\u{22b}\
	\u{22d}\x03\x02\x02\x02\u{22c}\u{219}\x03\x02\x02\x02\u{22c}\u{220}\x03\
	\x02\x02\x02\u{22d}\x11\x03\x02\x02\x02\u{22e}\u{232}\x07\x4e\x02\x02\u{22f}\
	\u{231}\x05\u{f2}\x7a\x02\u{230}\u{22f}\x03\x02\x02\x02\u{231}\u{234}\x03\
	\x02\x02\x02\u{232}\u{230}\x03\x02\x02\x02\u{232}\u{233}\x03\x02\x02\x02\
	\u{233}\u{235}\x03\x02\x02\x02\u{234}\u{232}\x03\x02\x02\x02\u{235}\u{237}\
	\x05\u{1ea}\u{f6}\x02\u{236}\u{238}\x05\x2a\x16\x02\u{237}\u{236}\x03\x02\
	\x02\x02\u{237}\u{238}\x03\x02\x02\x02\u{238}\x13\x03\x02\x02\x02\u{239}\
	\u{23b}\x05\u{f2}\x7a\x02\u{23a}\u{239}\x03\x02\x02\x02\u{23b}\u{23e}\x03\
	\x02\x02\x02\u{23c}\u{23a}\x03\x02\x02\x02\u{23c}\u{23d}\x03\x02\x02\x02\
	\u{23d}\u{23f}\x03\x02\x02\x02\u{23e}\u{23c}\x03\x02\x02\x02\u{23f}\u{241}\
	\x05\u{1ea}\u{f6}\x02\u{240}\u{242}\x05\x2a\x16\x02\u{241}\u{240}\x03\x02\
	\x02\x02\u{241}\u{242}\x03\x02\x02\x02\u{242}\x15\x03\x02\x02\x02\u{243}\
	\u{244}\x05\x10\x09\x02\u{244}\x17\x03\x02\x02\x02\u{245}\u{246}\x05\x12\
	\x0a\x02\u{246}\x19\x03\x02\x02\x02\u{247}\u{248}\x05\x14\x0b\x02\u{248}\
	\x1b\x03\x02\x02\x02\u{249}\u{24b}\x05\u{f2}\x7a\x02\u{24a}\u{249}\x03\x02\
	\x02\x02\u{24b}\u{24e}\x03\x02\x02\x02\u{24c}\u{24a}\x03\x02\x02\x02\u{24c}\
	\u{24d}\x03\x02\x02\x02\u{24d}\u{24f}\x03\x02\x02\x02\u{24e}\u{24c}\x03\
	\x02\x02\x02\u{24f}\u{250}\x05\u{1ea}\u{f6}\x02\u{250}\x1d\x03\x02\x02\x02\
	\u{251}\u{252}\x05\x04\x03\x02\u{252}\u{253}\x05\x20\x11\x02\u{253}\u{25b}\
	\x03\x02\x02\x02\u{254}\u{255}\x05\x0e\x08\x02\u{255}\u{256}\x05\x20\x11\
	\x02\u{256}\u{25b}\x03\x02\x02\x02\u{257}\u{258}\x05\x1c\x0f\x02\u{258}\
	\u{259}\x05\x20\x11\x02\u{259}\u{25b}\x03\x02\x02\x02\u{25a}\u{251}\x03\
	\x02\x02\x02\u{25a}\u{254}\x03\x02\x02\x02\u{25a}\u{257}\x03\x02\x02\x02\
	\u{25b}\x1f\x03\x02\x02\x02\u{25c}\u{25e}\x05\u{f2}\x7a\x02\u{25d}\u{25c}\
	\x03\x02\x02\x02\u{25e}\u{261}\x03\x02\x02\x02\u{25f}\u{25d}\x03\x02\x02\
	\x02\u{25f}\u{260}\x03\x02\x02\x02\u{260}\u{262}\x03\x02\x02\x02\u{261}\
	\u{25f}\x03\x02\x02\x02\u{262}\u{263}\x07\x4a\x02\x02\u{263}\u{26e}\x07\
	\x4b\x02\x02\u{264}\u{266}\x05\u{f2}\x7a\x02\u{265}\u{264}\x03\x02\x02\x02\
	\u{266}\u{269}\x03\x02\x02\x02\u{267}\u{265}\x03\x02\x02\x02\u{267}\u{268}\
	\x03\x02\x02\x02\u{268}\u{26a}\x03\x02\x02\x02\u{269}\u{267}\x03\x02\x02\
	\x02\u{26a}\u{26b}\x07\x4a\x02\x02\u{26b}\u{26d}\x07\x4b\x02\x02\u{26c}\
	\u{267}\x03\x02\x02\x02\u{26d}\u{270}\x03\x02\x02\x02\u{26e}\u{26c}\x03\
	\x02\x02\x02\u{26e}\u{26f}\x03\x02\x02\x02\u{26f}\x21\x03\x02\x02\x02\u{270}\
	\u{26e}\x03\x02\x02\x02\u{271}\u{273}\x05\x24\x13\x02\u{272}\u{271}\x03\
	\x02\x02\x02\u{273}\u{276}\x03\x02\x02\x02\u{274}\u{272}\x03\x02\x02\x02\
	\u{274}\u{275}\x03\x02\x02\x02\u{275}\u{277}\x03\x02\x02\x02\u{276}\u{274}\
	\x03\x02\x02\x02\u{277}\u{279}\x05\u{1ea}\u{f6}\x02\u{278}\u{27a}\x05\x26\
	\x14\x02\u{279}\u{278}\x03\x02\x02\x02\u{279}\u{27a}\x03\x02\x02\x02\u{27a}\
	\x23\x03\x02\x02\x02\u{27b}\u{27c}\x05\u{f2}\x7a\x02\u{27c}\x25\x03\x02\
	\x02\x02\u{27d}\u{27e}\x07\x14\x02\x02\u{27e}\u{288}\x05\x1c\x0f\x02\u{27f}\
	\u{280}\x07\x14\x02\x02\u{280}\u{284}\x05\x0e\x08\x02\u{281}\u{283}\x05\
	\x28\x15\x02\u{282}\u{281}\x03\x02\x02\x02\u{283}\u{286}\x03\x02\x02\x02\
	\u{284}\u{282}\x03\x02\x02\x02\u{284}\u{285}\x03\x02\x02\x02\u{285}\u{288}\
	\x03\x02\x02\x02\u{286}\u{284}\x03\x02\x02\x02\u{287}\u{27d}\x03\x02\x02\
	\x02\u{287}\u{27f}\x03\x02\x02\x02\u{288}\x27\x03\x02\x02\x02\u{289}\u{28a}\
	\x07\x66\x02\x02\u{28a}\u{28b}\x05\x16\x0c\x02\u{28b}\x29\x03\x02\x02\x02\
	\u{28c}\u{28d}\x07\x54\x02\x02\u{28d}\u{28e}\x05\x2c\x17\x02\u{28e}\u{28f}\
	\x07\x53\x02\x02\u{28f}\x2b\x03\x02\x02\x02\u{290}\u{295}\x05\x2e\x18\x02\
	\u{291}\u{292}\x07\x4d\x02\x02\u{292}\u{294}\x05\x2e\x18\x02\u{293}\u{291}\
	\x03\x02\x02\x02\u{294}\u{297}\x03\x02\x02\x02\u{295}\u{293}\x03\x02\x02\
	\x02\u{295}\u{296}\x03\x02\x02\x02\u{296}\x2d\x03\x02\x02\x02\u{297}\u{295}\
	\x03\x02\x02\x02\u{298}\u{29b}\x05\x0c\x07\x02\u{299}\u{29b}\x05\x30\x19\
	\x02\u{29a}\u{298}\x03\x02\x02\x02\u{29a}\u{299}\x03\x02\x02\x02\u{29b}\
	\x2f\x03\x02\x02\x02\u{29c}\u{29e}\x05\u{f2}\x7a\x02\u{29d}\u{29c}\x03\x02\
	\x02\x02\u{29e}\u{2a1}\x03\x02\x02\x02\u{29f}\u{29d}\x03\x02\x02\x02\u{29f}\
	\u{2a0}\x03\x02\x02\x02\u{2a0}\u{2a2}\x03\x02\x02\x02\u{2a1}\u{29f}\x03\
	\x02\x02\x02\u{2a2}\u{2a4}\x07\x57\x02\x02\u{2a3}\u{2a5}\x05\x32\x1a\x02\
	\u{2a4}\u{2a3}\x03\x02\x02\x02\u{2a4}\u{2a5}\x03\x02\x02\x02\u{2a5}\x31\
	\x03\x02\x02\x02\u{2a6}\u{2a7}\x07\x14\x02\x02\u{2a7}\u{2ab}\x05\x0c\x07\
	\x02\u{2a8}\u{2a9}\x07\x30\x02\x02\u{2a9}\u{2ab}\x05\x0c\x07\x02\u{2aa}\
	\u{2a6}\x03\x02\x02\x02\u{2aa}\u{2a8}\x03\x02\x02\x02\u{2ab}\x33\x03\x02\
	\x02\x02\u{2ac}\u{2ad}\x08\x1b\x01\x02\u{2ad}\u{2ae}\x05\u{1ea}\u{f6}\x02\
	\u{2ae}\u{2b4}\x03\x02\x02\x02\u{2af}\u{2b0}\x0c\x03\x02\x02\u{2b0}\u{2b1}\
	\x07\x4e\x02\x02\u{2b1}\u{2b3}\x05\u{1ea}\u{f6}\x02\u{2b2}\u{2af}\x03\x02\
	\x02\x02\u{2b3}\u{2b6}\x03\x02\x02\x02\u{2b4}\u{2b2}\x03\x02\x02\x02\u{2b4}\
	\u{2b5}\x03\x02\x02\x02\u{2b5}\x35\x03\x02\x02\x02\u{2b6}\u{2b4}\x03\x02\
	\x02\x02\u{2b7}\u{2b8}\x08\x1c\x01\x02\u{2b8}\u{2b9}\x05\u{1ea}\u{f6}\x02\
	\u{2b9}\u{2bf}\x03\x02\x02\x02\u{2ba}\u{2bb}\x0c\x03\x02\x02\u{2bb}\u{2bc}\
	\x07\x4e\x02\x02\u{2bc}\u{2be}\x05\u{1ea}\u{f6}\x02\u{2bd}\u{2ba}\x03\x02\
	\x02\x02\u{2be}\u{2c1}\x03\x02\x02\x02\u{2bf}\u{2bd}\x03\x02\x02\x02\u{2bf}\
	\u{2c0}\x03\x02\x02\x02\u{2c0}\x37\x03\x02\x02\x02\u{2c1}\u{2bf}\x03\x02\
	\x02\x02\u{2c2}\u{2c8}\x05\u{1ea}\u{f6}\x02\u{2c3}\u{2c4}\x05\x3a\x1e\x02\
	\u{2c4}\u{2c5}\x07\x4e\x02\x02\u{2c5}\u{2c6}\x05\u{1ea}\u{f6}\x02\u{2c6}\
	\u{2c8}\x03\x02\x02\x02\u{2c7}\u{2c2}\x03\x02\x02\x02\u{2c7}\u{2c3}\x03\
	\x02\x02\x02\u{2c8}\x39\x03\x02\x02\x02\u{2c9}\u{2ca}\x08\x1e\x01\x02\u{2ca}\
	\u{2cb}\x05\u{1ea}\u{f6}\x02\u{2cb}\u{2d1}\x03\x02\x02\x02\u{2cc}\u{2cd}\
	\x0c\x03\x02\x02\u{2cd}\u{2ce}\x07\x4e\x02\x02\u{2ce}\u{2d0}\x05\u{1ea}\
	\u{f6}\x02\u{2cf}\u{2cc}\x03\x02\x02\x02\u{2d0}\u{2d3}\x03\x02\x02\x02\u{2d1}\
	\u{2cf}\x03\x02\x02\x02\u{2d1}\u{2d2}\x03\x02\x02\x02\u{2d2}\x3b\x03\x02\
	\x02\x02\u{2d3}\u{2d1}\x03\x02\x02\x02\u{2d4}\u{2da}\x05\u{1ea}\u{f6}\x02\
	\u{2d5}\u{2d6}\x05\x40\x21\x02\u{2d6}\u{2d7}\x07\x4e\x02\x02\u{2d7}\u{2d8}\
	\x05\u{1ea}\u{f6}\x02\u{2d8}\u{2da}\x03\x02\x02\x02\u{2d9}\u{2d4}\x03\x02\
	\x02\x02\u{2d9}\u{2d5}\x03\x02\x02\x02\u{2da}\x3d\x03\x02\x02\x02\u{2db}\
	\u{2dc}\x05\u{1ea}\u{f6}\x02\u{2dc}\x3f\x03\x02\x02\x02\u{2dd}\u{2de}\x08\
	\x21\x01\x02\u{2de}\u{2df}\x05\u{1ea}\u{f6}\x02\u{2df}\u{2e5}\x03\x02\x02\
	\x02\u{2e0}\u{2e1}\x0c\x03\x02\x02\u{2e1}\u{2e2}\x07\x4e\x02\x02\u{2e2}\
	\u{2e4}\x05\u{1ea}\u{f6}\x02\u{2e3}\u{2e0}\x03\x02\x02\x02\u{2e4}\u{2e7}\
	\x03\x02\x02\x02\u{2e5}\u{2e3}\x03\x02\x02\x02\u{2e5}\u{2e6}\x03\x02\x02\
	\x02\u{2e6}\x41\x03\x02\x02\x02\u{2e7}\u{2e5}\x03\x02\x02\x02\u{2e8}\u{2eb}\
	\x05\x44\x23\x02\u{2e9}\u{2eb}\x05\x46\x24\x02\u{2ea}\u{2e8}\x03\x02\x02\
	\x02\u{2ea}\u{2e9}\x03\x02\x02\x02\u{2eb}\u{2ec}\x03\x02\x02\x02\u{2ec}\
	\u{2ed}\x07\x02\x02\x03\u{2ed}\x43\x03\x02\x02\x02\u{2ee}\u{2f0}\x05\x48\
	\x25\x02\u{2ef}\u{2ee}\x03\x02\x02\x02\u{2ef}\u{2f0}\x03\x02\x02\x02\u{2f0}\
	\u{2f4}\x03\x02\x02\x02\u{2f1}\u{2f3}\x05\x4c\x27\x02\u{2f2}\u{2f1}\x03\
	\x02\x02\x02\u{2f3}\u{2f6}\x03\x02\x02\x02\u{2f4}\u{2f2}\x03\x02\x02\x02\
	\u{2f4}\u{2f5}\x03\x02\x02\x02\u{2f5}\u{2fa}\x03\x02\x02\x02\u{2f6}\u{2f4}\
	\x03\x02\x02\x02\u{2f7}\u{2f9}\x05\x56\x2c\x02\u{2f8}\u{2f7}\x03\x02\x02\
	\x02\u{2f9}\u{2fc}\x03\x02\x02\x02\u{2fa}\u{2f8}\x03\x02\x02\x02\u{2fa}\
	\u{2fb}\x03\x02\x02\x02\u{2fb}\u{2fd}\x03\x02\x02\x02\u{2fc}\u{2fa}\x03\
	\x02\x02\x02\u{2fd}\u{2fe}\x07\x02\x02\x03\u{2fe}\x45\x03\x02\x02\x02\u{2ff}\
	\u{301}\x05\x4c\x27\x02\u{300}\u{2ff}\x03\x02\x02\x02\u{301}\u{304}\x03\
	\x02\x02\x02\u{302}\u{300}\x03\x02\x02\x02\u{302}\u{303}\x03\x02\x02\x02\
	\u{303}\u{305}\x03\x02\x02\x02\u{304}\u{302}\x03\x02\x02\x02\u{305}\u{306}\
	\x05\x58\x2d\x02\u{306}\x47\x03\x02\x02\x02\u{307}\u{309}\x05\x4a\x26\x02\
	\u{308}\u{307}\x03\x02\x02\x02\u{309}\u{30c}\x03\x02\x02\x02\u{30a}\u{308}\
	\x03\x02\x02\x02\u{30a}\u{30b}\x03\x02\x02\x02\u{30b}\u{30d}\x03\x02\x02\
	\x02\u{30c}\u{30a}\x03\x02\x02\x02\u{30d}\u{30e}\x07\x26\x02\x02\u{30e}\
	\u{30f}\x05\x36\x1c\x02\u{30f}\u{310}\x07\x4c\x02\x02\u{310}\x49\x03\x02\
	\x02\x02\u{311}\u{312}\x05\u{f2}\x7a\x02\u{312}\x4b\x03\x02\x02\x02\u{313}\
	\u{318}\x05\x4e\x28\x02\u{314}\u{318}\x05\x50\x29\x02\u{315}\u{318}\x05\
	\x52\x2a\x02\u{316}\u{318}\x05\x54\x2b\x02\u{317}\u{313}\x03\x02\x02\x02\
	\u{317}\u{314}\x03\x02\x02\x02\u{317}\u{315}\x03\x02\x02\x02\u{317}\u{316}\
	\x03\x02\x02\x02\u{318}\x4d\x03\x02\x02\x02\u{319}\u{31a}\x07\x1c\x02\x02\
	\u{31a}\u{31b}\x05\x38\x1d\x02\u{31b}\u{31c}\x07\x4c\x02\x02\u{31c}\x4f\
	\x03\x02\x02\x02\u{31d}\u{31e}\x07\x1c\x02\x02\u{31e}\u{31f}\x05\x3a\x1e\
	\x02\u{31f}\u{320}\x07\x4e\x02\x02\u{320}\u{321}\x07\x64\x02\x02\u{321}\
	\u{322}\x07\x4c\x02\x02\u{322}\x51\x03\x02\x02\x02\u{323}\u{324}\x07\x1c\
	\x02\x02\u{324}\u{325}\x07\x2e\x02\x02\u{325}\u{326}\x05\x38\x1d\x02\u{326}\
	\u{327}\x07\x4e\x02\x02\u{327}\u{328}\x05\u{1ea}\u{f6}\x02\u{328}\u{329}\
	\x07\x4c\x02\x02\u{329}\x53\x03\x02\x02\x02\u{32a}\u{32b}\x07\x1c\x02\x02\
	\u{32b}\u{32c}\x07\x2e\x02\x02\u{32c}\u{32d}\x05\x38\x1d\x02\u{32d}\u{32e}\
	\x07\x4e\x02\x02\u{32e}\u{32f}\x07\x64\x02\x02\u{32f}\u{330}\x07\x4c\x02\
	\x02\u{330}\x55\x03\x02\x02\x02\u{331}\u{335}\x05\x5e\x30\x02\u{332}\u{335}\
	\x05\u{d2}\x6a\x02\u{333}\u{335}\x07\x4c\x02\x02\u{334}\u{331}\x03\x02\x02\
	\x02\u{334}\u{332}\x03\x02\x02\x02\u{334}\u{333}\x03\x02\x02\x02\u{335}\
	\x57\x03\x02\x02\x02\u{336}\u{338}\x05\u{f2}\x7a\x02\u{337}\u{336}\x03\x02\
	\x02\x02\u{338}\u{33b}\x03\x02\x02\x02\u{339}\u{337}\x03\x02\x02\x02\u{339}\
	\u{33a}\x03\x02\x02\x02\u{33a}\u{33d}\x03\x02\x02\x02\u{33b}\u{339}\x03\
	\x02\x02\x02\u{33c}\u{33e}\x07\x24\x02\x02\u{33d}\u{33c}\x03\x02\x02\x02\
	\u{33d}\u{33e}\x03\x02\x02\x02\u{33e}\u{33f}\x03\x02\x02\x02\u{33f}\u{340}\
	\x07\x21\x02\x02\u{340}\u{341}\x05\x34\x1b\x02\u{341}\u{345}\x07\x48\x02\
	\x02\u{342}\u{344}\x05\x5a\x2e\x02\u{343}\u{342}\x03\x02\x02\x02\u{344}\
	\u{347}\x03\x02\x02\x02\u{345}\u{343}\x03\x02\x02\x02\u{345}\u{346}\x03\
	\x02\x02\x02\u{346}\u{348}\x03\x02\x02\x02\u{347}\u{345}\x03\x02\x02\x02\
	\u{348}\u{349}\x07\x49\x02\x02\u{349}\x59\x03\x02\x02\x02\u{34a}\u{34e}\
	\x07\x2b\x02\x02\u{34b}\u{34d}\x05\x5c\x2f\x02\u{34c}\u{34b}\x03\x02\x02\
	\x02\u{34d}\u{350}\x03\x02\x02\x02\u{34e}\u{34c}\x03\x02\x02\x02\u{34e}\
	\u{34f}\x03\x02\x02\x02\u{34f}\u{351}\x03\x02\x02\x02\u{350}\u{34e}\x03\
	\x02\x02\x02\u{351}\u{352}\x05\x34\x1b\x02\u{352}\u{353}\x07\x4c\x02\x02\
	\u{353}\u{384}\x03\x02\x02\x02\u{354}\u{355}\x07\x13\x02\x02\u{355}\u{35f}\
	\x05\x36\x1c\x02\u{356}\u{357}\x07\x36\x02\x02\u{357}\u{35c}\x05\x34\x1b\
	\x02\u{358}\u{359}\x07\x4d\x02\x02\u{359}\u{35b}\x05\x34\x1b\x02\u{35a}\
	\u{358}\x03\x02\x02\x02\u{35b}\u{35e}\x03\x02\x02\x02\u{35c}\u{35a}\x03\
	\x02\x02\x02\u{35c}\u{35d}\x03\x02\x02\x02\u{35d}\u{360}\x03\x02\x02\x02\
	\u{35e}\u{35c}\x03\x02\x02\x02\u{35f}\u{356}\x03\x02\x02\x02\u{35f}\u{360}\
	\x03\x02\x02\x02\u{360}\u{361}\x03\x02\x02\x02\u{361}\u{362}\x07\x4c\x02\
	\x02\u{362}\u{384}\x03\x02\x02\x02\u{363}\u{364}\x07\x25\x02\x02\u{364}\
	\u{36e}\x05\x36\x1c\x02\u{365}\u{366}\x07\x36\x02\x02\u{366}\u{36b}\x05\
	\x34\x1b\x02\u{367}\u{368}\x07\x4d\x02\x02\u{368}\u{36a}\x05\x34\x1b\x02\
	\u{369}\u{367}\x03\x02\x02\x02\u{36a}\u{36d}\x03\x02\x02\x02\u{36b}\u{369}\
	\x03\x02\x02\x02\u{36b}\u{36c}\x03\x02\x02\x02\u{36c}\u{36f}\x03\x02\x02\
	\x02\u{36d}\u{36b}\x03\x02\x02\x02\u{36e}\u{365}\x03\x02\x02\x02\u{36e}\
	\u{36f}\x03\x02\x02\x02\u{36f}\u{370}\x03\x02\x02\x02\u{370}\u{371}\x07\
	\x4c\x02\x02\u{371}\u{384}\x03\x02\x02\x02\u{372}\u{373}\x07\x3a\x02\x02\
	\u{373}\u{374}\x05\x38\x1d\x02\u{374}\u{375}\x07\x4c\x02\x02\u{375}\u{384}\
	\x03\x02\x02\x02\u{376}\u{377}\x07\x29\x02\x02\u{377}\u{378}\x05\x38\x1d\
	\x02\u{378}\u{379}\x07\x3e\x02\x02\u{379}\u{37e}\x05\x38\x1d\x02\u{37a}\
	\u{37b}\x07\x4d\x02\x02\u{37b}\u{37d}\x05\x38\x1d\x02\u{37c}\u{37a}\x03\
	\x02\x02\x02\u{37d}\u{380}\x03\x02\x02\x02\u{37e}\u{37c}\x03\x02\x02\x02\
	\u{37e}\u{37f}\x03\x02\x02\x02\u{37f}\u{381}\x03\x02\x02\x02\u{380}\u{37e}\
	\x03\x02\x02\x02\u{381}\u{382}\x07\x4c\x02\x02\u{382}\u{384}\x03\x02\x02\
	\x02\u{383}\u{34a}\x03\x02\x02\x02\u{383}\u{354}\x03\x02\x02\x02\u{383}\
	\u{363}\x03\x02\x02\x02\u{383}\u{372}\x03\x02\x02\x02\u{383}\u{376}\x03\
	\x02\x02\x02\u{384}\x5b\x03\x02\x02\x02\u{385}\u{386}\x09\x05\x02\x02\u{386}\
	\x5d\x03\x02\x02\x02\u{387}\u{38a}\x05\x60\x31\x02\u{388}\u{38a}\x05\u{c6}\
	\x64\x02\u{389}\u{387}\x03\x02\x02\x02\u{389}\u{388}\x03\x02\x02\x02\u{38a}\
	\x5f\x03\x02\x02\x02\u{38b}\u{38d}\x05\x62\x32\x02\u{38c}\u{38b}\x03\x02\
	\x02\x02\u{38d}\u{390}\x03\x02\x02\x02\u{38e}\u{38c}\x03\x02\x02\x02\u{38e}\
	\u{38f}\x03\x02\x02\x02\u{38f}\u{391}\x03\x02\x02\x02\u{390}\u{38e}\x03\
	\x02\x02\x02\u{391}\u{392}\x07\x0b\x02\x02\u{392}\u{394}\x05\u{1ea}\u{f6}\
	\x02\u{393}\u{395}\x05\x64\x33\x02\u{394}\u{393}\x03\x02\x02\x02\u{394}\
	\u{395}\x03\x02\x02\x02\u{395}\u{397}\x03\x02\x02\x02\u{396}\u{398}\x05\
	\x68\x35\x02\u{397}\u{396}\x03\x02\x02\x02\u{397}\u{398}\x03\x02\x02\x02\
	\u{398}\u{39a}\x03\x02\x02\x02\u{399}\u{39b}\x05\x6a\x36\x02\u{39a}\u{399}\
	\x03\x02\x02\x02\u{39a}\u{39b}\x03\x02\x02\x02\u{39b}\u{39c}\x03\x02\x02\
	\x02\u{39c}\u{39d}\x05\x6e\x38\x02\u{39d}\x61\x03\x02\x02\x02\u{39e}\u{3a7}\
	\x05\u{f2}\x7a\x02\u{39f}\u{3a7}\x07\x2a\x02\x02\u{3a0}\u{3a7}\x07\x28\x02\
	\x02\u{3a1}\u{3a7}\x07\x27\x02\x02\u{3a2}\u{3a7}\x07\x03\x02\x02\u{3a3}\
	\u{3a7}\x07\x2e\x02\x02\u{3a4}\u{3a7}\x07\x15\x02\x02\u{3a5}\u{3a7}\x07\
	\x2f\x02\x02\u{3a6}\u{39e}\x03\x02\x02\x02\u{3a6}\u{39f}\x03\x02\x02\x02\
	\u{3a6}\u{3a0}\x03\x02\x02\x02\u{3a6}\u{3a1}\x03\x02\x02\x02\u{3a6}\u{3a2}\
	\x03\x02\x02\x02\u{3a6}\u{3a3}\x03\x02\x02\x02\u{3a6}\u{3a4}\x03\x02\x02\
	\x02\u{3a6}\u{3a5}\x03\x02\x02\x02\u{3a7}\x63\x03\x02\x02\x02\u{3a8}\u{3a9}\
	\x07\x54\x02\x02\u{3a9}\u{3aa}\x05\x66\x34\x02\u{3aa}\u{3ab}\x07\x53\x02\
	\x02\u{3ab}\x65\x03\x02\x02\x02\u{3ac}\u{3b1}\x05\x22\x12\x02\u{3ad}\u{3ae}\
	\x07\x4d\x02\x02\u{3ae}\u{3b0}\x05\x22\x12\x02\u{3af}\u{3ad}\x03\x02\x02\
	\x02\u{3b0}\u{3b3}\x03\x02\x02\x02\u{3b1}\u{3af}\x03\x02\x02\x02\u{3b1}\
	\u{3b2}\x03\x02\x02\x02\u{3b2}\x67\x03\x02\x02\x02\u{3b3}\u{3b1}\x03\x02\
	\x02\x02\u{3b4}\u{3b5}\x07\x14\x02\x02\u{3b5}\u{3b6}\x05\x10\x09\x02\u{3b6}\
	\x69\x03\x02\x02\x02\u{3b7}\u{3b8}\x07\x1b\x02\x02\u{3b8}\u{3b9}\x05\x6c\
	\x37\x02\u{3b9}\x6b\x03\x02\x02\x02\u{3ba}\u{3bf}\x05\x16\x0c\x02\u{3bb}\
	\u{3bc}\x07\x4d\x02\x02\u{3bc}\u{3be}\x05\x16\x0c\x02\u{3bd}\u{3bb}\x03\
	\x02\x02\x02\u{3be}\u{3c1}\x03\x02\x02\x02\u{3bf}\u{3bd}\x03\x02\x02\x02\
	\u{3bf}\u{3c0}\x03\x02\x02\x02\u{3c0}\x6d\x03\x02\x02\x02\u{3c1}\u{3bf}\
	\x03\x02\x02\x02\u{3c2}\u{3c6}\x07\x48\x02\x02\u{3c3}\u{3c5}\x05\x70\x39\
	\x02\u{3c4}\u{3c3}\x03\x02\x02\x02\u{3c5}\u{3c8}\x03\x02\x02\x02\u{3c6}\
	\u{3c4}\x03\x02\x02\x02\u{3c6}\u{3c7}\x03\x02\x02\x02\u{3c7}\u{3c9}\x03\
	\x02\x02\x02\u{3c8}\u{3c6}\x03\x02\x02\x02\u{3c9}\u{3ca}\x07\x49\x02\x02\
	\u{3ca}\x6f\x03\x02\x02\x02\u{3cb}\u{3d0}\x05\x72\x3a\x02\u{3cc}\u{3d0}\
	\x05\u{b6}\x5c\x02\u{3cd}\u{3d0}\x05\u{b8}\x5d\x02\u{3ce}\u{3d0}\x05\u{ba}\
	\x5e\x02\u{3cf}\u{3cb}\x03\x02\x02\x02\u{3cf}\u{3cc}\x03\x02\x02\x02\u{3cf}\
	\u{3cd}\x03\x02\x02\x02\u{3cf}\u{3ce}\x03\x02\x02\x02\u{3d0}\x71\x03\x02\
	\x02\x02\u{3d1}\u{3d7}\x05\x74\x3b\x02\u{3d2}\u{3d7}\x05\u{98}\x4d\x02\u{3d3}\
	\u{3d7}\x05\x5e\x30\x02\u{3d4}\u{3d7}\x05\u{d2}\x6a\x02\u{3d5}\u{3d7}\x07\
	\x4c\x02\x02\u{3d6}\u{3d1}\x03\x02\x02\x02\u{3d6}\u{3d2}\x03\x02\x02\x02\
	\u{3d6}\u{3d3}\x03\x02\x02\x02\u{3d6}\u{3d4}\x03\x02\x02\x02\u{3d6}\u{3d5}\
	\x03\x02\x02\x02\u{3d7}\x73\x03\x02\x02\x02\u{3d8}\u{3da}\x05\x76\x3c\x02\
	\u{3d9}\u{3d8}\x03\x02\x02\x02\u{3da}\u{3dd}\x03\x02\x02\x02\u{3db}\u{3d9}\
	\x03\x02\x02\x02\u{3db}\u{3dc}\x03\x02\x02\x02\u{3dc}\u{3de}\x03\x02\x02\
	\x02\u{3dd}\u{3db}\x03\x02\x02\x02\u{3de}\u{3df}\x05\u{80}\x41\x02\u{3df}\
	\u{3e0}\x05\x78\x3d\x02\u{3e0}\u{3e1}\x07\x4c\x02\x02\u{3e1}\x75\x03\x02\
	\x02\x02\u{3e2}\u{3eb}\x05\u{f2}\x7a\x02\u{3e3}\u{3eb}\x07\x2a\x02\x02\u{3e4}\
	\u{3eb}\x07\x28\x02\x02\u{3e5}\u{3eb}\x07\x27\x02\x02\u{3e6}\u{3eb}\x07\
	\x2e\x02\x02\u{3e7}\u{3eb}\x07\x15\x02\x02\u{3e8}\u{3eb}\x07\x37\x02\x02\
	\u{3e9}\u{3eb}\x07\x3c\x02\x02\u{3ea}\u{3e2}\x03\x02\x02\x02\u{3ea}\u{3e3}\
	\x03\x02\x02\x02\u{3ea}\u{3e4}\x03\x02\x02\x02\u{3ea}\u{3e5}\x03\x02\x02\
	\x02\u{3ea}\u{3e6}\x03\x02\x02\x02\u{3ea}\u{3e7}\x03\x02\x02\x02\u{3ea}\
	\u{3e8}\x03\x02\x02\x02\u{3ea}\u{3e9}\x03\x02\x02\x02\u{3eb}\x77\x03\x02\
	\x02\x02\u{3ec}\u{3f1}\x05\x7a\x3e\x02\u{3ed}\u{3ee}\x07\x4d\x02\x02\u{3ee}\
	\u{3f0}\x05\x7a\x3e\x02\u{3ef}\u{3ed}\x03\x02\x02\x02\u{3f0}\u{3f3}\x03\
	\x02\x02\x02\u{3f1}\u{3ef}\x03\x02\x02\x02\u{3f1}\u{3f2}\x03\x02\x02\x02\
	\u{3f2}\x79\x03\x02\x02\x02\u{3f3}\u{3f1}\x03\x02\x02\x02\u{3f4}\u{3f7}\
	\x05\x7c\x3f\x02\u{3f5}\u{3f6}\x07\x52\x02\x02\u{3f6}\u{3f8}\x05\x7e\x40\
	\x02\u{3f7}\u{3f5}\x03\x02\x02\x02\u{3f7}\u{3f8}\x03\x02\x02\x02\u{3f8}\
	\x7b\x03\x02\x02\x02\u{3f9}\u{3fb}\x05\u{1ea}\u{f6}\x02\u{3fa}\u{3fc}\x05\
	\x20\x11\x02\u{3fb}\u{3fa}\x03\x02\x02\x02\u{3fb}\u{3fc}\x03\x02\x02\x02\
	\u{3fc}\x7d\x03\x02\x02\x02\u{3fd}\u{400}\x05\u{1ae}\u{d8}\x02\u{3fe}\u{400}\
	\x05\u{104}\u{83}\x02\u{3ff}\u{3fd}\x03\x02\x02\x02\u{3ff}\u{3fe}\x03\x02\
	\x02\x02\u{400}\x7f\x03\x02\x02\x02\u{401}\u{404}\x05\u{82}\x42\x02\u{402}\
	\u{404}\x05\u{84}\x43\x02\u{403}\u{401}\x03\x02\x02\x02\u{403}\u{402}\x03\
	\x02\x02\x02\u{404}\u{81}\x03\x02\x02\x02\u{405}\u{408}\x05\x06\x04\x02\
	\u{406}\u{408}\x07\x05\x02\x02\u{407}\u{405}\x03\x02\x02\x02\u{407}\u{406}\
	\x03\x02\x02\x02\u{408}\u{83}\x03\x02\x02\x02\u{409}\u{40d}\x05\u{86}\x44\
	\x02\u{40a}\u{40d}\x05\u{94}\x4b\x02\u{40b}\u{40d}\x05\u{96}\x4c\x02\u{40c}\
	\u{409}\x03\x02\x02\x02\u{40c}\u{40a}\x03\x02\x02\x02\u{40c}\u{40b}\x03\
	\x02\x02\x02\u{40d}\u{85}\x03\x02\x02\x02\u{40e}\u{411}\x05\u{8c}\x47\x02\
	\u{40f}\u{411}\x05\u{92}\x4a\x02\u{410}\u{40e}\x03\x02\x02\x02\u{410}\u{40f}\
	\x03\x02\x02\x02\u{411}\u{416}\x03\x02\x02\x02\u{412}\u{415}\x05\u{8a}\x46\
	\x02\u{413}\u{415}\x05\u{90}\x49\x02\u{414}\u{412}\x03\x02\x02\x02\u{414}\
	\u{413}\x03\x02\x02\x02\u{415}\u{418}\x03\x02\x02\x02\u{416}\u{414}\x03\
	\x02\x02\x02\u{416}\u{417}\x03\x02\x02\x02\u{417}\u{87}\x03\x02\x02\x02\
	\u{418}\u{416}\x03\x02\x02\x02\u{419}\u{41b}\x05\u{1ea}\u{f6}\x02\u{41a}\
	\u{41c}\x05\x2a\x16\x02\u{41b}\u{41a}\x03\x02\x02\x02\u{41b}\u{41c}\x03\
	\x02\x02\x02\u{41c}\u{42a}\x03\x02\x02\x02\u{41d}\u{41e}\x05\u{86}\x44\x02\
	\u{41e}\u{422}\x07\x4e\x02\x02\u{41f}\u{421}\x05\u{f2}\x7a\x02\u{420}\u{41f}\
	\x03\x02\x02\x02\u{421}\u{424}\x03\x02\x02\x02\u{422}\u{420}\x03\x02\x02\
	\x02\u{422}\u{423}\x03\x02\x02\x02\u{423}\u{425}\x03\x02\x02\x02\u{424}\
	\u{422}\x03\x02\x02\x02\u{425}\u{427}\x05\u{1ea}\u{f6}\x02\u{426}\u{428}\
	\x05\x2a\x16\x02\u{427}\u{426}\x03\x02\x02\x02\u{427}\u{428}\x03\x02\x02\
	\x02\u{428}\u{42a}\x03\x02\x02\x02\u{429}\u{419}\x03\x02\x02\x02\u{429}\
	\u{41d}\x03\x02\x02\x02\u{42a}\u{89}\x03\x02\x02\x02\u{42b}\u{42f}\x07\x4e\
	\x02\x02\u{42c}\u{42e}\x05\u{f2}\x7a\x02\u{42d}\u{42c}\x03\x02\x02\x02\u{42e}\
	\u{431}\x03\x02\x02\x02\u{42f}\u{42d}\x03\x02\x02\x02\u{42f}\u{430}\x03\
	\x02\x02\x02\u{430}\u{432}\x03\x02\x02\x02\u{431}\u{42f}\x03\x02\x02\x02\
	\u{432}\u{434}\x05\u{1ea}\u{f6}\x02\u{433}\u{435}\x05\x2a\x16\x02\u{434}\
	\u{433}\x03\x02\x02\x02\u{434}\u{435}\x03\x02\x02\x02\u{435}\u{8b}\x03\x02\
	\x02\x02\u{436}\u{438}\x05\u{1ea}\u{f6}\x02\u{437}\u{439}\x05\x2a\x16\x02\
	\u{438}\u{437}\x03\x02\x02\x02\u{438}\u{439}\x03\x02\x02\x02\u{439}\u{8d}\
	\x03\x02\x02\x02\u{43a}\u{43b}\x05\u{88}\x45\x02\u{43b}\u{8f}\x03\x02\x02\
	\x02\u{43c}\u{43d}\x05\u{8a}\x46\x02\u{43d}\u{91}\x03\x02\x02\x02\u{43e}\
	\u{43f}\x05\u{8c}\x47\x02\u{43f}\u{93}\x03\x02\x02\x02\u{440}\u{441}\x05\
	\u{1ea}\u{f6}\x02\u{441}\u{95}\x03\x02\x02\x02\u{442}\u{443}\x05\u{82}\x42\
	\x02\u{443}\u{444}\x05\x20\x11\x02\u{444}\u{44c}\x03\x02\x02\x02\u{445}\
	\u{446}\x05\u{86}\x44\x02\u{446}\u{447}\x05\x20\x11\x02\u{447}\u{44c}\x03\
	\x02\x02\x02\u{448}\u{449}\x05\u{94}\x4b\x02\u{449}\u{44a}\x05\x20\x11\x02\
	\u{44a}\u{44c}\x03\x02\x02\x02\u{44b}\u{442}\x03\x02\x02\x02\u{44b}\u{445}\
	\x03\x02\x02\x02\u{44b}\u{448}\x03\x02\x02\x02\u{44c}\u{97}\x03\x02\x02\
	\x02\u{44d}\u{44f}\x05\u{9a}\x4e\x02\u{44e}\u{44d}\x03\x02\x02\x02\u{44f}\
	\u{452}\x03\x02\x02\x02\u{450}\u{44e}\x03\x02\x02\x02\u{450}\u{451}\x03\
	\x02\x02\x02\u{451}\u{453}\x03\x02\x02\x02\u{452}\u{450}\x03\x02\x02\x02\
	\u{453}\u{454}\x05\u{9c}\x4f\x02\u{454}\u{455}\x05\u{b4}\x5b\x02\u{455}\
	\u{99}\x03\x02\x02\x02\u{456}\u{461}\x05\u{f2}\x7a\x02\u{457}\u{461}\x07\
	\x2a\x02\x02\u{458}\u{461}\x07\x28\x02\x02\u{459}\u{461}\x07\x27\x02\x02\
	\u{45a}\u{461}\x07\x03\x02\x02\u{45b}\u{461}\x07\x2e\x02\x02\u{45c}\u{461}\
	\x07\x15\x02\x02\u{45d}\u{461}\x07\x32\x02\x02\u{45e}\u{461}\x07\x22\x02\
	\x02\u{45f}\u{461}\x07\x2f\x02\x02\u{460}\u{456}\x03\x02\x02\x02\u{460}\
	\u{457}\x03\x02\x02\x02\u{460}\u{458}\x03\x02\x02\x02\u{460}\u{459}\x03\
	\x02\x02\x02\u{460}\u{45a}\x03\x02\x02\x02\u{460}\u{45b}\x03\x02\x02\x02\
	\u{460}\u{45c}\x03\x02\x02\x02\u{460}\u{45d}\x03\x02\x02\x02\u{460}\u{45e}\
	\x03\x02\x02\x02\u{460}\u{45f}\x03\x02\x02\x02\u{461}\u{9b}\x03\x02\x02\
	\x02\u{462}\u{463}\x05\u{9e}\x50\x02\u{463}\u{465}\x05\u{a0}\x51\x02\u{464}\
	\u{466}\x05\u{ae}\x58\x02\u{465}\u{464}\x03\x02\x02\x02\u{465}\u{466}\x03\
	\x02\x02\x02\u{466}\u{474}\x03\x02\x02\x02\u{467}\u{46b}\x05\x64\x33\x02\
	\u{468}\u{46a}\x05\u{f2}\x7a\x02\u{469}\u{468}\x03\x02\x02\x02\u{46a}\u{46d}\
	\x03\x02\x02\x02\u{46b}\u{469}\x03\x02\x02\x02\u{46b}\u{46c}\x03\x02\x02\
	\x02\u{46c}\u{46e}\x03\x02\x02\x02\u{46d}\u{46b}\x03\x02\x02\x02\u{46e}\
	\u{46f}\x05\u{9e}\x50\x02\u{46f}\u{471}\x05\u{a0}\x51\x02\u{470}\u{472}\
	\x05\u{ae}\x58\x02\u{471}\u{470}\x03\x02\x02\x02\u{471}\u{472}\x03\x02\x02\
	\x02\u{472}\u{474}\x03\x02\x02\x02\u{473}\u{462}\x03\x02\x02\x02\u{473}\
	\u{467}\x03\x02\x02\x02\u{474}\u{9d}\x03\x02\x02\x02\u{475}\u{478}\x05\u{80}\
	\x41\x02\u{476}\u{478}\x07\x3b\x02\x02\u{477}\u{475}\x03\x02\x02\x02\u{477}\
	\u{476}\x03\x02\x02\x02\u{478}\u{9f}\x03\x02\x02\x02\u{479}\u{47a}\x05\u{1ea}\
	\u{f6}\x02\u{47a}\u{47c}\x07\x46\x02\x02\u{47b}\u{47d}\x05\u{a2}\x52\x02\
	\u{47c}\u{47b}\x03\x02\x02\x02\u{47c}\u{47d}\x03\x02\x02\x02\u{47d}\u{47e}\
	\x03\x02\x02\x02\u{47e}\u{480}\x07\x47\x02\x02\u{47f}\u{481}\x05\x20\x11\
	\x02\u{480}\u{47f}\x03\x02\x02\x02\u{480}\u{481}\x03\x02\x02\x02\u{481}\
	\u{a1}\x03\x02\x02\x02\u{482}\u{483}\x05\u{a4}\x53\x02\u{483}\u{484}\x07\
	\x4d\x02\x02\u{484}\u{485}\x05\u{aa}\x56\x02\u{485}\u{489}\x03\x02\x02\x02\
	\u{486}\u{489}\x05\u{aa}\x56\x02\u{487}\u{489}\x05\u{ac}\x57\x02\u{488}\
	\u{482}\x03\x02\x02\x02\u{488}\u{486}\x03\x02\x02\x02\u{488}\u{487}\x03\
	\x02\x02\x02\u{489}\u{a3}\x03\x02\x02\x02\u{48a}\u{48f}\x05\u{a6}\x54\x02\
	\u{48b}\u{48c}\x07\x4d\x02\x02\u{48c}\u{48e}\x05\u{a6}\x54\x02\u{48d}\u{48b}\
	\x03\x02\x02\x02\u{48e}\u{491}\x03\x02\x02\x02\u{48f}\u{48d}\x03\x02\x02\
	\x02\u{48f}\u{490}\x03\x02\x02\x02\u{490}\u{49b}\x03\x02\x02\x02\u{491}\
	\u{48f}\x03\x02\x02\x02\u{492}\u{497}\x05\u{ac}\x57\x02\u{493}\u{494}\x07\
	\x4d\x02\x02\u{494}\u{496}\x05\u{a6}\x54\x02\u{495}\u{493}\x03\x02\x02\x02\
	\u{496}\u{499}\x03\x02\x02\x02\u{497}\u{495}\x03\x02\x02\x02\u{497}\u{498}\
	\x03\x02\x02\x02\u{498}\u{49b}\x03\x02\x02\x02\u{499}\u{497}\x03\x02\x02\
	\x02\u{49a}\u{48a}\x03\x02\x02\x02\u{49a}\u{492}\x03\x02\x02\x02\u{49b}\
	\u{a5}\x03\x02\x02\x02\u{49c}\u{49e}\x05\u{a8}\x55\x02\u{49d}\u{49c}\x03\
	\x02\x02\x02\u{49e}\u{4a1}\x03\x02\x02\x02\u{49f}\u{49d}\x03\x02\x02\x02\
	\u{49f}\u{4a0}\x03\x02\x02\x02\u{4a0}\u{4a2}\x03\x02\x02\x02\u{4a1}\u{49f}\
	\x03\x02\x02\x02\u{4a2}\u{4a3}\x05\u{80}\x41\x02\u{4a3}\u{4a4}\x05\x7c\x3f\
	\x02\u{4a4}\u{a7}\x03\x02\x02\x02\u{4a5}\u{4a8}\x05\u{f2}\x7a\x02\u{4a6}\
	\u{4a8}\x07\x15\x02\x02\u{4a7}\u{4a5}\x03\x02\x02\x02\u{4a7}\u{4a6}\x03\
	\x02\x02\x02\u{4a8}\u{a9}\x03\x02\x02\x02\u{4a9}\u{4ab}\x05\u{a8}\x55\x02\
	\u{4aa}\u{4a9}\x03\x02\x02\x02\u{4ab}\u{4ae}\x03\x02\x02\x02\u{4ac}\u{4aa}\
	\x03\x02\x02\x02\u{4ac}\u{4ad}\x03\x02\x02\x02\u{4ad}\u{4af}\x03\x02\x02\
	\x02\u{4ae}\u{4ac}\x03\x02\x02\x02\u{4af}\u{4b3}\x05\u{80}\x41\x02\u{4b0}\
	\u{4b2}\x05\u{f2}\x7a\x02\u{4b1}\u{4b0}\x03\x02\x02\x02\u{4b2}\u{4b5}\x03\
	\x02\x02\x02\u{4b3}\u{4b1}\x03\x02\x02\x02\u{4b3}\u{4b4}\x03\x02\x02\x02\
	\u{4b4}\u{4b6}\x03\x02\x02\x02\u{4b5}\u{4b3}\x03\x02\x02\x02\u{4b6}\u{4b7}\
	\x07\x4f\x02\x02\u{4b7}\u{4b8}\x05\x7c\x3f\x02\u{4b8}\u{4bb}\x03\x02\x02\
	\x02\u{4b9}\u{4bb}\x05\u{a6}\x54\x02\u{4ba}\u{4ac}\x03\x02\x02\x02\u{4ba}\
	\u{4b9}\x03\x02\x02\x02\u{4bb}\u{ab}\x03\x02\x02\x02\u{4bc}\u{4be}\x05\u{f2}\
	\x7a\x02\u{4bd}\u{4bc}\x03\x02\x02\x02\u{4be}\u{4c1}\x03\x02\x02\x02\u{4bf}\
	\u{4bd}\x03\x02\x02\x02\u{4bf}\u{4c0}\x03\x02\x02\x02\u{4c0}\u{4c2}\x03\
	\x02\x02\x02\u{4c1}\u{4bf}\x03\x02\x02\x02\u{4c2}\u{4c6}\x05\u{80}\x41\x02\
	\u{4c3}\u{4c4}\x05\u{1ea}\u{f6}\x02\u{4c4}\u{4c5}\x07\x4e\x02\x02\u{4c5}\
	\u{4c7}\x03\x02\x02\x02\u{4c6}\u{4c3}\x03\x02\x02\x02\u{4c6}\u{4c7}\x03\
	\x02\x02\x02\u{4c7}\u{4c8}\x03\x02\x02\x02\u{4c8}\u{4c9}\x07\x33\x02\x02\
	\u{4c9}\u{ad}\x03\x02\x02\x02\u{4ca}\u{4cb}\x07\x35\x02\x02\u{4cb}\u{4cc}\
	\x05\u{b0}\x59\x02\u{4cc}\u{af}\x03\x02\x02\x02\u{4cd}\u{4d2}\x05\u{b2}\
	\x5a\x02\u{4ce}\u{4cf}\x07\x4d\x02\x02\u{4cf}\u{4d1}\x05\u{b2}\x5a\x02\u{4d0}\
	\u{4ce}\x03\x02\x02\x02\u{4d1}\u{4d4}\x03\x02\x02\x02\u{4d2}\u{4d0}\x03\
	\x02\x02\x02\u{4d2}\u{4d3}\x03\x02\x02\x02\u{4d3}\u{b1}\x03\x02\x02\x02\
	\u{4d4}\u{4d2}\x03\x02\x02\x02\u{4d5}\u{4d8}\x05\x10\x09\x02\u{4d6}\u{4d8}\
	\x05\x1c\x0f\x02\u{4d7}\u{4d5}\x03\x02\x02\x02\u{4d7}\u{4d6}\x03\x02\x02\
	\x02\u{4d8}\u{b3}\x03\x02\x02\x02\u{4d9}\u{4dc}\x05\u{108}\u{85}\x02\u{4da}\
	\u{4dc}\x07\x4c\x02\x02\u{4db}\u{4d9}\x03\x02\x02\x02\u{4db}\u{4da}\x03\
	\x02\x02\x02\u{4dc}\u{b5}\x03\x02\x02\x02\u{4dd}\u{4de}\x05\u{108}\u{85}\
	\x02\u{4de}\u{b7}\x03\x02\x02\x02\u{4df}\u{4e0}\x07\x2e\x02\x02\u{4e0}\u{4e1}\
	\x05\u{108}\u{85}\x02\u{4e1}\u{b9}\x03\x02\x02\x02\u{4e2}\u{4e4}\x05\u{bc}\
	\x5f\x02\u{4e3}\u{4e2}\x03\x02\x02\x02\u{4e4}\u{4e7}\x03\x02\x02\x02\u{4e5}\
	\u{4e3}\x03\x02\x02\x02\u{4e5}\u{4e6}\x03\x02\x02\x02\u{4e6}\u{4e8}\x03\
	\x02\x02\x02\u{4e7}\u{4e5}\x03\x02\x02\x02\u{4e8}\u{4ea}\x05\u{be}\x60\x02\
	\u{4e9}\u{4eb}\x05\u{ae}\x58\x02\u{4ea}\u{4e9}\x03\x02\x02\x02\u{4ea}\u{4eb}\
	\x03\x02\x02\x02\u{4eb}\u{4ec}\x03\x02\x02\x02\u{4ec}\u{4ed}\x05\u{c2}\x62\
	\x02\u{4ed}\u{bb}\x03\x02\x02\x02\u{4ee}\u{4f3}\x05\u{f2}\x7a\x02\u{4ef}\
	\u{4f3}\x07\x2a\x02\x02\u{4f0}\u{4f3}\x07\x28\x02\x02\u{4f1}\u{4f3}\x07\
	\x27\x02\x02\u{4f2}\u{4ee}\x03\x02\x02\x02\u{4f2}\u{4ef}\x03\x02\x02\x02\
	\u{4f2}\u{4f0}\x03\x02\x02\x02\u{4f2}\u{4f1}\x03\x02\x02\x02\u{4f3}\u{bd}\
	\x03\x02\x02\x02\u{4f4}\u{4f6}\x05\x64\x33\x02\u{4f5}\u{4f4}\x03\x02\x02\
	\x02\u{4f5}\u{4f6}\x03\x02\x02\x02\u{4f6}\u{4f7}\x03\x02\x02\x02\u{4f7}\
	\u{4f8}\x05\u{c0}\x61\x02\u{4f8}\u{4fa}\x07\x46\x02\x02\u{4f9}\u{4fb}\x05\
	\u{a2}\x52\x02\u{4fa}\u{4f9}\x03\x02\x02\x02\u{4fa}\u{4fb}\x03\x02\x02\x02\
	\u{4fb}\u{4fc}\x03\x02\x02\x02\u{4fc}\u{4fd}\x07\x47\x02\x02\u{4fd}\u{bf}\
	\x03\x02\x02\x02\u{4fe}\u{4ff}\x05\u{1ea}\u{f6}\x02\u{4ff}\u{c1}\x03\x02\
	\x02\x02\u{500}\u{502}\x07\x48\x02\x02\u{501}\u{503}\x05\u{c4}\x63\x02\u{502}\
	\u{501}\x03\x02\x02\x02\u{502}\u{503}\x03\x02\x02\x02\u{503}\u{505}\x03\
	\x02\x02\x02\u{504}\u{506}\x05\u{10a}\u{86}\x02\u{505}\u{504}\x03\x02\x02\
	\x02\u{505}\u{506}\x03\x02\x02\x02\u{506}\u{507}\x03\x02\x02\x02\u{507}\
	\u{508}\x07\x49\x02\x02\u{508}\u{c3}\x03\x02\x02\x02\u{509}\u{50b}\x05\x2a\
	\x16\x02\u{50a}\u{509}\x03\x02\x02\x02\u{50a}\u{50b}\x03\x02\x02\x02\u{50b}\
	\u{50c}\x03\x02\x02\x02\u{50c}\u{50d}\x07\x33\x02\x02\u{50d}\u{50f}\x07\
	\x46\x02\x02\u{50e}\u{510}\x05\u{19e}\u{d0}\x02\u{50f}\u{50e}\x03\x02\x02\
	\x02\u{50f}\u{510}\x03\x02\x02\x02\u{510}\u{511}\x03\x02\x02\x02\u{511}\
	\u{512}\x07\x47\x02\x02\u{512}\u{538}\x07\x4c\x02\x02\u{513}\u{515}\x05\
	\x2a\x16\x02\u{514}\u{513}\x03\x02\x02\x02\u{514}\u{515}\x03\x02\x02\x02\
	\u{515}\u{516}\x03\x02\x02\x02\u{516}\u{517}\x07\x30\x02\x02\u{517}\u{519}\
	\x07\x46\x02\x02\u{518}\u{51a}\x05\u{19e}\u{d0}\x02\u{519}\u{518}\x03\x02\
	\x02\x02\u{519}\u{51a}\x03\x02\x02\x02\u{51a}\u{51b}\x03\x02\x02\x02\u{51b}\
	\u{51c}\x07\x47\x02\x02\u{51c}\u{538}\x07\x4c\x02\x02\u{51d}\u{51e}\x05\
	\x3c\x1f\x02\u{51e}\u{520}\x07\x4e\x02\x02\u{51f}\u{521}\x05\x2a\x16\x02\
	\u{520}\u{51f}\x03\x02\x02\x02\u{520}\u{521}\x03\x02\x02\x02\u{521}\u{522}\
	\x03\x02\x02\x02\u{522}\u{523}\x07\x30\x02\x02\u{523}\u{525}\x07\x46\x02\
	\x02\u{524}\u{526}\x05\u{19e}\u{d0}\x02\u{525}\u{524}\x03\x02\x02\x02\u{525}\
	\u{526}\x03\x02\x02\x02\u{526}\u{527}\x03\x02\x02\x02\u{527}\u{528}\x07\
	\x47\x02\x02\u{528}\u{529}\x07\x4c\x02\x02\u{529}\u{538}\x03\x02\x02\x02\
	\u{52a}\u{52b}\x05\u{16e}\u{b8}\x02\u{52b}\u{52d}\x07\x4e\x02\x02\u{52c}\
	\u{52e}\x05\x2a\x16\x02\u{52d}\u{52c}\x03\x02\x02\x02\u{52d}\u{52e}\x03\
	\x02\x02\x02\u{52e}\u{52f}\x03\x02\x02\x02\u{52f}\u{530}\x07\x30\x02\x02\
	\u{530}\u{532}\x07\x46\x02\x02\u{531}\u{533}\x05\u{19e}\u{d0}\x02\u{532}\
	\u{531}\x03\x02\x02\x02\u{532}\u{533}\x03\x02\x02\x02\u{533}\u{534}\x03\
	\x02\x02\x02\u{534}\u{535}\x07\x47\x02\x02\u{535}\u{536}\x07\x4c\x02\x02\
	\u{536}\u{538}\x03\x02\x02\x02\u{537}\u{50a}\x03\x02\x02\x02\u{537}\u{514}\
	\x03\x02\x02\x02\u{537}\u{51d}\x03\x02\x02\x02\u{537}\u{52a}\x03\x02\x02\
	\x02\u{538}\u{c5}\x03\x02\x02\x02\u{539}\u{53b}\x05\x62\x32\x02\u{53a}\u{539}\
	\x03\x02\x02\x02\u{53b}\u{53e}\x03\x02\x02\x02\u{53c}\u{53a}\x03\x02\x02\
	\x02\u{53c}\u{53d}\x03\x02\x02\x02\u{53d}\u{53f}\x03\x02\x02\x02\u{53e}\
	\u{53c}\x03\x02\x02\x02\u{53f}\u{540}\x07\x12\x02\x02\u{540}\u{542}\x05\
	\u{1ea}\u{f6}\x02\u{541}\u{543}\x05\x6a\x36\x02\u{542}\u{541}\x03\x02\x02\
	\x02\u{542}\u{543}\x03\x02\x02\x02\u{543}\u{544}\x03\x02\x02\x02\u{544}\
	\u{545}\x05\u{c8}\x65\x02\u{545}\u{c7}\x03\x02\x02\x02\u{546}\u{548}\x07\
	\x48\x02\x02\u{547}\u{549}\x05\u{ca}\x66\x02\u{548}\u{547}\x03\x02\x02\x02\
	\u{548}\u{549}\x03\x02\x02\x02\u{549}\u{54b}\x03\x02\x02\x02\u{54a}\u{54c}\
	\x07\x4d\x02\x02\u{54b}\u{54a}\x03\x02\x02\x02\u{54b}\u{54c}\x03\x02\x02\
	\x02\u{54c}\u{54e}\x03\x02\x02\x02\u{54d}\u{54f}\x05\u{d0}\x69\x02\u{54e}\
	\u{54d}\x03\x02\x02\x02\u{54e}\u{54f}\x03\x02\x02\x02\u{54f}\u{550}\x03\
	\x02\x02\x02\u{550}\u{551}\x07\x49\x02\x02\u{551}\u{c9}\x03\x02\x02\x02\
	\u{552}\u{557}\x05\u{cc}\x67\x02\u{553}\u{554}\x07\x4d\x02\x02\u{554}\u{556}\
	\x05\u{cc}\x67\x02\u{555}\u{553}\x03\x02\x02\x02\u{556}\u{559}\x03\x02\x02\
	\x02\u{557}\u{555}\x03\x02\x02\x02\u{557}\u{558}\x03\x02\x02\x02\u{558}\
	\u{cb}\x03\x02\x02\x02\u{559}\u{557}\x03\x02\x02\x02\u{55a}\u{55c}\x05\u{ce}\
	\x68\x02\u{55b}\u{55a}\x03\x02\x02\x02\u{55c}\u{55f}\x03\x02\x02\x02\u{55d}\
	\u{55b}\x03\x02\x02\x02\u{55d}\u{55e}\x03\x02\x02\x02\u{55e}\u{560}\x03\
	\x02\x02\x02\u{55f}\u{55d}\x03\x02\x02\x02\u{560}\u{566}\x05\u{1ea}\u{f6}\
	\x02\u{561}\u{563}\x07\x46\x02\x02\u{562}\u{564}\x05\u{19e}\u{d0}\x02\u{563}\
	\u{562}\x03\x02\x02\x02\u{563}\u{564}\x03\x02\x02\x02\u{564}\u{565}\x03\
	\x02\x02\x02\u{565}\u{567}\x07\x47\x02\x02\u{566}\u{561}\x03\x02\x02\x02\
	\u{566}\u{567}\x03\x02\x02\x02\u{567}\u{569}\x03\x02\x02\x02\u{568}\u{56a}\
	\x05\x6e\x38\x02\u{569}\u{568}\x03\x02\x02\x02\u{569}\u{56a}\x03\x02\x02\
	\x02\u{56a}\u{cd}\x03\x02\x02\x02\u{56b}\u{56c}\x05\u{f2}\x7a\x02\u{56c}\
	\u{cf}\x03\x02\x02\x02\u{56d}\u{571}\x07\x4c\x02\x02\u{56e}\u{570}\x05\x70\
	\x39\x02\u{56f}\u{56e}\x03\x02\x02\x02\u{570}\u{573}\x03\x02\x02\x02\u{571}\
	\u{56f}\x03\x02\x02\x02\u{571}\u{572}\x03\x02\x02\x02\u{572}\u{d1}\x03\x02\
	\x02\x02\u{573}\u{571}\x03\x02\x02\x02\u{574}\u{577}\x05\u{d4}\x6b\x02\u{575}\
	\u{577}\x05\u{e6}\x74\x02\u{576}\u{574}\x03\x02\x02\x02\u{576}\u{575}\x03\
	\x02\x02\x02\u{577}\u{d3}\x03\x02\x02\x02\u{578}\u{57a}\x05\u{d6}\x6c\x02\
	\u{579}\u{578}\x03\x02\x02\x02\u{57a}\u{57d}\x03\x02\x02\x02\u{57b}\u{579}\
	\x03\x02\x02\x02\u{57b}\u{57c}\x03\x02\x02\x02\u{57c}\u{57e}\x03\x02\x02\
	\x02\u{57d}\u{57b}\x03\x02\x02\x02\u{57e}\u{57f}\x07\x1f\x02\x02\u{57f}\
	\u{581}\x05\u{1ea}\u{f6}\x02\u{580}\u{582}\x05\x64\x33\x02\u{581}\u{580}\
	\x03\x02\x02\x02\u{581}\u{582}\x03\x02\x02\x02\u{582}\u{584}\x03\x02\x02\
	\x02\u{583}\u{585}\x05\u{d8}\x6d\x02\u{584}\u{583}\x03\x02\x02\x02\u{584}\
	\u{585}\x03\x02\x02\x02\u{585}\u{586}\x03\x02\x02\x02\u{586}\u{587}\x05\
	\u{da}\x6e\x02\u{587}\u{d5}\x03\x02\x02\x02\u{588}\u{590}\x05\u{f2}\x7a\
	\x02\u{589}\u{590}\x07\x2a\x02\x02\u{58a}\u{590}\x07\x28\x02\x02\u{58b}\
	\u{590}\x07\x27\x02\x02\u{58c}\u{590}\x07\x03\x02\x02\u{58d}\u{590}\x07\
	\x2e\x02\x02\u{58e}\u{590}\x07\x2f\x02\x02\u{58f}\u{588}\x03\x02\x02\x02\
	\u{58f}\u{589}\x03\x02\x02\x02\u{58f}\u{58a}\x03\x02\x02\x02\u{58f}\u{58b}\
	\x03\x02\x02\x02\u{58f}\u{58c}\x03\x02\x02\x02\u{58f}\u{58d}\x03\x02\x02\
	\x02\u{58f}\u{58e}\x03\x02\x02\x02\u{590}\u{d7}\x03\x02\x02\x02\u{591}\u{592}\
	\x07\x14\x02\x02\u{592}\u{593}\x05\x6c\x37\x02\u{593}\u{d9}\x03\x02\x02\
	\x02\u{594}\u{598}\x07\x48\x02\x02\u{595}\u{597}\x05\u{dc}\x6f\x02\u{596}\
	\u{595}\x03\x02\x02\x02\u{597}\u{59a}\x03\x02\x02\x02\u{598}\u{596}\x03\
	\x02\x02\x02\u{598}\u{599}\x03\x02\x02\x02\u{599}\u{59b}\x03\x02\x02\x02\
	\u{59a}\u{598}\x03\x02\x02\x02\u{59b}\u{59c}\x07\x49\x02\x02\u{59c}\u{db}\
	\x03\x02\x02\x02\u{59d}\u{5a3}\x05\u{de}\x70\x02\u{59e}\u{5a3}\x05\u{e2}\
	\x72\x02\u{59f}\u{5a3}\x05\x5e\x30\x02\u{5a0}\u{5a3}\x05\u{d2}\x6a\x02\u{5a1}\
	\u{5a3}\x07\x4c\x02\x02\u{5a2}\u{59d}\x03\x02\x02\x02\u{5a2}\u{59e}\x03\
	\x02\x02\x02\u{5a2}\u{59f}\x03\x02\x02\x02\u{5a2}\u{5a0}\x03\x02\x02\x02\
	\u{5a2}\u{5a1}\x03\x02\x02\x02\u{5a3}\u{dd}\x03\x02\x02\x02\u{5a4}\u{5a6}\
	\x05\u{e0}\x71\x02\u{5a5}\u{5a4}\x03\x02\x02\x02\u{5a6}\u{5a9}\x03\x02\x02\
	\x02\u{5a7}\u{5a5}\x03\x02\x02\x02\u{5a7}\u{5a8}\x03\x02\x02\x02\u{5a8}\
	\u{5aa}\x03\x02\x02\x02\u{5a9}\u{5a7}\x03\x02\x02\x02\u{5aa}\u{5ab}\x05\
	\u{80}\x41\x02\u{5ab}\u{5ac}\x05\x78\x3d\x02\u{5ac}\u{5ad}\x07\x4c\x02\x02\
	\u{5ad}\u{df}\x03\x02\x02\x02\u{5ae}\u{5b3}\x05\u{f2}\x7a\x02\u{5af}\u{5b3}\
	\x07\x2a\x02\x02\u{5b0}\u{5b3}\x07\x2e\x02\x02\u{5b1}\u{5b3}\x07\x15\x02\
	\x02\u{5b2}\u{5ae}\x03\x02\x02\x02\u{5b2}\u{5af}\x03\x02\x02\x02\u{5b2}\
	\u{5b0}\x03\x02\x02\x02\u{5b2}\u{5b1}\x03\x02\x02\x02\u{5b3}\u{e1}\x03\x02\
	\x02\x02\u{5b4}\u{5b6}\x05\u{e4}\x73\x02\u{5b5}\u{5b4}\x03\x02\x02\x02\u{5b6}\
	\u{5b9}\x03\x02\x02\x02\u{5b7}\u{5b5}\x03\x02\x02\x02\u{5b7}\u{5b8}\x03\
	\x02\x02\x02\u{5b8}\u{5ba}\x03\x02\x02\x02\u{5b9}\u{5b7}\x03\x02\x02\x02\
	\u{5ba}\u{5bb}\x05\u{9c}\x4f\x02\u{5bb}\u{5bc}\x05\u{b4}\x5b\x02\u{5bc}\
	\u{e3}\x03\x02\x02\x02\u{5bd}\u{5c5}\x05\u{f2}\x7a\x02\u{5be}\u{5c5}\x07\
	\x2a\x02\x02\u{5bf}\u{5c5}\x07\x27\x02\x02\u{5c0}\u{5c5}\x07\x03\x02\x02\
	\u{5c1}\u{5c5}\x07\x0e\x02\x02\u{5c2}\u{5c5}\x07\x2e\x02\x02\u{5c3}\u{5c5}\
	\x07\x2f\x02\x02\u{5c4}\u{5bd}\x03\x02\x02\x02\u{5c4}\u{5be}\x03\x02\x02\
	\x02\u{5c4}\u{5bf}\x03\x02\x02\x02\u{5c4}\u{5c0}\x03\x02\x02\x02\u{5c4}\
	\u{5c1}\x03\x02\x02\x02\u{5c4}\u{5c2}\x03\x02\x02\x02\u{5c4}\u{5c3}\x03\
	\x02\x02\x02\u{5c5}\u{e5}\x03\x02\x02\x02\u{5c6}\u{5c8}\x05\u{d6}\x6c\x02\
	\u{5c7}\u{5c6}\x03\x02\x02\x02\u{5c8}\u{5cb}\x03\x02\x02\x02\u{5c9}\u{5c7}\
	\x03\x02\x02\x02\u{5c9}\u{5ca}\x03\x02\x02\x02\u{5ca}\u{5cc}\x03\x02\x02\
	\x02\u{5cb}\u{5c9}\x03\x02\x02\x02\u{5cc}\u{5cd}\x07\x50\x02\x02\u{5cd}\
	\u{5ce}\x07\x1f\x02\x02\u{5ce}\u{5cf}\x05\u{1ea}\u{f6}\x02\u{5cf}\u{5d0}\
	\x05\u{e8}\x75\x02\u{5d0}\u{e7}\x03\x02\x02\x02\u{5d1}\u{5d5}\x07\x48\x02\
	\x02\u{5d2}\u{5d4}\x05\u{ea}\x76\x02\u{5d3}\u{5d2}\x03\x02\x02\x02\u{5d4}\
	\u{5d7}\x03\x02\x02\x02\u{5d5}\u{5d3}\x03\x02\x02\x02\u{5d5}\u{5d6}\x03\
	\x02\x02\x02\u{5d6}\u{5d8}\x03\x02\x02\x02\u{5d7}\u{5d5}\x03\x02\x02\x02\
	\u{5d8}\u{5d9}\x07\x49\x02\x02\u{5d9}\u{e9}\x03\x02\x02\x02\u{5da}\u{5e0}\
	\x05\u{ec}\x77\x02\u{5db}\u{5e0}\x05\u{de}\x70\x02\u{5dc}\u{5e0}\x05\x5e\
	\x30\x02\u{5dd}\u{5e0}\x05\u{d2}\x6a\x02\u{5de}\u{5e0}\x07\x4c\x02\x02\u{5df}\
	\u{5da}\x03\x02\x02\x02\u{5df}\u{5db}\x03\x02\x02\x02\u{5df}\u{5dc}\x03\
	\x02\x02\x02\u{5df}\u{5dd}\x03\x02\x02\x02\u{5df}\u{5de}\x03\x02\x02\x02\
	\u{5e0}\u{eb}\x03\x02\x02\x02\u{5e1}\u{5e3}\x05\u{ee}\x78\x02\u{5e2}\u{5e1}\
	\x03\x02\x02\x02\u{5e3}\u{5e6}\x03\x02\x02\x02\u{5e4}\u{5e2}\x03\x02\x02\
	\x02\u{5e4}\u{5e5}\x03\x02\x02\x02\u{5e5}\u{5e7}\x03\x02\x02\x02\u{5e6}\
	\u{5e4}\x03\x02\x02\x02\u{5e7}\u{5e8}\x05\u{80}\x41\x02\u{5e8}\u{5e9}\x05\
	\u{1ea}\u{f6}\x02\u{5e9}\u{5ea}\x07\x46\x02\x02\u{5ea}\u{5ec}\x07\x47\x02\
	\x02\u{5eb}\u{5ed}\x05\x20\x11\x02\u{5ec}\u{5eb}\x03\x02\x02\x02\u{5ec}\
	\u{5ed}\x03\x02\x02\x02\u{5ed}\u{5ef}\x03\x02\x02\x02\u{5ee}\u{5f0}\x05\
	\u{f0}\x79\x02\u{5ef}\u{5ee}\x03\x02\x02\x02\u{5ef}\u{5f0}\x03\x02\x02\x02\
	\u{5f0}\u{5f1}\x03\x02\x02\x02\u{5f1}\u{5f2}\x07\x4c\x02\x02\u{5f2}\u{ed}\
	\x03\x02\x02\x02\u{5f3}\u{5f7}\x05\u{f2}\x7a\x02\u{5f4}\u{5f7}\x07\x2a\x02\
	\x02\u{5f5}\u{5f7}\x07\x03\x02\x02\u{5f6}\u{5f3}\x03\x02\x02\x02\u{5f6}\
	\u{5f4}\x03\x02\x02\x02\u{5f6}\u{5f5}\x03\x02\x02\x02\u{5f7}\u{ef}\x03\x02\
	\x02\x02\u{5f8}\u{5f9}\x07\x0e\x02\x02\u{5f9}\u{5fa}\x05\u{fa}\x7e\x02\u{5fa}\
	\u{f1}\x03\x02\x02\x02\u{5fb}\u{5ff}\x05\u{f4}\x7b\x02\u{5fc}\u{5ff}\x05\
	\u{100}\u{81}\x02\u{5fd}\u{5ff}\x05\u{102}\u{82}\x02\u{5fe}\u{5fb}\x03\x02\
	\x02\x02\u{5fe}\u{5fc}\x03\x02\x02\x02\u{5fe}\u{5fd}\x03\x02\x02\x02\u{5ff}\
	\u{f3}\x03\x02\x02\x02\u{600}\u{601}\x07\x50\x02\x02\u{601}\u{602}\x05\x38\
	\x1d\x02\u{602}\u{604}\x07\x46\x02\x02\u{603}\u{605}\x05\u{f6}\x7c\x02\u{604}\
	\u{603}\x03\x02\x02\x02\u{604}\u{605}\x03\x02\x02\x02\u{605}\u{606}\x03\
	\x02\x02\x02\u{606}\u{607}\x07\x47\x02\x02\u{607}\u{f5}\x03\x02\x02\x02\
	\u{608}\u{60d}\x05\u{f8}\x7d\x02\u{609}\u{60a}\x07\x4d\x02\x02\u{60a}\u{60c}\
	\x05\u{f8}\x7d\x02\u{60b}\u{609}\x03\x02\x02\x02\u{60c}\u{60f}\x03\x02\x02\
	\x02\u{60d}\u{60b}\x03\x02\x02\x02\u{60d}\u{60e}\x03\x02\x02\x02\u{60e}\
	\u{f7}\x03\x02\x02\x02\u{60f}\u{60d}\x03\x02\x02\x02\u{610}\u{611}\x05\u{1ea}\
	\u{f6}\x02\u{611}\u{612}\x07\x52\x02\x02\u{612}\u{613}\x05\u{fa}\x7e\x02\
	\u{613}\u{f9}\x03\x02\x02\x02\u{614}\u{618}\x05\u{1c0}\u{e1}\x02\u{615}\
	\u{618}\x05\u{fc}\x7f\x02\u{616}\u{618}\x05\u{f2}\x7a\x02\u{617}\u{614}\
	\x03\x02\x02\x02\u{617}\u{615}\x03\x02\x02\x02\u{617}\u{616}\x03\x02\x02\
	\x02\u{618}\u{fb}\x03\x02\x02\x02\u{619}\u{61b}\x07\x48\x02\x02\u{61a}\u{61c}\
	\x05\u{fe}\u{80}\x02\u{61b}\u{61a}\x03\x02\x02\x02\u{61b}\u{61c}\x03\x02\
	\x02\x02\u{61c}\u{61e}\x03\x02\x02\x02\u{61d}\u{61f}\x07\x4d\x02\x02\u{61e}\
	\u{61d}\x03\x02\x02\x02\u{61e}\u{61f}\x03\x02\x02\x02\u{61f}\u{620}\x03\
	\x02\x02\x02\u{620}\u{621}\x07\x49\x02\x02\u{621}\u{fd}\x03\x02\x02\x02\
	\u{622}\u{627}\x05\u{fa}\x7e\x02\u{623}\u{624}\x07\x4d\x02\x02\u{624}\u{626}\
	\x05\u{fa}\x7e\x02\u{625}\u{623}\x03\x02\x02\x02\u{626}\u{629}\x03\x02\x02\
	\x02\u{627}\u{625}\x03\x02\x02\x02\u{627}\u{628}\x03\x02\x02\x02\u{628}\
	\u{ff}\x03\x02\x02\x02\u{629}\u{627}\x03\x02\x02\x02\u{62a}\u{62b}\x07\x50\
	\x02\x02\u{62b}\u{62c}\x05\x38\x1d\x02\u{62c}\u{101}\x03\x02\x02\x02\u{62d}\
	\u{62e}\x07\x50\x02\x02\u{62e}\u{62f}\x05\x38\x1d\x02\u{62f}\u{630}\x07\
	\x46\x02\x02\u{630}\u{631}\x05\u{fa}\x7e\x02\u{631}\u{632}\x07\x47\x02\x02\
	\u{632}\u{103}\x03\x02\x02\x02\u{633}\u{635}\x07\x48\x02\x02\u{634}\u{636}\
	\x05\u{106}\u{84}\x02\u{635}\u{634}\x03\x02\x02\x02\u{635}\u{636}\x03\x02\
	\x02\x02\u{636}\u{638}\x03\x02\x02\x02\u{637}\u{639}\x07\x4d\x02\x02\u{638}\
	\u{637}\x03\x02\x02\x02\u{638}\u{639}\x03\x02\x02\x02\u{639}\u{63a}\x03\
	\x02\x02\x02\u{63a}\u{63b}\x07\x49\x02\x02\u{63b}\u{105}\x03\x02\x02\x02\
	\u{63c}\u{641}\x05\x7e\x40\x02\u{63d}\u{63e}\x07\x4d\x02\x02\u{63e}\u{640}\
	\x05\x7e\x40\x02\u{63f}\u{63d}\x03\x02\x02\x02\u{640}\u{643}\x03\x02\x02\
	\x02\u{641}\u{63f}\x03\x02\x02\x02\u{641}\u{642}\x03\x02\x02\x02\u{642}\
	\u{107}\x03\x02\x02\x02\u{643}\u{641}\x03\x02\x02\x02\u{644}\u{646}\x07\
	\x48\x02\x02\u{645}\u{647}\x05\u{10a}\u{86}\x02\u{646}\u{645}\x03\x02\x02\
	\x02\u{646}\u{647}\x03\x02\x02\x02\u{647}\u{648}\x03\x02\x02\x02\u{648}\
	\u{649}\x07\x49\x02\x02\u{649}\u{109}\x03\x02\x02\x02\u{64a}\u{64c}\x05\
	\u{10c}\u{87}\x02\u{64b}\u{64a}\x03\x02\x02\x02\u{64c}\u{64d}\x03\x02\x02\
	\x02\u{64d}\u{64b}\x03\x02\x02\x02\u{64d}\u{64e}\x03\x02\x02\x02\u{64e}\
	\u{10b}\x03\x02\x02\x02\u{64f}\u{653}\x05\u{10e}\u{88}\x02\u{650}\u{653}\
	\x05\x5e\x30\x02\u{651}\u{653}\x05\u{112}\u{8a}\x02\u{652}\u{64f}\x03\x02\
	\x02\x02\u{652}\u{650}\x03\x02\x02\x02\u{652}\u{651}\x03\x02\x02\x02\u{653}\
	\u{10d}\x03\x02\x02\x02\u{654}\u{655}\x05\u{110}\u{89}\x02\u{655}\u{656}\
	\x07\x4c\x02\x02\u{656}\u{10f}\x03\x02\x02\x02\u{657}\u{659}\x05\u{a8}\x55\
	\x02\u{658}\u{657}\x03\x02\x02\x02\u{659}\u{65c}\x03\x02\x02\x02\u{65a}\
	\u{658}\x03\x02\x02\x02\u{65a}\u{65b}\x03\x02\x02\x02\u{65b}\u{65d}\x03\
	\x02\x02\x02\u{65c}\u{65a}\x03\x02\x02\x02\u{65d}\u{65e}\x05\u{80}\x41\x02\
	\u{65e}\u{65f}\x05\x78\x3d\x02\u{65f}\u{111}\x03\x02\x02\x02\u{660}\u{667}\
	\x05\u{116}\u{8c}\x02\u{661}\u{667}\x05\u{11a}\u{8e}\x02\u{662}\u{667}\x05\
	\u{122}\u{92}\x02\u{663}\u{667}\x05\u{124}\u{93}\x02\u{664}\u{667}\x05\u{136}\
	\u{9c}\x02\u{665}\u{667}\x05\u{13c}\u{9f}\x02\u{666}\u{660}\x03\x02\x02\
	\x02\u{666}\u{661}\x03\x02\x02\x02\u{666}\u{662}\x03\x02\x02\x02\u{666}\
	\u{663}\x03\x02\x02\x02\u{666}\u{664}\x03\x02\x02\x02\u{666}\u{665}\x03\
	\x02\x02\x02\u{667}\u{113}\x03\x02\x02\x02\u{668}\u{66e}\x05\u{116}\u{8c}\
	\x02\u{669}\u{66e}\x05\u{11c}\u{8f}\x02\u{66a}\u{66e}\x05\u{126}\u{94}\x02\
	\u{66b}\u{66e}\x05\u{138}\u{9d}\x02\u{66c}\u{66e}\x05\u{13e}\u{a0}\x02\u{66d}\
	\u{668}\x03\x02\x02\x02\u{66d}\u{669}\x03\x02\x02\x02\u{66d}\u{66a}\x03\
	\x02\x02\x02\u{66d}\u{66b}\x03\x02\x02\x02\u{66d}\u{66c}\x03\x02\x02\x02\
	\u{66e}\u{115}\x03\x02\x02\x02\u{66f}\u{67c}\x05\u{108}\u{85}\x02\u{670}\
	\u{67c}\x05\u{118}\u{8d}\x02\u{671}\u{67c}\x05\u{11e}\u{90}\x02\u{672}\u{67c}\
	\x05\u{128}\u{95}\x02\u{673}\u{67c}\x05\u{12a}\u{96}\x02\u{674}\u{67c}\x05\
	\u{13a}\u{9e}\x02\u{675}\u{67c}\x05\u{14e}\u{a8}\x02\u{676}\u{67c}\x05\u{150}\
	\u{a9}\x02\u{677}\u{67c}\x05\u{152}\u{aa}\x02\u{678}\u{67c}\x05\u{156}\u{ac}\
	\x02\u{679}\u{67c}\x05\u{154}\u{ab}\x02\u{67a}\u{67c}\x05\u{158}\u{ad}\x02\
	\u{67b}\u{66f}\x03\x02\x02\x02\u{67b}\u{670}\x03\x02\x02\x02\u{67b}\u{671}\
	\x03\x02\x02\x02\u{67b}\u{672}\x03\x02\x02\x02\u{67b}\u{673}\x03\x02\x02\
	\x02\u{67b}\u{674}\x03\x02\x02\x02\u{67b}\u{675}\x03\x02\x02\x02\u{67b}\
	\u{676}\x03\x02\x02\x02\u{67b}\u{677}\x03\x02\x02\x02\u{67b}\u{678}\x03\
	\x02\x02\x02\u{67b}\u{679}\x03\x02\x02\x02\u{67b}\u{67a}\x03\x02\x02\x02\
	\u{67c}\u{117}\x03\x02\x02\x02\u{67d}\u{67e}\x07\x4c\x02\x02\u{67e}\u{119}\
	\x03\x02\x02\x02\u{67f}\u{680}\x05\u{1ea}\u{f6}\x02\u{680}\u{681}\x07\x58\
	\x02\x02\u{681}\u{682}\x05\u{112}\u{8a}\x02\u{682}\u{11b}\x03\x02\x02\x02\
	\u{683}\u{684}\x05\u{1ea}\u{f6}\x02\u{684}\u{685}\x07\x58\x02\x02\u{685}\
	\u{686}\x05\u{114}\u{8b}\x02\u{686}\u{11d}\x03\x02\x02\x02\u{687}\u{688}\
	\x05\u{120}\u{91}\x02\u{688}\u{689}\x07\x4c\x02\x02\u{689}\u{11f}\x03\x02\
	\x02\x02\u{68a}\u{692}\x05\u{1ba}\u{de}\x02\u{68b}\u{692}\x05\u{1d8}\u{ed}\
	\x02\u{68c}\u{692}\x05\u{1da}\u{ee}\x02\u{68d}\u{692}\x05\u{1e0}\u{f1}\x02\
	\u{68e}\u{692}\x05\u{1e4}\u{f3}\x02\u{68f}\u{692}\x05\u{198}\u{cd}\x02\u{690}\
	\u{692}\x05\u{184}\u{c3}\x02\u{691}\u{68a}\x03\x02\x02\x02\u{691}\u{68b}\
	\x03\x02\x02\x02\u{691}\u{68c}\x03\x02\x02\x02\u{691}\u{68d}\x03\x02\x02\
	\x02\u{691}\u{68e}\x03\x02\x02\x02\u{691}\u{68f}\x03\x02\x02\x02\u{691}\
	\u{690}\x03\x02\x02\x02\u{692}\u{121}\x03\x02\x02\x02\u{693}\u{694}\x07\
	\x19\x02\x02\u{694}\u{695}\x07\x46\x02\x02\u{695}\u{696}\x05\u{1ae}\u{d8}\
	\x02\u{696}\u{697}\x07\x47\x02\x02\u{697}\u{698}\x05\u{112}\u{8a}\x02\u{698}\
	\u{123}\x03\x02\x02\x02\u{699}\u{69a}\x07\x19\x02\x02\u{69a}\u{69b}\x07\
	\x46\x02\x02\u{69b}\u{69c}\x05\u{1ae}\u{d8}\x02\u{69c}\u{69d}\x07\x47\x02\
	\x02\u{69d}\u{69e}\x05\u{114}\u{8b}\x02\u{69e}\u{69f}\x07\x11\x02\x02\u{69f}\
	\u{6a0}\x05\u{112}\u{8a}\x02\u{6a0}\u{125}\x03\x02\x02\x02\u{6a1}\u{6a2}\
	\x07\x19\x02\x02\u{6a2}\u{6a3}\x07\x46\x02\x02\u{6a3}\u{6a4}\x05\u{1ae}\
	\u{d8}\x02\u{6a4}\u{6a5}\x07\x47\x02\x02\u{6a5}\u{6a6}\x05\u{114}\u{8b}\
	\x02\u{6a6}\u{6a7}\x07\x11\x02\x02\u{6a7}\u{6a8}\x05\u{114}\u{8b}\x02\u{6a8}\
	\u{127}\x03\x02\x02\x02\u{6a9}\u{6aa}\x07\x04\x02\x02\u{6aa}\u{6ab}\x05\
	\u{1ae}\u{d8}\x02\u{6ab}\u{6ac}\x07\x4c\x02\x02\u{6ac}\u{6b4}\x03\x02\x02\
	\x02\u{6ad}\u{6ae}\x07\x04\x02\x02\u{6ae}\u{6af}\x05\u{1ae}\u{d8}\x02\u{6af}\
	\u{6b0}\x07\x58\x02\x02\u{6b0}\u{6b1}\x05\u{1ae}\u{d8}\x02\u{6b1}\u{6b2}\
	\x07\x4c\x02\x02\u{6b2}\u{6b4}\x03\x02\x02\x02\u{6b3}\u{6a9}\x03\x02\x02\
	\x02\u{6b3}\u{6ad}\x03\x02\x02\x02\u{6b4}\u{129}\x03\x02\x02\x02\u{6b5}\
	\u{6b6}\x07\x31\x02\x02\u{6b6}\u{6b7}\x07\x46\x02\x02\u{6b7}\u{6b8}\x05\
	\u{1ae}\u{d8}\x02\u{6b8}\u{6b9}\x07\x47\x02\x02\u{6b9}\u{6ba}\x05\u{12c}\
	\u{97}\x02\u{6ba}\u{12b}\x03\x02\x02\x02\u{6bb}\u{6bf}\x07\x48\x02\x02\u{6bc}\
	\u{6be}\x05\u{12e}\u{98}\x02\u{6bd}\u{6bc}\x03\x02\x02\x02\u{6be}\u{6c1}\
	\x03\x02\x02\x02\u{6bf}\u{6bd}\x03\x02\x02\x02\u{6bf}\u{6c0}\x03\x02\x02\
	\x02\u{6c0}\u{6c5}\x03\x02\x02\x02\u{6c1}\u{6bf}\x03\x02\x02\x02\u{6c2}\
	\u{6c4}\x05\u{132}\u{9a}\x02\u{6c3}\u{6c2}\x03\x02\x02\x02\u{6c4}\u{6c7}\
	\x03\x02\x02\x02\u{6c5}\u{6c3}\x03\x02\x02\x02\u{6c5}\u{6c6}\x03\x02\x02\
	\x02\u{6c6}\u{6c8}\x03\x02\x02\x02\u{6c7}\u{6c5}\x03\x02\x02\x02\u{6c8}\
	\u{6c9}\x07\x49\x02\x02\u{6c9}\u{12d}\x03\x02\x02\x02\u{6ca}\u{6cb}\x05\
	\u{130}\u{99}\x02\u{6cb}\u{6cc}\x05\u{10a}\u{86}\x02\u{6cc}\u{12f}\x03\x02\
	\x02\x02\u{6cd}\u{6cf}\x05\u{132}\u{9a}\x02\u{6ce}\u{6cd}\x03\x02\x02\x02\
	\u{6cf}\u{6d0}\x03\x02\x02\x02\u{6d0}\u{6ce}\x03\x02\x02\x02\u{6d0}\u{6d1}\
	\x03\x02\x02\x02\u{6d1}\u{131}\x03\x02\x02\x02\u{6d2}\u{6d3}\x07\x08\x02\
	\x02\u{6d3}\u{6d4}\x05\u{1ac}\u{d7}\x02\u{6d4}\u{6d5}\x07\x58\x02\x02\u{6d5}\
	\u{6dd}\x03\x02\x02\x02\u{6d6}\u{6d7}\x07\x08\x02\x02\u{6d7}\u{6d8}\x05\
	\u{134}\u{9b}\x02\u{6d8}\u{6d9}\x07\x58\x02\x02\u{6d9}\u{6dd}\x03\x02\x02\
	\x02\u{6da}\u{6db}\x07\x0e\x02\x02\u{6db}\u{6dd}\x07\x58\x02\x02\u{6dc}\
	\u{6d2}\x03\x02\x02\x02\u{6dc}\u{6d6}\x03\x02\x02\x02\u{6dc}\u{6da}\x03\
	\x02\x02\x02\u{6dd}\u{133}\x03\x02\x02\x02\u{6de}\u{6df}\x05\u{1ea}\u{f6}\
	\x02\u{6df}\u{135}\x03\x02\x02\x02\u{6e0}\u{6e1}\x07\x3d\x02\x02\u{6e1}\
	\u{6e2}\x07\x46\x02\x02\u{6e2}\u{6e3}\x05\u{1ae}\u{d8}\x02\u{6e3}\u{6e4}\
	\x07\x47\x02\x02\u{6e4}\u{6e5}\x05\u{112}\u{8a}\x02\u{6e5}\u{137}\x03\x02\
	\x02\x02\u{6e6}\u{6e7}\x07\x3d\x02\x02\u{6e7}\u{6e8}\x07\x46\x02\x02\u{6e8}\
	\u{6e9}\x05\u{1ae}\u{d8}\x02\u{6e9}\u{6ea}\x07\x47\x02\x02\u{6ea}\u{6eb}\
	\x05\u{114}\u{8b}\x02\u{6eb}\u{139}\x03\x02\x02\x02\u{6ec}\u{6ed}\x07\x0f\
	\x02\x02\u{6ed}\u{6ee}\x05\u{112}\u{8a}\x02\u{6ee}\u{6ef}\x07\x3d\x02\x02\
	\u{6ef}\u{6f0}\x07\x46\x02\x02\u{6f0}\u{6f1}\x05\u{1ae}\u{d8}\x02\u{6f1}\
	\u{6f2}\x07\x47\x02\x02\u{6f2}\u{6f3}\x07\x4c\x02\x02\u{6f3}\u{13b}\x03\
	\x02\x02\x02\u{6f4}\u{6f7}\x05\u{140}\u{a1}\x02\u{6f5}\u{6f7}\x05\u{14a}\
	\u{a6}\x02\u{6f6}\u{6f4}\x03\x02\x02\x02\u{6f6}\u{6f5}\x03\x02\x02\x02\u{6f7}\
	\u{13d}\x03\x02\x02\x02\u{6f8}\u{6fb}\x05\u{142}\u{a2}\x02\u{6f9}\u{6fb}\
	\x05\u{14c}\u{a7}\x02\u{6fa}\u{6f8}\x03\x02\x02\x02\u{6fa}\u{6f9}\x03\x02\
	\x02\x02\u{6fb}\u{13f}\x03\x02\x02\x02\u{6fc}\u{6fd}\x07\x18\x02\x02\u{6fd}\
	\u{6ff}\x07\x46\x02\x02\u{6fe}\u{700}\x05\u{144}\u{a3}\x02\u{6ff}\u{6fe}\
	\x03\x02\x02\x02\u{6ff}\u{700}\x03\x02\x02\x02\u{700}\u{701}\x03\x02\x02\
	\x02\u{701}\u{703}\x07\x4c\x02\x02\u{702}\u{704}\x05\u{1ae}\u{d8}\x02\u{703}\
	\u{702}\x03\x02\x02\x02\u{703}\u{704}\x03\x02\x02\x02\u{704}\u{705}\x03\
	\x02\x02\x02\u{705}\u{707}\x07\x4c\x02\x02\u{706}\u{708}\x05\u{146}\u{a4}\
	\x02\u{707}\u{706}\x03\x02\x02\x02\u{707}\u{708}\x03\x02\x02\x02\u{708}\
	\u{709}\x03\x02\x02\x02\u{709}\u{70a}\x07\x47\x02\x02\u{70a}\u{70b}\x05\
	\u{112}\u{8a}\x02\u{70b}\u{141}\x03\x02\x02\x02\u{70c}\u{70d}\x07\x18\x02\
	\x02\u{70d}\u{70f}\x07\x46\x02\x02\u{70e}\u{710}\x05\u{144}\u{a3}\x02\u{70f}\
	\u{70e}\x03\x02\x02\x02\u{70f}\u{710}\x03\x02\x02\x02\u{710}\u{711}\x03\
	\x02\x02\x02\u{711}\u{713}\x07\x4c\x02\x02\u{712}\u{714}\x05\u{1ae}\u{d8}\
	\x02\u{713}\u{712}\x03\x02\x02\x02\u{713}\u{714}\x03\x02\x02\x02\u{714}\
	\u{715}\x03\x02\x02\x02\u{715}\u{717}\x07\x4c\x02\x02\u{716}\u{718}\x05\
	\u{146}\u{a4}\x02\u{717}\u{716}\x03\x02\x02\x02\u{717}\u{718}\x03\x02\x02\
	\x02\u{718}\u{719}\x03\x02\x02\x02\u{719}\u{71a}\x07\x47\x02\x02\u{71a}\
	\u{71b}\x05\u{114}\u{8b}\x02\u{71b}\u{143}\x03\x02\x02\x02\u{71c}\u{71f}\
	\x05\u{148}\u{a5}\x02\u{71d}\u{71f}\x05\u{110}\u{89}\x02\u{71e}\u{71c}\x03\
	\x02\x02\x02\u{71e}\u{71d}\x03\x02\x02\x02\u{71f}\u{145}\x03\x02\x02\x02\
	\u{720}\u{721}\x05\u{148}\u{a5}\x02\u{721}\u{147}\x03\x02\x02\x02\u{722}\
	\u{727}\x05\u{120}\u{91}\x02\u{723}\u{724}\x07\x4d\x02\x02\u{724}\u{726}\
	\x05\u{120}\u{91}\x02\u{725}\u{723}\x03\x02\x02\x02\u{726}\u{729}\x03\x02\
	\x02\x02\u{727}\u{725}\x03\x02\x02\x02\u{727}\u{728}\x03\x02\x02\x02\u{728}\
	\u{149}\x03\x02\x02\x02\u{729}\u{727}\x03\x02\x02\x02\u{72a}\u{72b}\x07\
	\x18\x02\x02\u{72b}\u{72f}\x07\x46\x02\x02\u{72c}\u{72e}\x05\u{a8}\x55\x02\
	\u{72d}\u{72c}\x03\x02\x02\x02\u{72e}\u{731}\x03\x02\x02\x02\u{72f}\u{72d}\
	\x03\x02\x02\x02\u{72f}\u{730}\x03\x02\x02\x02\u{730}\u{732}\x03\x02\x02\
	\x02\u{731}\u{72f}\x03\x02\x02\x02\u{732}\u{733}\x05\u{80}\x41\x02\u{733}\
	\u{734}\x05\x7c\x3f\x02\u{734}\u{735}\x07\x58\x02\x02\u{735}\u{736}\x05\
	\u{1ae}\u{d8}\x02\u{736}\u{737}\x07\x47\x02\x02\u{737}\u{738}\x05\u{112}\
	\u{8a}\x02\u{738}\u{14b}\x03\x02\x02\x02\u{739}\u{73a}\x07\x18\x02\x02\u{73a}\
	\u{73e}\x07\x46\x02\x02\u{73b}\u{73d}\x05\u{a8}\x55\x02\u{73c}\u{73b}\x03\
	\x02\x02\x02\u{73d}\u{740}\x03\x02\x02\x02\u{73e}\u{73c}\x03\x02\x02\x02\
	\u{73e}\u{73f}\x03\x02\x02\x02\u{73f}\u{741}\x03\x02\x02\x02\u{740}\u{73e}\
	\x03\x02\x02\x02\u{741}\u{742}\x05\u{80}\x41\x02\u{742}\u{743}\x05\x7c\x3f\
	\x02\u{743}\u{744}\x07\x58\x02\x02\u{744}\u{745}\x05\u{1ae}\u{d8}\x02\u{745}\
	\u{746}\x07\x47\x02\x02\u{746}\u{747}\x05\u{114}\u{8b}\x02\u{747}\u{14d}\
	\x03\x02\x02\x02\u{748}\u{74a}\x07\x06\x02\x02\u{749}\u{74b}\x05\u{1ea}\
	\u{f6}\x02\u{74a}\u{749}\x03\x02\x02\x02\u{74a}\u{74b}\x03\x02\x02\x02\u{74b}\
	\u{74c}\x03\x02\x02\x02\u{74c}\u{74d}\x07\x4c\x02\x02\u{74d}\u{14f}\x03\
	\x02\x02\x02\u{74e}\u{750}\x07\x0d\x02\x02\u{74f}\u{751}\x05\u{1ea}\u{f6}\
	\x02\u{750}\u{74f}\x03\x02\x02\x02\u{750}\u{751}\x03\x02\x02\x02\u{751}\
	\u{752}\x03\x02\x02\x02\u{752}\u{753}\x07\x4c\x02\x02\u{753}\u{151}\x03\
	\x02\x02\x02\u{754}\u{756}\x07\x2c\x02\x02\u{755}\u{757}\x05\u{1ae}\u{d8}\
	\x02\u{756}\u{755}\x03\x02\x02\x02\u{756}\u{757}\x03\x02\x02\x02\u{757}\
	\u{758}\x03\x02\x02\x02\u{758}\u{759}\x07\x4c\x02\x02\u{759}\u{153}\x03\
	\x02\x02\x02\u{75a}\u{75b}\x07\x34\x02\x02\u{75b}\u{75c}\x05\u{1ae}\u{d8}\
	\x02\u{75c}\u{75d}\x07\x4c\x02\x02\u{75d}\u{155}\x03\x02\x02\x02\u{75e}\
	\u{75f}\x07\x32\x02\x02\u{75f}\u{760}\x07\x46\x02\x02\u{760}\u{761}\x05\
	\u{1ae}\u{d8}\x02\u{761}\u{762}\x07\x47\x02\x02\u{762}\u{763}\x05\u{108}\
	\u{85}\x02\u{763}\u{157}\x03\x02\x02\x02\u{764}\u{765}\x07\x39\x02\x02\u{765}\
	\u{766}\x05\u{108}\u{85}\x02\u{766}\u{767}\x05\u{15a}\u{ae}\x02\u{767}\u{771}\
	\x03\x02\x02\x02\u{768}\u{769}\x07\x39\x02\x02\u{769}\u{76b}\x05\u{108}\
	\u{85}\x02\u{76a}\u{76c}\x05\u{15a}\u{ae}\x02\u{76b}\u{76a}\x03\x02\x02\
	\x02\u{76b}\u{76c}\x03\x02\x02\x02\u{76c}\u{76d}\x03\x02\x02\x02\u{76d}\
	\u{76e}\x05\u{162}\u{b2}\x02\u{76e}\u{771}\x03\x02\x02\x02\u{76f}\u{771}\
	\x05\u{164}\u{b3}\x02\u{770}\u{764}\x03\x02\x02\x02\u{770}\u{768}\x03\x02\
	\x02\x02\u{770}\u{76f}\x03\x02\x02\x02\u{771}\u{159}\x03\x02\x02\x02\u{772}\
	\u{774}\x05\u{15c}\u{af}\x02\u{773}\u{772}\x03\x02\x02\x02\u{774}\u{775}\
	\x03\x02\x02\x02\u{775}\u{773}\x03\x02\x02\x02\u{775}\u{776}\x03\x02\x02\
	\x02\u{776}\u{15b}\x03\x02\x02\x02\u{777}\u{778}\x07\x09\x02\x02\u{778}\
	\u{779}\x07\x46\x02\x02\u{779}\u{77a}\x05\u{15e}\u{b0}\x02\u{77a}\u{77b}\
	\x07\x47\x02\x02\u{77b}\u{77c}\x05\u{108}\u{85}\x02\u{77c}\u{15d}\x03\x02\
	\x02\x02\u{77d}\u{77f}\x05\u{a8}\x55\x02\u{77e}\u{77d}\x03\x02\x02\x02\u{77f}\
	\u{782}\x03\x02\x02\x02\u{780}\u{77e}\x03\x02\x02\x02\u{780}\u{781}\x03\
	\x02\x02\x02\u{781}\u{783}\x03\x02\x02\x02\u{782}\u{780}\x03\x02\x02\x02\
	\u{783}\u{784}\x05\u{160}\u{b1}\x02\u{784}\u{785}\x05\x7c\x3f\x02\u{785}\
	\u{15f}\x03\x02\x02\x02\u{786}\u{78b}\x05\u{88}\x45\x02\u{787}\u{788}\x07\
	\x67\x02\x02\u{788}\u{78a}\x05\x10\x09\x02\u{789}\u{787}\x03\x02\x02\x02\
	\u{78a}\u{78d}\x03\x02\x02\x02\u{78b}\u{789}\x03\x02\x02\x02\u{78b}\u{78c}\
	\x03\x02\x02\x02\u{78c}\u{161}\x03\x02\x02\x02\u{78d}\u{78b}\x03\x02\x02\
	\x02\u{78e}\u{78f}\x07\x16\x02\x02\u{78f}\u{790}\x05\u{108}\u{85}\x02\u{790}\
	\u{163}\x03\x02\x02\x02\u{791}\u{792}\x07\x39\x02\x02\u{792}\u{793}\x05\
	\u{166}\u{b4}\x02\u{793}\u{795}\x05\u{108}\u{85}\x02\u{794}\u{796}\x05\u{15a}\
	\u{ae}\x02\u{795}\u{794}\x03\x02\x02\x02\u{795}\u{796}\x03\x02\x02\x02\u{796}\
	\u{798}\x03\x02\x02\x02\u{797}\u{799}\x05\u{162}\u{b2}\x02\u{798}\u{797}\
	\x03\x02\x02\x02\u{798}\u{799}\x03\x02\x02\x02\u{799}\u{165}\x03\x02\x02\
	\x02\u{79a}\u{79b}\x07\x46\x02\x02\u{79b}\u{79d}\x05\u{168}\u{b5}\x02\u{79c}\
	\u{79e}\x07\x4c\x02\x02\u{79d}\u{79c}\x03\x02\x02\x02\u{79d}\u{79e}\x03\
	\x02\x02\x02\u{79e}\u{79f}\x03\x02\x02\x02\u{79f}\u{7a0}\x07\x47\x02\x02\
	\u{7a0}\u{167}\x03\x02\x02\x02\u{7a1}\u{7a6}\x05\u{16a}\u{b6}\x02\u{7a2}\
	\u{7a3}\x07\x4c\x02\x02\u{7a3}\u{7a5}\x05\u{16a}\u{b6}\x02\u{7a4}\u{7a2}\
	\x03\x02\x02\x02\u{7a5}\u{7a8}\x03\x02\x02\x02\u{7a6}\u{7a4}\x03\x02\x02\
	\x02\u{7a6}\u{7a7}\x03\x02\x02\x02\u{7a7}\u{169}\x03\x02\x02\x02\u{7a8}\
	\u{7a6}\x03\x02\x02\x02\u{7a9}\u{7ab}\x05\u{a8}\x55\x02\u{7aa}\u{7a9}\x03\
	\x02\x02\x02\u{7ab}\u{7ae}\x03\x02\x02\x02\u{7ac}\u{7aa}\x03\x02\x02\x02\
	\u{7ac}\u{7ad}\x03\x02\x02\x02\u{7ad}\u{7af}\x03\x02\x02\x02\u{7ae}\u{7ac}\
	\x03\x02\x02\x02\u{7af}\u{7b0}\x05\u{80}\x41\x02\u{7b0}\u{7b1}\x05\x7c\x3f\
	\x02\u{7b1}\u{7b2}\x07\x52\x02\x02\u{7b2}\u{7b3}\x05\u{1ae}\u{d8}\x02\u{7b3}\
	\u{7b6}\x03\x02\x02\x02\u{7b4}\u{7b6}\x05\u{16c}\u{b7}\x02\u{7b5}\u{7ac}\
	\x03\x02\x02\x02\u{7b5}\u{7b4}\x03\x02\x02\x02\u{7b6}\u{16b}\x03\x02\x02\
	\x02\u{7b7}\u{7ba}\x05\x3c\x1f\x02\u{7b8}\u{7ba}\x05\u{18c}\u{c7}\x02\u{7b9}\
	\u{7b7}\x03\x02\x02\x02\u{7b9}\u{7b8}\x03\x02\x02\x02\u{7ba}\u{16d}\x03\
	\x02\x02\x02\u{7bb}\u{7be}\x05\u{17c}\u{bf}\x02\u{7bc}\u{7be}\x05\u{1a6}\
	\u{d4}\x02\u{7bd}\u{7bb}\x03\x02\x02\x02\u{7bd}\u{7bc}\x03\x02\x02\x02\u{7be}\
	\u{7c2}\x03\x02\x02\x02\u{7bf}\u{7c1}\x05\u{176}\u{bc}\x02\u{7c0}\u{7bf}\
	\x03\x02\x02\x02\u{7c1}\u{7c4}\x03\x02\x02\x02\u{7c2}\u{7c0}\x03\x02\x02\
	\x02\u{7c2}\u{7c3}\x03\x02\x02\x02\u{7c3}\u{16f}\x03\x02\x02\x02\u{7c4}\
	\u{7c2}\x03\x02\x02\x02\u{7c5}\u{7d6}\x05\x02\x02\x02\u{7c6}\u{7d6}\x05\
	\u{182}\u{c2}\x02\u{7c7}\u{7d6}\x07\x33\x02\x02\u{7c8}\u{7c9}\x05\x38\x1d\
	\x02\u{7c9}\u{7ca}\x07\x4e\x02\x02\u{7ca}\u{7cb}\x07\x33\x02\x02\u{7cb}\
	\u{7d6}\x03\x02\x02\x02\u{7cc}\u{7cd}\x07\x46\x02\x02\u{7cd}\u{7ce}\x05\
	\u{1ae}\u{d8}\x02\u{7ce}\u{7cf}\x07\x47\x02\x02\u{7cf}\u{7d6}\x03\x02\x02\
	\x02\u{7d0}\u{7d6}\x05\u{184}\u{c3}\x02\u{7d1}\u{7d6}\x05\u{18c}\u{c7}\x02\
	\u{7d2}\u{7d6}\x05\u{192}\u{ca}\x02\u{7d3}\u{7d6}\x05\u{198}\u{cd}\x02\u{7d4}\
	\u{7d6}\x05\u{1a0}\u{d1}\x02\u{7d5}\u{7c5}\x03\x02\x02\x02\u{7d5}\u{7c6}\
	\x03\x02\x02\x02\u{7d5}\u{7c7}\x03\x02\x02\x02\u{7d5}\u{7c8}\x03\x02\x02\
	\x02\u{7d5}\u{7cc}\x03\x02\x02\x02\u{7d5}\u{7d0}\x03\x02\x02\x02\u{7d5}\
	\u{7d1}\x03\x02\x02\x02\u{7d5}\u{7d2}\x03\x02\x02\x02\u{7d5}\u{7d3}\x03\
	\x02\x02\x02\u{7d5}\u{7d4}\x03\x02\x02\x02\u{7d6}\u{171}\x03\x02\x02\x02\
	\u{7d7}\u{7d8}\x03\x02\x02\x02\u{7d8}\u{173}\x03\x02\x02\x02\u{7d9}\u{7f6}\
	\x05\x02\x02\x02\u{7da}\u{7df}\x05\x38\x1d\x02\u{7db}\u{7dc}\x07\x4a\x02\
	\x02\u{7dc}\u{7de}\x07\x4b\x02\x02\u{7dd}\u{7db}\x03\x02\x02\x02\u{7de}\
	\u{7e1}\x03\x02\x02\x02\u{7df}\u{7dd}\x03\x02\x02\x02\u{7df}\u{7e0}\x03\
	\x02\x02\x02\u{7e0}\u{7e2}\x03\x02\x02\x02\u{7e1}\u{7df}\x03\x02\x02\x02\
	\u{7e2}\u{7e3}\x07\x4e\x02\x02\u{7e3}\u{7e4}\x07\x0b\x02\x02\u{7e4}\u{7f6}\
	\x03\x02\x02\x02\u{7e5}\u{7e6}\x07\x3b\x02\x02\u{7e6}\u{7e7}\x07\x4e\x02\
	\x02\u{7e7}\u{7f6}\x07\x0b\x02\x02\u{7e8}\u{7f6}\x07\x33\x02\x02\u{7e9}\
	\u{7ea}\x05\x38\x1d\x02\u{7ea}\u{7eb}\x07\x4e\x02\x02\u{7eb}\u{7ec}\x07\
	\x33\x02\x02\u{7ec}\u{7f6}\x03\x02\x02\x02\u{7ed}\u{7ee}\x07\x46\x02\x02\
	\u{7ee}\u{7ef}\x05\u{1ae}\u{d8}\x02\u{7ef}\u{7f0}\x07\x47\x02\x02\u{7f0}\
	\u{7f6}\x03\x02\x02\x02\u{7f1}\u{7f6}\x05\u{184}\u{c3}\x02\u{7f2}\u{7f6}\
	\x05\u{18c}\u{c7}\x02\u{7f3}\u{7f6}\x05\u{198}\u{cd}\x02\u{7f4}\u{7f6}\x05\
	\u{1a0}\u{d1}\x02\u{7f5}\u{7d9}\x03\x02\x02\x02\u{7f5}\u{7da}\x03\x02\x02\
	\x02\u{7f5}\u{7e5}\x03\x02\x02\x02\u{7f5}\u{7e8}\x03\x02\x02\x02\u{7f5}\
	\u{7e9}\x03\x02\x02\x02\u{7f5}\u{7ed}\x03\x02\x02\x02\u{7f5}\u{7f1}\x03\
	\x02\x02\x02\u{7f5}\u{7f2}\x03\x02\x02\x02\u{7f5}\u{7f3}\x03\x02\x02\x02\
	\u{7f5}\u{7f4}\x03\x02\x02\x02\u{7f6}\u{175}\x03\x02\x02\x02\u{7f7}\u{7fd}\
	\x05\u{186}\u{c4}\x02\u{7f8}\u{7fd}\x05\u{18e}\u{c8}\x02\u{7f9}\u{7fd}\x05\
	\u{194}\u{cb}\x02\u{7fa}\u{7fd}\x05\u{19a}\u{ce}\x02\u{7fb}\u{7fd}\x05\u{1a2}\
	\u{d2}\x02\u{7fc}\u{7f7}\x03\x02\x02\x02\u{7fc}\u{7f8}\x03\x02\x02\x02\u{7fc}\
	\u{7f9}\x03\x02\x02\x02\u{7fc}\u{7fa}\x03\x02\x02\x02\u{7fc}\u{7fb}\x03\
	\x02\x02\x02\u{7fd}\u{177}\x03\x02\x02\x02\u{7fe}\u{7ff}\x03\x02\x02\x02\
	\u{7ff}\u{179}\x03\x02\x02\x02\u{800}\u{805}\x05\u{186}\u{c4}\x02\u{801}\
	\u{805}\x05\u{18e}\u{c8}\x02\u{802}\u{805}\x05\u{19a}\u{ce}\x02\u{803}\u{805}\
	\x05\u{1a2}\u{d2}\x02\u{804}\u{800}\x03\x02\x02\x02\u{804}\u{801}\x03\x02\
	\x02\x02\u{804}\u{802}\x03\x02\x02\x02\u{804}\u{803}\x03\x02\x02\x02\u{805}\
	\u{17b}\x03\x02\x02\x02\u{806}\u{82f}\x05\x02\x02\x02\u{807}\u{80c}\x05\
	\x38\x1d\x02\u{808}\u{809}\x07\x4a\x02\x02\u{809}\u{80b}\x07\x4b\x02\x02\
	\u{80a}\u{808}\x03\x02\x02\x02\u{80b}\u{80e}\x03\x02\x02\x02\u{80c}\u{80a}\
	\x03\x02\x02\x02\u{80c}\u{80d}\x03\x02\x02\x02\u{80d}\u{80f}\x03\x02\x02\
	\x02\u{80e}\u{80c}\x03\x02\x02\x02\u{80f}\u{810}\x07\x4e\x02\x02\u{810}\
	\u{811}\x07\x0b\x02\x02\u{811}\u{82f}\x03\x02\x02\x02\u{812}\u{817}\x05\
	\u{82}\x42\x02\u{813}\u{814}\x07\x4a\x02\x02\u{814}\u{816}\x07\x4b\x02\x02\
	\u{815}\u{813}\x03\x02\x02\x02\u{816}\u{819}\x03\x02\x02\x02\u{817}\u{815}\
	\x03\x02\x02\x02\u{817}\u{818}\x03\x02\x02\x02\u{818}\u{81a}\x03\x02\x02\
	\x02\u{819}\u{817}\x03\x02\x02\x02\u{81a}\u{81b}\x07\x4e\x02\x02\u{81b}\
	\u{81c}\x07\x0b\x02\x02\u{81c}\u{82f}\x03\x02\x02\x02\u{81d}\u{81e}\x07\
	\x3b\x02\x02\u{81e}\u{81f}\x07\x4e\x02\x02\u{81f}\u{82f}\x07\x0b\x02\x02\
	\u{820}\u{82f}\x07\x33\x02\x02\u{821}\u{822}\x05\x38\x1d\x02\u{822}\u{823}\
	\x07\x4e\x02\x02\u{823}\u{824}\x07\x33\x02\x02\u{824}\u{82f}\x03\x02\x02\
	\x02\u{825}\u{826}\x07\x46\x02\x02\u{826}\u{827}\x05\u{1ae}\u{d8}\x02\u{827}\
	\u{828}\x07\x47\x02\x02\u{828}\u{82f}\x03\x02\x02\x02\u{829}\u{82f}\x05\
	\u{188}\u{c5}\x02\u{82a}\u{82f}\x05\u{190}\u{c9}\x02\u{82b}\u{82f}\x05\u{196}\
	\u{cc}\x02\u{82c}\u{82f}\x05\u{19c}\u{cf}\x02\u{82d}\u{82f}\x05\u{1a4}\u{d3}\
	\x02\u{82e}\u{806}\x03\x02\x02\x02\u{82e}\u{807}\x03\x02\x02\x02\u{82e}\
	\u{812}\x03\x02\x02\x02\u{82e}\u{81d}\x03\x02\x02\x02\u{82e}\u{820}\x03\
	\x02\x02\x02\u{82e}\u{821}\x03\x02\x02\x02\u{82e}\u{825}\x03\x02\x02\x02\
	\u{82e}\u{829}\x03\x02\x02\x02\u{82e}\u{82a}\x03\x02\x02\x02\u{82e}\u{82b}\
	\x03\x02\x02\x02\u{82e}\u{82c}\x03\x02\x02\x02\u{82e}\u{82d}\x03\x02\x02\
	\x02\u{82f}\u{17d}\x03\x02\x02\x02\u{830}\u{831}\x03\x02\x02\x02\u{831}\
	\u{17f}\x03\x02\x02\x02\u{832}\u{85a}\x05\x02\x02\x02\u{833}\u{838}\x05\
	\x38\x1d\x02\u{834}\u{835}\x07\x4a\x02\x02\u{835}\u{837}\x07\x4b\x02\x02\
	\u{836}\u{834}\x03\x02\x02\x02\u{837}\u{83a}\x03\x02\x02\x02\u{838}\u{836}\
	\x03\x02\x02\x02\u{838}\u{839}\x03\x02\x02\x02\u{839}\u{83b}\x03\x02\x02\
	\x02\u{83a}\u{838}\x03\x02\x02\x02\u{83b}\u{83c}\x07\x4e\x02\x02\u{83c}\
	\u{83d}\x07\x0b\x02\x02\u{83d}\u{85a}\x03\x02\x02\x02\u{83e}\u{843}\x05\
	\u{82}\x42\x02\u{83f}\u{840}\x07\x4a\x02\x02\u{840}\u{842}\x07\x4b\x02\x02\
	\u{841}\u{83f}\x03\x02\x02\x02\u{842}\u{845}\x03\x02\x02\x02\u{843}\u{841}\
	\x03\x02\x02\x02\u{843}\u{844}\x03\x02\x02\x02\u{844}\u{846}\x03\x02\x02\
	\x02\u{845}\u{843}\x03\x02\x02\x02\u{846}\u{847}\x07\x4e\x02\x02\u{847}\
	\u{848}\x07\x0b\x02\x02\u{848}\u{85a}\x03\x02\x02\x02\u{849}\u{84a}\x07\
	\x3b\x02\x02\u{84a}\u{84b}\x07\x4e\x02\x02\u{84b}\u{85a}\x07\x0b\x02\x02\
	\u{84c}\u{85a}\x07\x33\x02\x02\u{84d}\u{84e}\x05\x38\x1d\x02\u{84e}\u{84f}\
	\x07\x4e\x02\x02\u{84f}\u{850}\x07\x33\x02\x02\u{850}\u{85a}\x03\x02\x02\
	\x02\u{851}\u{852}\x07\x46\x02\x02\u{852}\u{853}\x05\u{1ae}\u{d8}\x02\u{853}\
	\u{854}\x07\x47\x02\x02\u{854}\u{85a}\x03\x02\x02\x02\u{855}\u{85a}\x05\
	\u{188}\u{c5}\x02\u{856}\u{85a}\x05\u{190}\u{c9}\x02\u{857}\u{85a}\x05\u{19c}\
	\u{cf}\x02\u{858}\u{85a}\x05\u{1a4}\u{d3}\x02\u{859}\u{832}\x03\x02\x02\
	\x02\u{859}\u{833}\x03\x02\x02\x02\u{859}\u{83e}\x03\x02\x02\x02\u{859}\
	\u{849}\x03\x02\x02\x02\u{859}\u{84c}\x03\x02\x02\x02\u{859}\u{84d}\x03\
	\x02\x02\x02\u{859}\u{851}\x03\x02\x02\x02\u{859}\u{855}\x03\x02\x02\x02\
	\u{859}\u{856}\x03\x02\x02\x02\u{859}\u{857}\x03\x02\x02\x02\u{859}\u{858}\
	\x03\x02\x02\x02\u{85a}\u{181}\x03\x02\x02\x02\u{85b}\u{85f}\x05\x38\x1d\
	\x02\u{85c}\u{85f}\x05\x06\x04\x02\u{85d}\u{85f}\x07\x05\x02\x02\u{85e}\
	\u{85b}\x03\x02\x02\x02\u{85e}\u{85c}\x03\x02\x02\x02\u{85e}\u{85d}\x03\
	\x02\x02\x02\u{85f}\u{864}\x03\x02\x02\x02\u{860}\u{861}\x07\x4a\x02\x02\
	\u{861}\u{863}\x07\x4b\x02\x02\u{862}\u{860}\x03\x02\x02\x02\u{863}\u{866}\
	\x03\x02\x02\x02\u{864}\u{862}\x03\x02\x02\x02\u{864}\u{865}\x03\x02\x02\
	\x02\u{865}\u{867}\x03\x02\x02\x02\u{866}\u{864}\x03\x02\x02\x02\u{867}\
	\u{868}\x07\x4e\x02\x02\u{868}\u{86d}\x07\x0b\x02\x02\u{869}\u{86a}\x07\
	\x3b\x02\x02\u{86a}\u{86b}\x07\x4e\x02\x02\u{86b}\u{86d}\x07\x0b\x02\x02\
	\u{86c}\u{85e}\x03\x02\x02\x02\u{86c}\u{869}\x03\x02\x02\x02\u{86d}\u{183}\
	\x03\x02\x02\x02\u{86e}\u{870}\x07\x23\x02\x02\u{86f}\u{871}\x05\x2a\x16\
	\x02\u{870}\u{86f}\x03\x02\x02\x02\u{870}\u{871}\x03\x02\x02\x02\u{871}\
	\u{875}\x03\x02\x02\x02\u{872}\u{874}\x05\u{f2}\x7a\x02\u{873}\u{872}\x03\
	\x02\x02\x02\u{874}\u{877}\x03\x02\x02\x02\u{875}\u{873}\x03\x02\x02\x02\
	\u{875}\u{876}\x03\x02\x02\x02\u{876}\u{878}\x03\x02\x02\x02\u{877}\u{875}\
	\x03\x02\x02\x02\u{878}\u{883}\x05\u{1ea}\u{f6}\x02\u{879}\u{87d}\x07\x4e\
	\x02\x02\u{87a}\u{87c}\x05\u{f2}\x7a\x02\u{87b}\u{87a}\x03\x02\x02\x02\u{87c}\
	\u{87f}\x03\x02\x02\x02\u{87d}\u{87b}\x03\x02\x02\x02\u{87d}\u{87e}\x03\
	\x02\x02\x02\u{87e}\u{880}\x03\x02\x02\x02\u{87f}\u{87d}\x03\x02\x02\x02\
	\u{880}\u{882}\x05\u{1ea}\u{f6}\x02\u{881}\u{879}\x03\x02\x02\x02\u{882}\
	\u{885}\x03\x02\x02\x02\u{883}\u{881}\x03\x02\x02\x02\u{883}\u{884}\x03\
	\x02\x02\x02\u{884}\u{887}\x03\x02\x02\x02\u{885}\u{883}\x03\x02\x02\x02\
	\u{886}\u{888}\x05\u{18a}\u{c6}\x02\u{887}\u{886}\x03\x02\x02\x02\u{887}\
	\u{888}\x03\x02\x02\x02\u{888}\u{889}\x03\x02\x02\x02\u{889}\u{88b}\x07\
	\x46\x02\x02\u{88a}\u{88c}\x05\u{19e}\u{d0}\x02\u{88b}\u{88a}\x03\x02\x02\
	\x02\u{88b}\u{88c}\x03\x02\x02\x02\u{88c}\u{88d}\x03\x02\x02\x02\u{88d}\
	\u{88f}\x07\x47\x02\x02\u{88e}\u{890}\x05\x6e\x38\x02\u{88f}\u{88e}\x03\
	\x02\x02\x02\u{88f}\u{890}\x03\x02\x02\x02\u{890}\u{8c2}\x03\x02\x02\x02\
	\u{891}\u{892}\x05\x3c\x1f\x02\u{892}\u{893}\x07\x4e\x02\x02\u{893}\u{895}\
	\x07\x23\x02\x02\u{894}\u{896}\x05\x2a\x16\x02\u{895}\u{894}\x03\x02\x02\
	\x02\u{895}\u{896}\x03\x02\x02\x02\u{896}\u{89a}\x03\x02\x02\x02\u{897}\
	\u{899}\x05\u{f2}\x7a\x02\u{898}\u{897}\x03\x02\x02\x02\u{899}\u{89c}\x03\
	\x02\x02\x02\u{89a}\u{898}\x03\x02\x02\x02\u{89a}\u{89b}\x03\x02\x02\x02\
	\u{89b}\u{89d}\x03\x02\x02\x02\u{89c}\u{89a}\x03\x02\x02\x02\u{89d}\u{89f}\
	\x05\u{1ea}\u{f6}\x02\u{89e}\u{8a0}\x05\u{18a}\u{c6}\x02\u{89f}\u{89e}\x03\
	\x02\x02\x02\u{89f}\u{8a0}\x03\x02\x02\x02\u{8a0}\u{8a1}\x03\x02\x02\x02\
	\u{8a1}\u{8a3}\x07\x46\x02\x02\u{8a2}\u{8a4}\x05\u{19e}\u{d0}\x02\u{8a3}\
	\u{8a2}\x03\x02\x02\x02\u{8a3}\u{8a4}\x03\x02\x02\x02\u{8a4}\u{8a5}\x03\
	\x02\x02\x02\u{8a5}\u{8a7}\x07\x47\x02\x02\u{8a6}\u{8a8}\x05\x6e\x38\x02\
	\u{8a7}\u{8a6}\x03\x02\x02\x02\u{8a7}\u{8a8}\x03\x02\x02\x02\u{8a8}\u{8c2}\
	\x03\x02\x02\x02\u{8a9}\u{8aa}\x05\u{16e}\u{b8}\x02\u{8aa}\u{8ab}\x07\x4e\
	\x02\x02\u{8ab}\u{8ad}\x07\x23\x02\x02\u{8ac}\u{8ae}\x05\x2a\x16\x02\u{8ad}\
	\u{8ac}\x03\x02\x02\x02\u{8ad}\u{8ae}\x03\x02\x02\x02\u{8ae}\u{8b2}\x03\
	\x02\x02\x02\u{8af}\u{8b1}\x05\u{f2}\x7a\x02\u{8b0}\u{8af}\x03\x02\x02\x02\
	\u{8b1}\u{8b4}\x03\x02\x02\x02\u{8b2}\u{8b0}\x03\x02\x02\x02\u{8b2}\u{8b3}\
	\x03\x02\x02\x02\u{8b3}\u{8b5}\x03\x02\x02\x02\u{8b4}\u{8b2}\x03\x02\x02\
	\x02\u{8b5}\u{8b7}\x05\u{1ea}\u{f6}\x02\u{8b6}\u{8b8}\x05\u{18a}\u{c6}\x02\
	\u{8b7}\u{8b6}\x03\x02\x02\x02\u{8b7}\u{8b8}\x03\x02\x02\x02\u{8b8}\u{8b9}\
	\x03\x02\x02\x02\u{8b9}\u{8bb}\x07\x46\x02\x02\u{8ba}\u{8bc}\x05\u{19e}\
	\u{d0}\x02\u{8bb}\u{8ba}\x03\x02\x02\x02\u{8bb}\u{8bc}\x03\x02\x02\x02\u{8bc}\
	\u{8bd}\x03\x02\x02\x02\u{8bd}\u{8bf}\x07\x47\x02\x02\u{8be}\u{8c0}\x05\
	\x6e\x38\x02\u{8bf}\u{8be}\x03\x02\x02\x02\u{8bf}\u{8c0}\x03\x02\x02\x02\
	\u{8c0}\u{8c2}\x03\x02\x02\x02\u{8c1}\u{86e}\x03\x02\x02\x02\u{8c1}\u{891}\
	\x03\x02\x02\x02\u{8c1}\u{8a9}\x03\x02\x02\x02\u{8c2}\u{185}\x03\x02\x02\
	\x02\u{8c3}\u{8c4}\x07\x4e\x02\x02\u{8c4}\u{8c6}\x07\x23\x02\x02\u{8c5}\
	\u{8c7}\x05\x2a\x16\x02\u{8c6}\u{8c5}\x03\x02\x02\x02\u{8c6}\u{8c7}\x03\
	\x02\x02\x02\u{8c7}\u{8cb}\x03\x02\x02\x02\u{8c8}\u{8ca}\x05\u{f2}\x7a\x02\
	\u{8c9}\u{8c8}\x03\x02\x02\x02\u{8ca}\u{8cd}\x03\x02\x02\x02\u{8cb}\u{8c9}\
	\x03\x02\x02\x02\u{8cb}\u{8cc}\x03\x02\x02\x02\u{8cc}\u{8ce}\x03\x02\x02\
	\x02\u{8cd}\u{8cb}\x03\x02\x02\x02\u{8ce}\u{8d0}\x05\u{1ea}\u{f6}\x02\u{8cf}\
	\u{8d1}\x05\u{18a}\u{c6}\x02\u{8d0}\u{8cf}\x03\x02\x02\x02\u{8d0}\u{8d1}\
	\x03\x02\x02\x02\u{8d1}\u{8d2}\x03\x02\x02\x02\u{8d2}\u{8d4}\x07\x46\x02\
	\x02\u{8d3}\u{8d5}\x05\u{19e}\u{d0}\x02\u{8d4}\u{8d3}\x03\x02\x02\x02\u{8d4}\
	\u{8d5}\x03\x02\x02\x02\u{8d5}\u{8d6}\x03\x02\x02\x02\u{8d6}\u{8d8}\x07\
	\x47\x02\x02\u{8d7}\u{8d9}\x05\x6e\x38\x02\u{8d8}\u{8d7}\x03\x02\x02\x02\
	\u{8d8}\u{8d9}\x03\x02\x02\x02\u{8d9}\u{187}\x03\x02\x02\x02\u{8da}\u{8dc}\
	\x07\x23\x02\x02\u{8db}\u{8dd}\x05\x2a\x16\x02\u{8dc}\u{8db}\x03\x02\x02\
	\x02\u{8dc}\u{8dd}\x03\x02\x02\x02\u{8dd}\u{8e1}\x03\x02\x02\x02\u{8de}\
	\u{8e0}\x05\u{f2}\x7a\x02\u{8df}\u{8de}\x03\x02\x02\x02\u{8e0}\u{8e3}\x03\
	\x02\x02\x02\u{8e1}\u{8df}\x03\x02\x02\x02\u{8e1}\u{8e2}\x03\x02\x02\x02\
	\u{8e2}\u{8e4}\x03\x02\x02\x02\u{8e3}\u{8e1}\x03\x02\x02\x02\u{8e4}\u{8ef}\
	\x05\u{1ea}\u{f6}\x02\u{8e5}\u{8e9}\x07\x4e\x02\x02\u{8e6}\u{8e8}\x05\u{f2}\
	\x7a\x02\u{8e7}\u{8e6}\x03\x02\x02\x02\u{8e8}\u{8eb}\x03\x02\x02\x02\u{8e9}\
	\u{8e7}\x03\x02\x02\x02\u{8e9}\u{8ea}\x03\x02\x02\x02\u{8ea}\u{8ec}\x03\
	\x02\x02\x02\u{8eb}\u{8e9}\x03\x02\x02\x02\u{8ec}\u{8ee}\x05\u{1ea}\u{f6}\
	\x02\u{8ed}\u{8e5}\x03\x02\x02\x02\u{8ee}\u{8f1}\x03\x02\x02\x02\u{8ef}\
	\u{8ed}\x03\x02\x02\x02\u{8ef}\u{8f0}\x03\x02\x02\x02\u{8f0}\u{8f3}\x03\
	\x02\x02\x02\u{8f1}\u{8ef}\x03\x02\x02\x02\u{8f2}\u{8f4}\x05\u{18a}\u{c6}\
	\x02\u{8f3}\u{8f2}\x03\x02\x02\x02\u{8f3}\u{8f4}\x03\x02\x02\x02\u{8f4}\
	\u{8f5}\x03\x02\x02\x02\u{8f5}\u{8f7}\x07\x46\x02\x02\u{8f6}\u{8f8}\x05\
	\u{19e}\u{d0}\x02\u{8f7}\u{8f6}\x03\x02\x02\x02\u{8f7}\u{8f8}\x03\x02\x02\
	\x02\u{8f8}\u{8f9}\x03\x02\x02\x02\u{8f9}\u{8fb}\x07\x47\x02\x02\u{8fa}\
	\u{8fc}\x05\x6e\x38\x02\u{8fb}\u{8fa}\x03\x02\x02\x02\u{8fb}\u{8fc}\x03\
	\x02\x02\x02\u{8fc}\u{916}\x03\x02\x02\x02\u{8fd}\u{8fe}\x05\x3c\x1f\x02\
	\u{8fe}\u{8ff}\x07\x4e\x02\x02\u{8ff}\u{901}\x07\x23\x02\x02\u{900}\u{902}\
	\x05\x2a\x16\x02\u{901}\u{900}\x03\x02\x02\x02\u{901}\u{902}\x03\x02\x02\
	\x02\u{902}\u{906}\x03\x02\x02\x02\u{903}\u{905}\x05\u{f2}\x7a\x02\u{904}\
	\u{903}\x03\x02\x02\x02\u{905}\u{908}\x03\x02\x02\x02\u{906}\u{904}\x03\
	\x02\x02\x02\u{906}\u{907}\x03\x02\x02\x02\u{907}\u{909}\x03\x02\x02\x02\
	\u{908}\u{906}\x03\x02\x02\x02\u{909}\u{90b}\x05\u{1ea}\u{f6}\x02\u{90a}\
	\u{90c}\x05\u{18a}\u{c6}\x02\u{90b}\u{90a}\x03\x02\x02\x02\u{90b}\u{90c}\
	\x03\x02\x02\x02\u{90c}\u{90d}\x03\x02\x02\x02\u{90d}\u{90f}\x07\x46\x02\
	\x02\u{90e}\u{910}\x05\u{19e}\u{d0}\x02\u{90f}\u{90e}\x03\x02\x02\x02\u{90f}\
	\u{910}\x03\x02\x02\x02\u{910}\u{911}\x03\x02\x02\x02\u{911}\u{913}\x07\
	\x47\x02\x02\u{912}\u{914}\x05\x6e\x38\x02\u{913}\u{912}\x03\x02\x02\x02\
	\u{913}\u{914}\x03\x02\x02\x02\u{914}\u{916}\x03\x02\x02\x02\u{915}\u{8da}\
	\x03\x02\x02\x02\u{915}\u{8fd}\x03\x02\x02\x02\u{916}\u{189}\x03\x02\x02\
	\x02\u{917}\u{91b}\x05\x2a\x16\x02\u{918}\u{919}\x07\x54\x02\x02\u{919}\
	\u{91b}\x07\x53\x02\x02\u{91a}\u{917}\x03\x02\x02\x02\u{91a}\u{918}\x03\
	\x02\x02\x02\u{91b}\u{18b}\x03\x02\x02\x02\u{91c}\u{91d}\x05\u{16e}\u{b8}\
	\x02\u{91d}\u{91e}\x07\x4e\x02\x02\u{91e}\u{91f}\x05\u{1ea}\u{f6}\x02\u{91f}\
	\u{92a}\x03\x02\x02\x02\u{920}\u{921}\x07\x30\x02\x02\u{921}\u{922}\x07\
	\x4e\x02\x02\u{922}\u{92a}\x05\u{1ea}\u{f6}\x02\u{923}\u{924}\x05\x38\x1d\
	\x02\u{924}\u{925}\x07\x4e\x02\x02\u{925}\u{926}\x07\x30\x02\x02\u{926}\
	\u{927}\x07\x4e\x02\x02\u{927}\u{928}\x05\u{1ea}\u{f6}\x02\u{928}\u{92a}\
	\x03\x02\x02\x02\u{929}\u{91c}\x03\x02\x02\x02\u{929}\u{920}\x03\x02\x02\
	\x02\u{929}\u{923}\x03\x02\x02\x02\u{92a}\u{18d}\x03\x02\x02\x02\u{92b}\
	\u{92c}\x07\x4e\x02\x02\u{92c}\u{92d}\x05\u{1ea}\u{f6}\x02\u{92d}\u{18f}\
	\x03\x02\x02\x02\u{92e}\u{92f}\x07\x30\x02\x02\u{92f}\u{930}\x07\x4e\x02\
	\x02\u{930}\u{938}\x05\u{1ea}\u{f6}\x02\u{931}\u{932}\x05\x38\x1d\x02\u{932}\
	\u{933}\x07\x4e\x02\x02\u{933}\u{934}\x07\x30\x02\x02\u{934}\u{935}\x07\
	\x4e\x02\x02\u{935}\u{936}\x05\u{1ea}\u{f6}\x02\u{936}\u{938}\x03\x02\x02\
	\x02\u{937}\u{92e}\x03\x02\x02\x02\u{937}\u{931}\x03\x02\x02\x02\u{938}\
	\u{191}\x03\x02\x02\x02\u{939}\u{93a}\x05\x3c\x1f\x02\u{93a}\u{93b}\x07\
	\x4a\x02\x02\u{93b}\u{93c}\x05\u{1ae}\u{d8}\x02\u{93c}\u{93d}\x07\x4b\x02\
	\x02\u{93d}\u{944}\x03\x02\x02\x02\u{93e}\u{93f}\x05\u{174}\u{bb}\x02\u{93f}\
	\u{940}\x07\x4a\x02\x02\u{940}\u{941}\x05\u{1ae}\u{d8}\x02\u{941}\u{942}\
	\x07\x4b\x02\x02\u{942}\u{944}\x03\x02\x02\x02\u{943}\u{939}\x03\x02\x02\
	\x02\u{943}\u{93e}\x03\x02\x02\x02\u{944}\u{94c}\x03\x02\x02\x02\u{945}\
	\u{946}\x05\u{172}\u{ba}\x02\u{946}\u{947}\x07\x4a\x02\x02\u{947}\u{948}\
	\x05\u{1ae}\u{d8}\x02\u{948}\u{949}\x07\x4b\x02\x02\u{949}\u{94b}\x03\x02\
	\x02\x02\u{94a}\u{945}\x03\x02\x02\x02\u{94b}\u{94e}\x03\x02\x02\x02\u{94c}\
	\u{94a}\x03\x02\x02\x02\u{94c}\u{94d}\x03\x02\x02\x02\u{94d}\u{193}\x03\
	\x02\x02\x02\u{94e}\u{94c}\x03\x02\x02\x02\u{94f}\u{950}\x05\u{17a}\u{be}\
	\x02\u{950}\u{951}\x07\x4a\x02\x02\u{951}\u{952}\x05\u{1ae}\u{d8}\x02\u{952}\
	\u{953}\x07\x4b\x02\x02\u{953}\u{95b}\x03\x02\x02\x02\u{954}\u{955}\x05\
	\u{178}\u{bd}\x02\u{955}\u{956}\x07\x4a\x02\x02\u{956}\u{957}\x05\u{1ae}\
	\u{d8}\x02\u{957}\u{958}\x07\x4b\x02\x02\u{958}\u{95a}\x03\x02\x02\x02\u{959}\
	\u{954}\x03\x02\x02\x02\u{95a}\u{95d}\x03\x02\x02\x02\u{95b}\u{959}\x03\
	\x02\x02\x02\u{95b}\u{95c}\x03\x02\x02\x02\u{95c}\u{195}\x03\x02\x02\x02\
	\u{95d}\u{95b}\x03\x02\x02\x02\u{95e}\u{95f}\x05\x3c\x1f\x02\u{95f}\u{960}\
	\x07\x4a\x02\x02\u{960}\u{961}\x05\u{1ae}\u{d8}\x02\u{961}\u{962}\x07\x4b\
	\x02\x02\u{962}\u{969}\x03\x02\x02\x02\u{963}\u{964}\x05\u{180}\u{c1}\x02\
	\u{964}\u{965}\x07\x4a\x02\x02\u{965}\u{966}\x05\u{1ae}\u{d8}\x02\u{966}\
	\u{967}\x07\x4b\x02\x02\u{967}\u{969}\x03\x02\x02\x02\u{968}\u{95e}\x03\
	\x02\x02\x02\u{968}\u{963}\x03\x02\x02\x02\u{969}\u{971}\x03\x02\x02\x02\
	\u{96a}\u{96b}\x05\u{17e}\u{c0}\x02\u{96b}\u{96c}\x07\x4a\x02\x02\u{96c}\
	\u{96d}\x05\u{1ae}\u{d8}\x02\u{96d}\u{96e}\x07\x4b\x02\x02\u{96e}\u{970}\
	\x03\x02\x02\x02\u{96f}\u{96a}\x03\x02\x02\x02\u{970}\u{973}\x03\x02\x02\
	\x02\u{971}\u{96f}\x03\x02\x02\x02\u{971}\u{972}\x03\x02\x02\x02\u{972}\
	\u{197}\x03\x02\x02\x02\u{973}\u{971}\x03\x02\x02\x02\u{974}\u{975}\x05\
	\x3e\x20\x02\u{975}\u{977}\x07\x46\x02\x02\u{976}\u{978}\x05\u{19e}\u{d0}\
	\x02\u{977}\u{976}\x03\x02\x02\x02\u{977}\u{978}\x03\x02\x02\x02\u{978}\
	\u{979}\x03\x02\x02\x02\u{979}\u{97a}\x07\x47\x02\x02\u{97a}\u{9ba}\x03\
	\x02\x02\x02\u{97b}\u{97c}\x05\x38\x1d\x02\u{97c}\u{97e}\x07\x4e\x02\x02\
	\u{97d}\u{97f}\x05\x2a\x16\x02\u{97e}\u{97d}\x03\x02\x02\x02\u{97e}\u{97f}\
	\x03\x02\x02\x02\u{97f}\u{980}\x03\x02\x02\x02\u{980}\u{981}\x05\u{1ea}\
	\u{f6}\x02\u{981}\u{983}\x07\x46\x02\x02\u{982}\u{984}\x05\u{19e}\u{d0}\
	\x02\u{983}\u{982}\x03\x02\x02\x02\u{983}\u{984}\x03\x02\x02\x02\u{984}\
	\u{985}\x03\x02\x02\x02\u{985}\u{986}\x07\x47\x02\x02\u{986}\u{9ba}\x03\
	\x02\x02\x02\u{987}\u{988}\x05\x3c\x1f\x02\u{988}\u{98a}\x07\x4e\x02\x02\
	\u{989}\u{98b}\x05\x2a\x16\x02\u{98a}\u{989}\x03\x02\x02\x02\u{98a}\u{98b}\
	\x03\x02\x02\x02\u{98b}\u{98c}\x03\x02\x02\x02\u{98c}\u{98d}\x05\u{1ea}\
	\u{f6}\x02\u{98d}\u{98f}\x07\x46\x02\x02\u{98e}\u{990}\x05\u{19e}\u{d0}\
	\x02\u{98f}\u{98e}\x03\x02\x02\x02\u{98f}\u{990}\x03\x02\x02\x02\u{990}\
	\u{991}\x03\x02\x02\x02\u{991}\u{992}\x07\x47\x02\x02\u{992}\u{9ba}\x03\
	\x02\x02\x02\u{993}\u{994}\x05\u{16e}\u{b8}\x02\u{994}\u{996}\x07\x4e\x02\
	\x02\u{995}\u{997}\x05\x2a\x16\x02\u{996}\u{995}\x03\x02\x02\x02\u{996}\
	\u{997}\x03\x02\x02\x02\u{997}\u{998}\x03\x02\x02\x02\u{998}\u{999}\x05\
	\u{1ea}\u{f6}\x02\u{999}\u{99b}\x07\x46\x02\x02\u{99a}\u{99c}\x05\u{19e}\
	\u{d0}\x02\u{99b}\u{99a}\x03\x02\x02\x02\u{99b}\u{99c}\x03\x02\x02\x02\u{99c}\
	\u{99d}\x03\x02\x02\x02\u{99d}\u{99e}\x07\x47\x02\x02\u{99e}\u{9ba}\x03\
	\x02\x02\x02\u{99f}\u{9a0}\x07\x30\x02\x02\u{9a0}\u{9a2}\x07\x4e\x02\x02\
	\u{9a1}\u{9a3}\x05\x2a\x16\x02\u{9a2}\u{9a1}\x03\x02\x02\x02\u{9a2}\u{9a3}\
	\x03\x02\x02\x02\u{9a3}\u{9a4}\x03\x02\x02\x02\u{9a4}\u{9a5}\x05\u{1ea}\
	\u{f6}\x02\u{9a5}\u{9a7}\x07\x46\x02\x02\u{9a6}\u{9a8}\x05\u{19e}\u{d0}\
	\x02\u{9a7}\u{9a6}\x03\x02\x02\x02\u{9a7}\u{9a8}\x03\x02\x02\x02\u{9a8}\
	\u{9a9}\x03\x02\x02\x02\u{9a9}\u{9aa}\x07\x47\x02\x02\u{9aa}\u{9ba}\x03\
	\x02\x02\x02\u{9ab}\u{9ac}\x05\x38\x1d\x02\u{9ac}\u{9ad}\x07\x4e\x02\x02\
	\u{9ad}\u{9ae}\x07\x30\x02\x02\u{9ae}\u{9b0}\x07\x4e\x02\x02\u{9af}\u{9b1}\
	\x05\x2a\x16\x02\u{9b0}\u{9af}\x03\x02\x02\x02\u{9b0}\u{9b1}\x03\x02\x02\
	\x02\u{9b1}\u{9b2}\x03\x02\x02\x02\u{9b2}\u{9b3}\x05\u{1ea}\u{f6}\x02\u{9b3}\
	\u{9b5}\x07\x46\x02\x02\u{9b4}\u{9b6}\x05\u{19e}\u{d0}\x02\u{9b5}\u{9b4}\
	\x03\x02\x02\x02\u{9b5}\u{9b6}\x03\x02\x02\x02\u{9b6}\u{9b7}\x03\x02\x02\
	\x02\u{9b7}\u{9b8}\x07\x47\x02\x02\u{9b8}\u{9ba}\x03\x02\x02\x02\u{9b9}\
	\u{974}\x03\x02\x02\x02\u{9b9}\u{97b}\x03\x02\x02\x02\u{9b9}\u{987}\x03\
	\x02\x02\x02\u{9b9}\u{993}\x03\x02\x02\x02\u{9b9}\u{99f}\x03\x02\x02\x02\
	\u{9b9}\u{9ab}\x03\x02\x02\x02\u{9ba}\u{199}\x03\x02\x02\x02\u{9bb}\u{9bd}\
	\x07\x4e\x02\x02\u{9bc}\u{9be}\x05\x2a\x16\x02\u{9bd}\u{9bc}\x03\x02\x02\
	\x02\u{9bd}\u{9be}\x03\x02\x02\x02\u{9be}\u{9bf}\x03\x02\x02\x02\u{9bf}\
	\u{9c0}\x05\u{1ea}\u{f6}\x02\u{9c0}\u{9c2}\x07\x46\x02\x02\u{9c1}\u{9c3}\
	\x05\u{19e}\u{d0}\x02\u{9c2}\u{9c1}\x03\x02\x02\x02\u{9c2}\u{9c3}\x03\x02\
	\x02\x02\u{9c3}\u{9c4}\x03\x02\x02\x02\u{9c4}\u{9c5}\x07\x47\x02\x02\u{9c5}\
	\u{19b}\x03\x02\x02\x02\u{9c6}\u{9c7}\x05\x3e\x20\x02\u{9c7}\u{9c9}\x07\
	\x46\x02\x02\u{9c8}\u{9ca}\x05\u{19e}\u{d0}\x02\u{9c9}\u{9c8}\x03\x02\x02\
	\x02\u{9c9}\u{9ca}\x03\x02\x02\x02\u{9ca}\u{9cb}\x03\x02\x02\x02\u{9cb}\
	\u{9cc}\x07\x47\x02\x02\u{9cc}\u{a00}\x03\x02\x02\x02\u{9cd}\u{9ce}\x05\
	\x38\x1d\x02\u{9ce}\u{9d0}\x07\x4e\x02\x02\u{9cf}\u{9d1}\x05\x2a\x16\x02\
	\u{9d0}\u{9cf}\x03\x02\x02\x02\u{9d0}\u{9d1}\x03\x02\x02\x02\u{9d1}\u{9d2}\
	\x03\x02\x02\x02\u{9d2}\u{9d3}\x05\u{1ea}\u{f6}\x02\u{9d3}\u{9d5}\x07\x46\
	\x02\x02\u{9d4}\u{9d6}\x05\u{19e}\u{d0}\x02\u{9d5}\u{9d4}\x03\x02\x02\x02\
	\u{9d5}\u{9d6}\x03\x02\x02\x02\u{9d6}\u{9d7}\x03\x02\x02\x02\u{9d7}\u{9d8}\
	\x07\x47\x02\x02\u{9d8}\u{a00}\x03\x02\x02\x02\u{9d9}\u{9da}\x05\x3c\x1f\
	\x02\u{9da}\u{9dc}\x07\x4e\x02\x02\u{9db}\u{9dd}\x05\x2a\x16\x02\u{9dc}\
	\u{9db}\x03\x02\x02\x02\u{9dc}\u{9dd}\x03\x02\x02\x02\u{9dd}\u{9de}\x03\
	\x02\x02\x02\u{9de}\u{9df}\x05\u{1ea}\u{f6}\x02\u{9df}\u{9e1}\x07\x46\x02\
	\x02\u{9e0}\u{9e2}\x05\u{19e}\u{d0}\x02\u{9e1}\u{9e0}\x03\x02\x02\x02\u{9e1}\
	\u{9e2}\x03\x02\x02\x02\u{9e2}\u{9e3}\x03\x02\x02\x02\u{9e3}\u{9e4}\x07\
	\x47\x02\x02\u{9e4}\u{a00}\x03\x02\x02\x02\u{9e5}\u{9e6}\x07\x30\x02\x02\
	\u{9e6}\u{9e8}\x07\x4e\x02\x02\u{9e7}\u{9e9}\x05\x2a\x16\x02\u{9e8}\u{9e7}\
	\x03\x02\x02\x02\u{9e8}\u{9e9}\x03\x02\x02\x02\u{9e9}\u{9ea}\x03\x02\x02\
	\x02\u{9ea}\u{9eb}\x05\u{1ea}\u{f6}\x02\u{9eb}\u{9ed}\x07\x46\x02\x02\u{9ec}\
	\u{9ee}\x05\u{19e}\u{d0}\x02\u{9ed}\u{9ec}\x03\x02\x02\x02\u{9ed}\u{9ee}\
	\x03\x02\x02\x02\u{9ee}\u{9ef}\x03\x02\x02\x02\u{9ef}\u{9f0}\x07\x47\x02\
	\x02\u{9f0}\u{a00}\x03\x02\x02\x02\u{9f1}\u{9f2}\x05\x38\x1d\x02\u{9f2}\
	\u{9f3}\x07\x4e\x02\x02\u{9f3}\u{9f4}\x07\x30\x02\x02\u{9f4}\u{9f6}\x07\
	\x4e\x02\x02\u{9f5}\u{9f7}\x05\x2a\x16\x02\u{9f6}\u{9f5}\x03\x02\x02\x02\
	\u{9f6}\u{9f7}\x03\x02\x02\x02\u{9f7}\u{9f8}\x03\x02\x02\x02\u{9f8}\u{9f9}\
	\x05\u{1ea}\u{f6}\x02\u{9f9}\u{9fb}\x07\x46\x02\x02\u{9fa}\u{9fc}\x05\u{19e}\
	\u{d0}\x02\u{9fb}\u{9fa}\x03\x02\x02\x02\u{9fb}\u{9fc}\x03\x02\x02\x02\u{9fc}\
	\u{9fd}\x03\x02\x02\x02\u{9fd}\u{9fe}\x07\x47\x02\x02\u{9fe}\u{a00}\x03\
	\x02\x02\x02\u{9ff}\u{9c6}\x03\x02\x02\x02\u{9ff}\u{9cd}\x03\x02\x02\x02\
	\u{9ff}\u{9d9}\x03\x02\x02\x02\u{9ff}\u{9e5}\x03\x02\x02\x02\u{9ff}\u{9f1}\
	\x03\x02\x02\x02\u{a00}\u{19d}\x03\x02\x02\x02\u{a01}\u{a06}\x05\u{1ae}\
	\u{d8}\x02\u{a02}\u{a03}\x07\x4d\x02\x02\u{a03}\u{a05}\x05\u{1ae}\u{d8}\
	\x02\u{a04}\u{a02}\x03\x02\x02\x02\u{a05}\u{a08}\x03\x02\x02\x02\u{a06}\
	\u{a04}\x03\x02\x02\x02\u{a06}\u{a07}\x03\x02\x02\x02\u{a07}\u{19f}\x03\
	\x02\x02\x02\u{a08}\u{a06}\x03\x02\x02\x02\u{a09}\u{a0a}\x05\x3c\x1f\x02\
	\u{a0a}\u{a0c}\x07\x51\x02\x02\u{a0b}\u{a0d}\x05\x2a\x16\x02\u{a0c}\u{a0b}\
	\x03\x02\x02\x02\u{a0c}\u{a0d}\x03\x02\x02\x02\u{a0d}\u{a0e}\x03\x02\x02\
	\x02\u{a0e}\u{a0f}\x05\u{1ea}\u{f6}\x02\u{a0f}\u{a39}\x03\x02\x02\x02\u{a10}\
	\u{a11}\x05\x0c\x07\x02\u{a11}\u{a13}\x07\x51\x02\x02\u{a12}\u{a14}\x05\
	\x2a\x16\x02\u{a13}\u{a12}\x03\x02\x02\x02\u{a13}\u{a14}\x03\x02\x02\x02\
	\u{a14}\u{a15}\x03\x02\x02\x02\u{a15}\u{a16}\x05\u{1ea}\u{f6}\x02\u{a16}\
	\u{a39}\x03\x02\x02\x02\u{a17}\u{a18}\x05\u{16e}\u{b8}\x02\u{a18}\u{a1a}\
	\x07\x51\x02\x02\u{a19}\u{a1b}\x05\x2a\x16\x02\u{a1a}\u{a19}\x03\x02\x02\
	\x02\u{a1a}\u{a1b}\x03\x02\x02\x02\u{a1b}\u{a1c}\x03\x02\x02\x02\u{a1c}\
	\u{a1d}\x05\u{1ea}\u{f6}\x02\u{a1d}\u{a39}\x03\x02\x02\x02\u{a1e}\u{a1f}\
	\x07\x30\x02\x02\u{a1f}\u{a21}\x07\x51\x02\x02\u{a20}\u{a22}\x05\x2a\x16\
	\x02\u{a21}\u{a20}\x03\x02\x02\x02\u{a21}\u{a22}\x03\x02\x02\x02\u{a22}\
	\u{a23}\x03\x02\x02\x02\u{a23}\u{a39}\x05\u{1ea}\u{f6}\x02\u{a24}\u{a25}\
	\x05\x38\x1d\x02\u{a25}\u{a26}\x07\x4e\x02\x02\u{a26}\u{a27}\x07\x30\x02\
	\x02\u{a27}\u{a29}\x07\x51\x02\x02\u{a28}\u{a2a}\x05\x2a\x16\x02\u{a29}\
	\u{a28}\x03\x02\x02\x02\u{a29}\u{a2a}\x03\x02\x02\x02\u{a2a}\u{a2b}\x03\
	\x02\x02\x02\u{a2b}\u{a2c}\x05\u{1ea}\u{f6}\x02\u{a2c}\u{a39}\x03\x02\x02\
	\x02\u{a2d}\u{a2e}\x05\x10\x09\x02\u{a2e}\u{a30}\x07\x51\x02\x02\u{a2f}\
	\u{a31}\x05\x2a\x16\x02\u{a30}\u{a2f}\x03\x02\x02\x02\u{a30}\u{a31}\x03\
	\x02\x02\x02\u{a31}\u{a32}\x03\x02\x02\x02\u{a32}\u{a33}\x07\x23\x02\x02\
	\u{a33}\u{a39}\x03\x02\x02\x02\u{a34}\u{a35}\x05\x1e\x10\x02\u{a35}\u{a36}\
	\x07\x51\x02\x02\u{a36}\u{a37}\x07\x23\x02\x02\u{a37}\u{a39}\x03\x02\x02\
	\x02\u{a38}\u{a09}\x03\x02\x02\x02\u{a38}\u{a10}\x03\x02\x02\x02\u{a38}\
	\u{a17}\x03\x02\x02\x02\u{a38}\u{a1e}\x03\x02\x02\x02\u{a38}\u{a24}\x03\
	\x02\x02\x02\u{a38}\u{a2d}\x03\x02\x02\x02\u{a38}\u{a34}\x03\x02\x02\x02\
	\u{a39}\u{1a1}\x03\x02\x02\x02\u{a3a}\u{a3c}\x07\x51\x02\x02\u{a3b}\u{a3d}\
	\x05\x2a\x16\x02\u{a3c}\u{a3b}\x03\x02\x02\x02\u{a3c}\u{a3d}\x03\x02\x02\
	\x02\u{a3d}\u{a3e}\x03\x02\x02\x02\u{a3e}\u{a3f}\x05\u{1ea}\u{f6}\x02\u{a3f}\
	\u{1a3}\x03\x02\x02\x02\u{a40}\u{a41}\x05\x3c\x1f\x02\u{a41}\u{a43}\x07\
	\x51\x02\x02\u{a42}\u{a44}\x05\x2a\x16\x02\u{a43}\u{a42}\x03\x02\x02\x02\
	\u{a43}\u{a44}\x03\x02\x02\x02\u{a44}\u{a45}\x03\x02\x02\x02\u{a45}\u{a46}\
	\x05\u{1ea}\u{f6}\x02\u{a46}\u{a69}\x03\x02\x02\x02\u{a47}\u{a48}\x05\x0c\
	\x07\x02\u{a48}\u{a4a}\x07\x51\x02\x02\u{a49}\u{a4b}\x05\x2a\x16\x02\u{a4a}\
	\u{a49}\x03\x02\x02\x02\u{a4a}\u{a4b}\x03\x02\x02\x02\u{a4b}\u{a4c}\x03\
	\x02\x02\x02\u{a4c}\u{a4d}\x05\u{1ea}\u{f6}\x02\u{a4d}\u{a69}\x03\x02\x02\
	\x02\u{a4e}\u{a4f}\x07\x30\x02\x02\u{a4f}\u{a51}\x07\x51\x02\x02\u{a50}\
	\u{a52}\x05\x2a\x16\x02\u{a51}\u{a50}\x03\x02\x02\x02\u{a51}\u{a52}\x03\
	\x02\x02\x02\u{a52}\u{a53}\x03\x02\x02\x02\u{a53}\u{a69}\x05\u{1ea}\u{f6}\
	\x02\u{a54}\u{a55}\x05\x38\x1d\x02\u{a55}\u{a56}\x07\x4e\x02\x02\u{a56}\
	\u{a57}\x07\x30\x02\x02\u{a57}\u{a59}\x07\x51\x02\x02\u{a58}\u{a5a}\x05\
	\x2a\x16\x02\u{a59}\u{a58}\x03\x02\x02\x02\u{a59}\u{a5a}\x03\x02\x02\x02\
	\u{a5a}\u{a5b}\x03\x02\x02\x02\u{a5b}\u{a5c}\x05\u{1ea}\u{f6}\x02\u{a5c}\
	\u{a69}\x03\x02\x02\x02\u{a5d}\u{a5e}\x05\x10\x09\x02\u{a5e}\u{a60}\x07\
	\x51\x02\x02\u{a5f}\u{a61}\x05\x2a\x16\x02\u{a60}\u{a5f}\x03\x02\x02\x02\
	\u{a60}\u{a61}\x03\x02\x02\x02\u{a61}\u{a62}\x03\x02\x02\x02\u{a62}\u{a63}\
	\x07\x23\x02\x02\u{a63}\u{a69}\x03\x02\x02\x02\u{a64}\u{a65}\x05\x1e\x10\
	\x02\u{a65}\u{a66}\x07\x51\x02\x02\u{a66}\u{a67}\x07\x23\x02\x02\u{a67}\
	\u{a69}\x03\x02\x02\x02\u{a68}\u{a40}\x03\x02\x02\x02\u{a68}\u{a47}\x03\
	\x02\x02\x02\u{a68}\u{a4e}\x03\x02\x02\x02\u{a68}\u{a54}\x03\x02\x02\x02\
	\u{a68}\u{a5d}\x03\x02\x02\x02\u{a68}\u{a64}\x03\x02\x02\x02\u{a69}\u{1a5}\
	\x03\x02\x02\x02\u{a6a}\u{a6b}\x07\x23\x02\x02\u{a6b}\u{a6c}\x05\x04\x03\
	\x02\u{a6c}\u{a6e}\x05\u{1a8}\u{d5}\x02\u{a6d}\u{a6f}\x05\x20\x11\x02\u{a6e}\
	\u{a6d}\x03\x02\x02\x02\u{a6e}\u{a6f}\x03\x02\x02\x02\u{a6f}\u{a81}\x03\
	\x02\x02\x02\u{a70}\u{a71}\x07\x23\x02\x02\u{a71}\u{a72}\x05\x0e\x08\x02\
	\u{a72}\u{a74}\x05\u{1a8}\u{d5}\x02\u{a73}\u{a75}\x05\x20\x11\x02\u{a74}\
	\u{a73}\x03\x02\x02\x02\u{a74}\u{a75}\x03\x02\x02\x02\u{a75}\u{a81}\x03\
	\x02\x02\x02\u{a76}\u{a77}\x07\x23\x02\x02\u{a77}\u{a78}\x05\x04\x03\x02\
	\u{a78}\u{a79}\x05\x20\x11\x02\u{a79}\u{a7a}\x05\u{104}\u{83}\x02\u{a7a}\
	\u{a81}\x03\x02\x02\x02\u{a7b}\u{a7c}\x07\x23\x02\x02\u{a7c}\u{a7d}\x05\
	\x0e\x08\x02\u{a7d}\u{a7e}\x05\x20\x11\x02\u{a7e}\u{a7f}\x05\u{104}\u{83}\
	\x02\u{a7f}\u{a81}\x03\x02\x02\x02\u{a80}\u{a6a}\x03\x02\x02\x02\u{a80}\
	\u{a70}\x03\x02\x02\x02\u{a80}\u{a76}\x03\x02\x02\x02\u{a80}\u{a7b}\x03\
	\x02\x02\x02\u{a81}\u{1a7}\x03\x02\x02\x02\u{a82}\u{a84}\x05\u{1aa}\u{d6}\
	\x02\u{a83}\u{a82}\x03\x02\x02\x02\u{a84}\u{a85}\x03\x02\x02\x02\u{a85}\
	\u{a83}\x03\x02\x02\x02\u{a85}\u{a86}\x03\x02\x02\x02\u{a86}\u{1a9}\x03\
	\x02\x02\x02\u{a87}\u{a89}\x05\u{f2}\x7a\x02\u{a88}\u{a87}\x03\x02\x02\x02\
	\u{a89}\u{a8c}\x03\x02\x02\x02\u{a8a}\u{a88}\x03\x02\x02\x02\u{a8a}\u{a8b}\
	\x03\x02\x02\x02\u{a8b}\u{a8d}\x03\x02\x02\x02\u{a8c}\u{a8a}\x03\x02\x02\
	\x02\u{a8d}\u{a8e}\x07\x4a\x02\x02\u{a8e}\u{a8f}\x05\u{1ae}\u{d8}\x02\u{a8f}\
	\u{a90}\x07\x4b\x02\x02\u{a90}\u{1ab}\x03\x02\x02\x02\u{a91}\u{a92}\x05\
	\u{1ae}\u{d8}\x02\u{a92}\u{1ad}\x03\x02\x02\x02\u{a93}\u{a96}\x05\u{1b0}\
	\u{d9}\x02\u{a94}\u{a96}\x05\u{1b8}\u{dd}\x02\u{a95}\u{a93}\x03\x02\x02\
	\x02\u{a95}\u{a94}\x03\x02\x02\x02\u{a96}\u{1af}\x03\x02\x02\x02\u{a97}\
	\u{a98}\x05\u{1b2}\u{da}\x02\u{a98}\u{a99}\x07\x59\x02\x02\u{a99}\u{a9a}\
	\x05\u{1b6}\u{dc}\x02\u{a9a}\u{1b1}\x03\x02\x02\x02\u{a9b}\u{aa6}\x05\u{1ea}\
	\u{f6}\x02\u{a9c}\u{a9e}\x07\x46\x02\x02\u{a9d}\u{a9f}\x05\u{a2}\x52\x02\
	\u{a9e}\u{a9d}\x03\x02\x02\x02\u{a9e}\u{a9f}\x03\x02\x02\x02\u{a9f}\u{aa0}\
	\x03\x02\x02\x02\u{aa0}\u{aa6}\x07\x47\x02\x02\u{aa1}\u{aa2}\x07\x46\x02\
	\x02\u{aa2}\u{aa3}\x05\u{1b4}\u{db}\x02\u{aa3}\u{aa4}\x07\x47\x02\x02\u{aa4}\
	\u{aa6}\x03\x02\x02\x02\u{aa5}\u{a9b}\x03\x02\x02\x02\u{aa5}\u{a9c}\x03\
	\x02\x02\x02\u{aa5}\u{aa1}\x03\x02\x02\x02\u{aa6}\u{1b3}\x03\x02\x02\x02\
	\u{aa7}\u{aac}\x05\u{1ea}\u{f6}\x02\u{aa8}\u{aa9}\x07\x4d\x02\x02\u{aa9}\
	\u{aab}\x05\u{1ea}\u{f6}\x02\u{aaa}\u{aa8}\x03\x02\x02\x02\u{aab}\u{aae}\
	\x03\x02\x02\x02\u{aac}\u{aaa}\x03\x02\x02\x02\u{aac}\u{aad}\x03\x02\x02\
	\x02\u{aad}\u{1b5}\x03\x02\x02\x02\u{aae}\u{aac}\x03\x02\x02\x02\u{aaf}\
	\u{ab2}\x05\u{1ae}\u{d8}\x02\u{ab0}\u{ab2}\x05\u{108}\u{85}\x02\u{ab1}\u{aaf}\
	\x03\x02\x02\x02\u{ab1}\u{ab0}\x03\x02\x02\x02\u{ab2}\u{1b7}\x03\x02\x02\
	\x02\u{ab3}\u{ab6}\x05\u{1c0}\u{e1}\x02\u{ab4}\u{ab6}\x05\u{1ba}\u{de}\x02\
	\u{ab5}\u{ab3}\x03\x02\x02\x02\u{ab5}\u{ab4}\x03\x02\x02\x02\u{ab6}\u{1b9}\
	\x03\x02\x02\x02\u{ab7}\u{ab8}\x05\u{1bc}\u{df}\x02\u{ab8}\u{ab9}\x05\u{1be}\
	\u{e0}\x02\u{ab9}\u{aba}\x05\u{1ae}\u{d8}\x02\u{aba}\u{1bb}\x03\x02\x02\
	\x02\u{abb}\u{abf}\x05\x3c\x1f\x02\u{abc}\u{abf}\x05\u{18c}\u{c7}\x02\u{abd}\
	\u{abf}\x05\u{192}\u{ca}\x02\u{abe}\u{abb}\x03\x02\x02\x02\u{abe}\u{abc}\
	\x03\x02\x02\x02\u{abe}\u{abd}\x03\x02\x02\x02\u{abf}\u{1bd}\x03\x02\x02\
	\x02\u{ac0}\u{ac1}\x09\x06\x02\x02\u{ac1}\u{1bf}\x03\x02\x02\x02\u{ac2}\
	\u{acc}\x05\u{1c2}\u{e2}\x02\u{ac3}\u{ac4}\x05\u{1c2}\u{e2}\x02\u{ac4}\u{ac5}\
	\x07\x57\x02\x02\u{ac5}\u{ac6}\x05\u{1ae}\u{d8}\x02\u{ac6}\u{ac9}\x07\x58\
	\x02\x02\u{ac7}\u{aca}\x05\u{1c0}\u{e1}\x02\u{ac8}\u{aca}\x05\u{1b0}\u{d9}\
	\x02\u{ac9}\u{ac7}\x03\x02\x02\x02\u{ac9}\u{ac8}\x03\x02\x02\x02\u{aca}\
	\u{acc}\x03\x02\x02\x02\u{acb}\u{ac2}\x03\x02\x02\x02\u{acb}\u{ac3}\x03\
	\x02\x02\x02\u{acc}\u{1c1}\x03\x02\x02\x02\u{acd}\u{ace}\x08\u{e2}\x01\x02\
	\u{ace}\u{acf}\x05\u{1c4}\u{e3}\x02\u{acf}\u{ad5}\x03\x02\x02\x02\u{ad0}\
	\u{ad1}\x0c\x03\x02\x02\u{ad1}\u{ad2}\x07\x5f\x02\x02\u{ad2}\u{ad4}\x05\
	\u{1c4}\u{e3}\x02\u{ad3}\u{ad0}\x03\x02\x02\x02\u{ad4}\u{ad7}\x03\x02\x02\
	\x02\u{ad5}\u{ad3}\x03\x02\x02\x02\u{ad5}\u{ad6}\x03\x02\x02\x02\u{ad6}\
	\u{1c3}\x03\x02\x02\x02\u{ad7}\u{ad5}\x03\x02\x02\x02\u{ad8}\u{ad9}\x08\
	\u{e3}\x01\x02\u{ad9}\u{ada}\x05\u{1c6}\u{e4}\x02\u{ada}\u{ae0}\x03\x02\
	\x02\x02\u{adb}\u{adc}\x0c\x03\x02\x02\u{adc}\u{add}\x07\x5e\x02\x02\u{add}\
	\u{adf}\x05\u{1c6}\u{e4}\x02\u{ade}\u{adb}\x03\x02\x02\x02\u{adf}\u{ae2}\
	\x03\x02\x02\x02\u{ae0}\u{ade}\x03\x02\x02\x02\u{ae0}\u{ae1}\x03\x02\x02\
	\x02\u{ae1}\u{1c5}\x03\x02\x02\x02\u{ae2}\u{ae0}\x03\x02\x02\x02\u{ae3}\
	\u{ae4}\x08\u{e4}\x01\x02\u{ae4}\u{ae5}\x05\u{1c8}\u{e5}\x02\u{ae5}\u{aeb}\
	\x03\x02\x02\x02\u{ae6}\u{ae7}\x0c\x03\x02\x02\u{ae7}\u{ae8}\x07\x67\x02\
	\x02\u{ae8}\u{aea}\x05\u{1c8}\u{e5}\x02\u{ae9}\u{ae6}\x03\x02\x02\x02\u{aea}\
	\u{aed}\x03\x02\x02\x02\u{aeb}\u{ae9}\x03\x02\x02\x02\u{aeb}\u{aec}\x03\
	\x02\x02\x02\u{aec}\u{1c7}\x03\x02\x02\x02\u{aed}\u{aeb}\x03\x02\x02\x02\
	\u{aee}\u{aef}\x08\u{e5}\x01\x02\u{aef}\u{af0}\x05\u{1ca}\u{e6}\x02\u{af0}\
	\u{af6}\x03\x02\x02\x02\u{af1}\u{af2}\x0c\x03\x02\x02\u{af2}\u{af3}\x07\
	\x68\x02\x02\u{af3}\u{af5}\x05\u{1ca}\u{e6}\x02\u{af4}\u{af1}\x03\x02\x02\
	\x02\u{af5}\u{af8}\x03\x02\x02\x02\u{af6}\u{af4}\x03\x02\x02\x02\u{af6}\
	\u{af7}\x03\x02\x02\x02\u{af7}\u{1c9}\x03\x02\x02\x02\u{af8}\u{af6}\x03\
	\x02\x02\x02\u{af9}\u{afa}\x08\u{e6}\x01\x02\u{afa}\u{afb}\x05\u{1cc}\u{e7}\
	\x02\u{afb}\u{b01}\x03\x02\x02\x02\u{afc}\u{afd}\x0c\x03\x02\x02\u{afd}\
	\u{afe}\x07\x66\x02\x02\u{afe}\u{b00}\x05\u{1cc}\u{e7}\x02\u{aff}\u{afc}\
	\x03\x02\x02\x02\u{b00}\u{b03}\x03\x02\x02\x02\u{b01}\u{aff}\x03\x02\x02\
	\x02\u{b01}\u{b02}\x03\x02\x02\x02\u{b02}\u{1cb}\x03\x02\x02\x02\u{b03}\
	\u{b01}\x03\x02\x02\x02\u{b04}\u{b05}\x08\u{e7}\x01\x02\u{b05}\u{b06}\x05\
	\u{1ce}\u{e8}\x02\u{b06}\u{b0f}\x03\x02\x02\x02\u{b07}\u{b08}\x0c\x04\x02\
	\x02\u{b08}\u{b09}\x07\x5a\x02\x02\u{b09}\u{b0e}\x05\u{1ce}\u{e8}\x02\u{b0a}\
	\u{b0b}\x0c\x03\x02\x02\u{b0b}\u{b0c}\x07\x5d\x02\x02\u{b0c}\u{b0e}\x05\
	\u{1ce}\u{e8}\x02\u{b0d}\u{b07}\x03\x02\x02\x02\u{b0d}\u{b0a}\x03\x02\x02\
	\x02\u{b0e}\u{b11}\x03\x02\x02\x02\u{b0f}\u{b0d}\x03\x02\x02\x02\u{b0f}\
	\u{b10}\x03\x02\x02\x02\u{b10}\u{1cd}\x03\x02\x02\x02\u{b11}\u{b0f}\x03\
	\x02\x02\x02\u{b12}\u{b13}\x08\u{e8}\x01\x02\u{b13}\u{b14}\x05\u{1d0}\u{e9}\
	\x02\u{b14}\u{b26}\x03\x02\x02\x02\u{b15}\u{b16}\x0c\x07\x02\x02\u{b16}\
	\u{b17}\x07\x54\x02\x02\u{b17}\u{b25}\x05\u{1d0}\u{e9}\x02\u{b18}\u{b19}\
	\x0c\x06\x02\x02\u{b19}\u{b1a}\x07\x53\x02\x02\u{b1a}\u{b25}\x05\u{1d0}\
	\u{e9}\x02\u{b1b}\u{b1c}\x0c\x05\x02\x02\u{b1c}\u{b1d}\x07\x5b\x02\x02\u{b1d}\
	\u{b25}\x05\u{1d0}\u{e9}\x02\u{b1e}\u{b1f}\x0c\x04\x02\x02\u{b1f}\u{b20}\
	\x07\x5c\x02\x02\u{b20}\u{b25}\x05\u{1d0}\u{e9}\x02\u{b21}\u{b22}\x0c\x03\
	\x02\x02\u{b22}\u{b23}\x07\x1d\x02\x02\u{b23}\u{b25}\x05\x0c\x07\x02\u{b24}\
	\u{b15}\x03\x02\x02\x02\u{b24}\u{b18}\x03\x02\x02\x02\u{b24}\u{b1b}\x03\
	\x02\x02\x02\u{b24}\u{b1e}\x03\x02\x02\x02\u{b24}\u{b21}\x03\x02\x02\x02\
	\u{b25}\u{b28}\x03\x02\x02\x02\u{b26}\u{b24}\x03\x02\x02\x02\u{b26}\u{b27}\
	\x03\x02\x02\x02\u{b27}\u{1cf}\x03\x02\x02\x02\u{b28}\u{b26}\x03\x02\x02\
	\x02\u{b29}\u{b2a}\x08\u{e9}\x01\x02\u{b2a}\u{b2b}\x05\u{1d2}\u{ea}\x02\
	\u{b2b}\u{b3b}\x03\x02\x02\x02\u{b2c}\u{b2d}\x0c\x05\x02\x02\u{b2d}\u{b2e}\
	\x07\x54\x02\x02\u{b2e}\u{b2f}\x07\x54\x02\x02\u{b2f}\u{b3a}\x05\u{1d2}\
	\u{ea}\x02\u{b30}\u{b31}\x0c\x04\x02\x02\u{b31}\u{b32}\x07\x53\x02\x02\u{b32}\
	\u{b33}\x07\x53\x02\x02\u{b33}\u{b3a}\x05\u{1d2}\u{ea}\x02\u{b34}\u{b35}\
	\x0c\x03\x02\x02\u{b35}\u{b36}\x07\x53\x02\x02\u{b36}\u{b37}\x07\x53\x02\
	\x02\u{b37}\u{b38}\x07\x53\x02\x02\u{b38}\u{b3a}\x05\u{1d2}\u{ea}\x02\u{b39}\
	\u{b2c}\x03\x02\x02\x02\u{b39}\u{b30}\x03\x02\x02\x02\u{b39}\u{b34}\x03\
	\x02\x02\x02\u{b3a}\u{b3d}\x03\x02\x02\x02\u{b3b}\u{b39}\x03\x02\x02\x02\
	\u{b3b}\u{b3c}\x03\x02\x02\x02\u{b3c}\u{1d1}\x03\x02\x02\x02\u{b3d}\u{b3b}\
	\x03\x02\x02\x02\u{b3e}\u{b3f}\x08\u{ea}\x01\x02\u{b3f}\u{b40}\x05\u{1d4}\
	\u{eb}\x02\u{b40}\u{b49}\x03\x02\x02\x02\u{b41}\u{b42}\x0c\x04\x02\x02\u{b42}\
	\u{b43}\x07\x62\x02\x02\u{b43}\u{b48}\x05\u{1d4}\u{eb}\x02\u{b44}\u{b45}\
	\x0c\x03\x02\x02\u{b45}\u{b46}\x07\x63\x02\x02\u{b46}\u{b48}\x05\u{1d4}\
	\u{eb}\x02\u{b47}\u{b41}\x03\x02\x02\x02\u{b47}\u{b44}\x03\x02\x02\x02\u{b48}\
	\u{b4b}\x03\x02\x02\x02\u{b49}\u{b47}\x03\x02\x02\x02\u{b49}\u{b4a}\x03\
	\x02\x02\x02\u{b4a}\u{1d3}\x03\x02\x02\x02\u{b4b}\u{b49}\x03\x02\x02\x02\
	\u{b4c}\u{b4d}\x08\u{eb}\x01\x02\u{b4d}\u{b4e}\x05\u{1d6}\u{ec}\x02\u{b4e}\
	\u{b5a}\x03\x02\x02\x02\u{b4f}\u{b50}\x0c\x05\x02\x02\u{b50}\u{b51}\x07\
	\x64\x02\x02\u{b51}\u{b59}\x05\u{1d6}\u{ec}\x02\u{b52}\u{b53}\x0c\x04\x02\
	\x02\u{b53}\u{b54}\x07\x65\x02\x02\u{b54}\u{b59}\x05\u{1d6}\u{ec}\x02\u{b55}\
	\u{b56}\x0c\x03\x02\x02\u{b56}\u{b57}\x07\x69\x02\x02\u{b57}\u{b59}\x05\
	\u{1d6}\u{ec}\x02\u{b58}\u{b4f}\x03\x02\x02\x02\u{b58}\u{b52}\x03\x02\x02\
	\x02\u{b58}\u{b55}\x03\x02\x02\x02\u{b59}\u{b5c}\x03\x02\x02\x02\u{b5a}\
	\u{b58}\x03\x02\x02\x02\u{b5a}\u{b5b}\x03\x02\x02\x02\u{b5b}\u{1d5}\x03\
	\x02\x02\x02\u{b5c}\u{b5a}\x03\x02\x02\x02\u{b5d}\u{b65}\x05\u{1d8}\u{ed}\
	\x02\u{b5e}\u{b65}\x05\u{1da}\u{ee}\x02\u{b5f}\u{b60}\x07\x62\x02\x02\u{b60}\
	\u{b65}\x05\u{1d6}\u{ec}\x02\u{b61}\u{b62}\x07\x63\x02\x02\u{b62}\u{b65}\
	\x05\u{1d6}\u{ec}\x02\u{b63}\u{b65}\x05\u{1dc}\u{ef}\x02\u{b64}\u{b5d}\x03\
	\x02\x02\x02\u{b64}\u{b5e}\x03\x02\x02\x02\u{b64}\u{b5f}\x03\x02\x02\x02\
	\u{b64}\u{b61}\x03\x02\x02\x02\u{b64}\u{b63}\x03\x02\x02\x02\u{b65}\u{1d7}\
	\x03\x02\x02\x02\u{b66}\u{b67}\x07\x60\x02\x02\u{b67}\u{b68}\x05\u{1d6}\
	\u{ec}\x02\u{b68}\u{1d9}\x03\x02\x02\x02\u{b69}\u{b6a}\x07\x61\x02\x02\u{b6a}\
	\u{b6b}\x05\u{1d6}\u{ec}\x02\u{b6b}\u{1db}\x03\x02\x02\x02\u{b6c}\u{b73}\
	\x05\u{1de}\u{f0}\x02\u{b6d}\u{b6e}\x07\x56\x02\x02\u{b6e}\u{b73}\x05\u{1d6}\
	\u{ec}\x02\u{b6f}\u{b70}\x07\x55\x02\x02\u{b70}\u{b73}\x05\u{1d6}\u{ec}\
	\x02\u{b71}\u{b73}\x05\u{1e8}\u{f5}\x02\u{b72}\u{b6c}\x03\x02\x02\x02\u{b72}\
	\u{b6d}\x03\x02\x02\x02\u{b72}\u{b6f}\x03\x02\x02\x02\u{b72}\u{b71}\x03\
	\x02\x02\x02\u{b73}\u{1dd}\x03\x02\x02\x02\u{b74}\u{b77}\x05\u{16e}\u{b8}\
	\x02\u{b75}\u{b77}\x05\x3c\x1f\x02\u{b76}\u{b74}\x03\x02\x02\x02\u{b76}\
	\u{b75}\x03\x02\x02\x02\u{b77}\u{b7c}\x03\x02\x02\x02\u{b78}\u{b7b}\x05\
	\u{1e2}\u{f2}\x02\u{b79}\u{b7b}\x05\u{1e6}\u{f4}\x02\u{b7a}\u{b78}\x03\x02\
	\x02\x02\u{b7a}\u{b79}\x03\x02\x02\x02\u{b7b}\u{b7e}\x03\x02\x02\x02\u{b7c}\
	\u{b7a}\x03\x02\x02\x02\u{b7c}\u{b7d}\x03\x02\x02\x02\u{b7d}\u{1df}\x03\
	\x02\x02\x02\u{b7e}\u{b7c}\x03\x02\x02\x02\u{b7f}\u{b80}\x05\u{1de}\u{f0}\
	\x02\u{b80}\u{b81}\x07\x60\x02\x02\u{b81}\u{1e1}\x03\x02\x02\x02\u{b82}\
	\u{b83}\x07\x60\x02\x02\u{b83}\u{1e3}\x03\x02\x02\x02\u{b84}\u{b85}\x05\
	\u{1de}\u{f0}\x02\u{b85}\u{b86}\x07\x61\x02\x02\u{b86}\u{1e5}\x03\x02\x02\
	\x02\u{b87}\u{b88}\x07\x61\x02\x02\u{b88}\u{1e7}\x03\x02\x02\x02\u{b89}\
	\u{b8a}\x07\x46\x02\x02\u{b8a}\u{b8b}\x05\x04\x03\x02\u{b8b}\u{b8c}\x07\
	\x47\x02\x02\u{b8c}\u{b8d}\x05\u{1d6}\u{ec}\x02\u{b8d}\u{ba5}\x03\x02\x02\
	\x02\u{b8e}\u{b8f}\x07\x46\x02\x02\u{b8f}\u{b93}\x05\x0c\x07\x02\u{b90}\
	\u{b92}\x05\x28\x15\x02\u{b91}\u{b90}\x03\x02\x02\x02\u{b92}\u{b95}\x03\
	\x02\x02\x02\u{b93}\u{b91}\x03\x02\x02\x02\u{b93}\u{b94}\x03\x02\x02\x02\
	\u{b94}\u{b96}\x03\x02\x02\x02\u{b95}\u{b93}\x03\x02\x02\x02\u{b96}\u{b97}\
	\x07\x47\x02\x02\u{b97}\u{b98}\x05\u{1dc}\u{ef}\x02\u{b98}\u{ba5}\x03\x02\
	\x02\x02\u{b99}\u{b9a}\x07\x46\x02\x02\u{b9a}\u{b9e}\x05\x0c\x07\x02\u{b9b}\
	\u{b9d}\x05\x28\x15\x02\u{b9c}\u{b9b}\x03\x02\x02\x02\u{b9d}\u{ba0}\x03\
	\x02\x02\x02\u{b9e}\u{b9c}\x03\x02\x02\x02\u{b9e}\u{b9f}\x03\x02\x02\x02\
	\u{b9f}\u{ba1}\x03\x02\x02\x02\u{ba0}\u{b9e}\x03\x02\x02\x02\u{ba1}\u{ba2}\
	\x07\x47\x02\x02\u{ba2}\u{ba3}\x05\u{1b0}\u{d9}\x02\u{ba3}\u{ba5}\x03\x02\
	\x02\x02\u{ba4}\u{b89}\x03\x02\x02\x02\u{ba4}\u{b8e}\x03\x02\x02\x02\u{ba4}\
	\u{b99}\x03\x02\x02\x02\u{ba5}\u{1e9}\x03\x02\x02\x02\u{ba6}\u{ba7}\x09\
	\x07\x02\x02\u{ba7}\u{1eb}\x03\x02\x02\x02\u{156}\u{1f1}\u{1f8}\u{1fc}\u{200}\
	\u{209}\u{20d}\u{211}\u{213}\u{219}\u{21e}\u{225}\u{22a}\u{22c}\u{232}\u{237}\
	\u{23c}\u{241}\u{24c}\u{25a}\u{25f}\u{267}\u{26e}\u{274}\u{279}\u{284}\u{287}\
	\u{295}\u{29a}\u{29f}\u{2a4}\u{2aa}\u{2b4}\u{2bf}\u{2c7}\u{2d1}\u{2d9}\u{2e5}\
	\u{2ea}\u{2ef}\u{2f4}\u{2fa}\u{302}\u{30a}\u{317}\u{334}\u{339}\u{33d}\u{345}\
	\u{34e}\u{35c}\u{35f}\u{36b}\u{36e}\u{37e}\u{383}\u{389}\u{38e}\u{394}\u{397}\
	\u{39a}\u{3a6}\u{3b1}\u{3bf}\u{3c6}\u{3cf}\u{3d6}\u{3db}\u{3ea}\u{3f1}\u{3f7}\
	\u{3fb}\u{3ff}\u{403}\u{407}\u{40c}\u{410}\u{414}\u{416}\u{41b}\u{422}\u{427}\
	\u{429}\u{42f}\u{434}\u{438}\u{44b}\u{450}\u{460}\u{465}\u{46b}\u{471}\u{473}\
	\u{477}\u{47c}\u{480}\u{488}\u{48f}\u{497}\u{49a}\u{49f}\u{4a7}\u{4ac}\u{4b3}\
	\u{4ba}\u{4bf}\u{4c6}\u{4d2}\u{4d7}\u{4db}\u{4e5}\u{4ea}\u{4f2}\u{4f5}\u{4fa}\
	\u{502}\u{505}\u{50a}\u{50f}\u{514}\u{519}\u{520}\u{525}\u{52d}\u{532}\u{537}\
	\u{53c}\u{542}\u{548}\u{54b}\u{54e}\u{557}\u{55d}\u{563}\u{566}\u{569}\u{571}\
	\u{576}\u{57b}\u{581}\u{584}\u{58f}\u{598}\u{5a2}\u{5a7}\u{5b2}\u{5b7}\u{5c4}\
	\u{5c9}\u{5d5}\u{5df}\u{5e4}\u{5ec}\u{5ef}\u{5f6}\u{5fe}\u{604}\u{60d}\u{617}\
	\u{61b}\u{61e}\u{627}\u{635}\u{638}\u{641}\u{646}\u{64d}\u{652}\u{65a}\u{666}\
	\u{66d}\u{67b}\u{691}\u{6b3}\u{6bf}\u{6c5}\u{6d0}\u{6dc}\u{6f6}\u{6fa}\u{6ff}\
	\u{703}\u{707}\u{70f}\u{713}\u{717}\u{71e}\u{727}\u{72f}\u{73e}\u{74a}\u{750}\
	\u{756}\u{76b}\u{770}\u{775}\u{780}\u{78b}\u{795}\u{798}\u{79d}\u{7a6}\u{7ac}\
	\u{7b5}\u{7b9}\u{7bd}\u{7c2}\u{7d5}\u{7df}\u{7f5}\u{7fc}\u{804}\u{80c}\u{817}\
	\u{82e}\u{838}\u{843}\u{859}\u{85e}\u{864}\u{86c}\u{870}\u{875}\u{87d}\u{883}\
	\u{887}\u{88b}\u{88f}\u{895}\u{89a}\u{89f}\u{8a3}\u{8a7}\u{8ad}\u{8b2}\u{8b7}\
	\u{8bb}\u{8bf}\u{8c1}\u{8c6}\u{8cb}\u{8d0}\u{8d4}\u{8d8}\u{8dc}\u{8e1}\u{8e9}\
	\u{8ef}\u{8f3}\u{8f7}\u{8fb}\u{901}\u{906}\u{90b}\u{90f}\u{913}\u{915}\u{91a}\
	\u{929}\u{937}\u{943}\u{94c}\u{95b}\u{968}\u{971}\u{977}\u{97e}\u{983}\u{98a}\
	\u{98f}\u{996}\u{99b}\u{9a2}\u{9a7}\u{9b0}\u{9b5}\u{9b9}\u{9bd}\u{9c2}\u{9c9}\
	\u{9d0}\u{9d5}\u{9dc}\u{9e1}\u{9e8}\u{9ed}\u{9f6}\u{9fb}\u{9ff}\u{a06}\u{a0c}\
	\u{a13}\u{a1a}\u{a21}\u{a29}\u{a30}\u{a38}\u{a3c}\u{a43}\u{a4a}\u{a51}\u{a59}\
	\u{a60}\u{a68}\u{a6e}\u{a74}\u{a80}\u{a85}\u{a8a}\u{a95}\u{a9e}\u{aa5}\u{aac}\
	\u{ab1}\u{ab5}\u{abe}\u{ac9}\u{acb}\u{ad5}\u{ae0}\u{aeb}\u{af6}\u{b01}\u{b0d}\
	\u{b0f}\u{b24}\u{b26}\u{b39}\u{b3b}\u{b47}\u{b49}\u{b58}\u{b5a}\u{b64}\u{b72}\
	\u{b76}\u{b7a}\u{b7c}\u{b93}\u{b9e}\u{ba4}";

